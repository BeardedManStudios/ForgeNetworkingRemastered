{
    "docs": [
        {
            "location": "/", 
            "text": "User Manual (Forge Networking Remastered)\n\n\nWelcome to Forge Networking Remastered, we would like to personally thank you for electing to become a part of our journey into Networking systems and Software as a whole. You are here because you have become a premium supporter of the Forge Networking project!\n\n\nHere for the \nCode API\n?\n\n\nHere for the \nVideo Tutorials\n?\n\n\nForge Networking to Remastered Migration Guide\n\n\nFirst, we would like to \nthank you\n so much for supporting Forge Networking over the past two years and we are proud to bring you \nForge Networking Remastered\n!\n\n\nForge Networking Remastered (FNR) is a re-imagining of networking for Forge. We took everything we learned, all the feedback we could get and we started \nfrom scratch\n on FNR. We kept some of the helper classes such as \nObjectMapper\n and \nBMSByte\n as those were optimized classes just for generic network data transfer. Secondly, we started FNR with the thought of \nWeb Sockets\n and WebGL in mind. Though (at the time of this writing) WebGL support is not officially complete, we are working very hard to solidify this platform (mainly in relation to Unity integration and limitations). Thirdly we wanted to completely remove any kind of reflection \"magic\" that was in the system. In place of reflection we opted for generated class files and code, this makes debugging and tracking execution much easier to maintain and test.\n\n\nNow for the reveal of the biggest change to Forge Networking, the Network Object. We have replaced the old singular, monolithic \ninheritance\n network model in place of an \nattachment\n network model. Now you can write your code as you wish without overly intrusive and complicated code/reflection and have a more solid extendable model. We have also included the new \nNetwork Contract Wizard (NCW)\n which allows you to easily blueprint and review your network contracts without having to dig through tons of code. We have completely re-imagined networking to be more of a service, attachment, addon, and extension rather than an overly complex integrated model.\n\n\nOf course you will find many things that you once knew such as \nNetwork Instantiation\n, \nRemote Procedure Calls RPC\n, \nMainThreadManager\n (\nThreading in Unity\n) however you will find that some of the older models (such as \nNetSync\n ) have been removed. I know, I know, \nNetSync\n is awesome and it works kinda like UNET's \nSyncVar\n ; however, we believe we have a much simpler, more controlled, less magical, and more powerful approach to serializing network variables. Since we have abstracted all the network code to be an attachment, you will find a new fancy \nnetwork Object\n variable that is a part of the class you create. This object will house all of your network variables and allow you to set the sync time as well as access any variable from the network easily. This means you can \nchoose\n when to use the network variable, choices are good, yes?\n\n\n Also, the networkObject is powerful, it automatically detects changes to your variable (as a whole) and serializes only that variable as opposed to the whole network class!\n\n\nSo, what are the difference highlights?\n\n\n\n\nInstantiation\n is done through \nNetworkManager.Instance.Instantiate...\n\n\nRemote procedure calls\n are done through \nnetworkObject.SendRpc\n\n\nNetSync has become \nnetworkObject.[myVar]\n\n\nPrimarySocket has become \nNetworkManager.Instance.Networker\n (You can also get the networker from the \nnetworkObject\n )\n\n\nWriteCustom has become \nBinary\n (Check out the VOIP module for how to use Binary) Networking and NetworkingManager have been replaced by \nNetworkManager\n\n\nSo what are some of the new highlights?\n\n\nNetwork Contract Wizard (NCW)\n\n\nSupport for \nNAT hole punching\n\n\nMaster Server has Matchmaking\n\n\n\"Cherry picked\" network variable updating\n\n\nState rewinding\n\n\nNetwork error logging system\n\n\nThe Network Object\n\n\n\n\nNotes from Community\n\nDo not put NetworkManager into your scene, it will be spawned on its own\n\nDO NOT\n wrap your RPC calls in MainThreadManger.Run if you have the \"Use Main Thread Manager For RPCs\" enabled", 
            "title": "Home"
        }, 
        {
            "location": "/#user-manual-forge-networking-remastered", 
            "text": "Welcome to Forge Networking Remastered, we would like to personally thank you for electing to become a part of our journey into Networking systems and Software as a whole. You are here because you have become a premium supporter of the Forge Networking project!", 
            "title": "User Manual (Forge Networking Remastered)"
        }, 
        {
            "location": "/#here-for-the-code-api", 
            "text": "", 
            "title": "Here for the Code API?"
        }, 
        {
            "location": "/#here-for-the-video-tutorials", 
            "text": "", 
            "title": "Here for the Video Tutorials?"
        }, 
        {
            "location": "/#forge-networking-to-remastered-migration-guide", 
            "text": "First, we would like to  thank you  so much for supporting Forge Networking over the past two years and we are proud to bring you  Forge Networking Remastered !  Forge Networking Remastered (FNR) is a re-imagining of networking for Forge. We took everything we learned, all the feedback we could get and we started  from scratch  on FNR. We kept some of the helper classes such as  ObjectMapper  and  BMSByte  as those were optimized classes just for generic network data transfer. Secondly, we started FNR with the thought of  Web Sockets  and WebGL in mind. Though (at the time of this writing) WebGL support is not officially complete, we are working very hard to solidify this platform (mainly in relation to Unity integration and limitations). Thirdly we wanted to completely remove any kind of reflection \"magic\" that was in the system. In place of reflection we opted for generated class files and code, this makes debugging and tracking execution much easier to maintain and test.  Now for the reveal of the biggest change to Forge Networking, the Network Object. We have replaced the old singular, monolithic  inheritance  network model in place of an  attachment  network model. Now you can write your code as you wish without overly intrusive and complicated code/reflection and have a more solid extendable model. We have also included the new  Network Contract Wizard (NCW)  which allows you to easily blueprint and review your network contracts without having to dig through tons of code. We have completely re-imagined networking to be more of a service, attachment, addon, and extension rather than an overly complex integrated model.  Of course you will find many things that you once knew such as  Network Instantiation ,  Remote Procedure Calls RPC ,  MainThreadManager  ( Threading in Unity ) however you will find that some of the older models (such as  NetSync  ) have been removed. I know, I know,  NetSync  is awesome and it works kinda like UNET's  SyncVar  ; however, we believe we have a much simpler, more controlled, less magical, and more powerful approach to serializing network variables. Since we have abstracted all the network code to be an attachment, you will find a new fancy  network Object  variable that is a part of the class you create. This object will house all of your network variables and allow you to set the sync time as well as access any variable from the network easily. This means you can  choose  when to use the network variable, choices are good, yes?   Also, the networkObject is powerful, it automatically detects changes to your variable (as a whole) and serializes only that variable as opposed to the whole network class!  So, what are the difference highlights?   Instantiation  is done through  NetworkManager.Instance.Instantiate...  Remote procedure calls  are done through  networkObject.SendRpc  NetSync has become  networkObject.[myVar]  PrimarySocket has become  NetworkManager.Instance.Networker  (You can also get the networker from the  networkObject  )  WriteCustom has become  Binary  (Check out the VOIP module for how to use Binary) Networking and NetworkingManager have been replaced by  NetworkManager  So what are some of the new highlights?  Network Contract Wizard (NCW)  Support for  NAT hole punching  Master Server has Matchmaking  \"Cherry picked\" network variable updating  State rewinding  Network error logging system  The Network Object   Notes from Community \nDo not put NetworkManager into your scene, it will be spawned on its own DO NOT  wrap your RPC calls in MainThreadManger.Run if you have the \"Use Main Thread Manager For RPCs\" enabled", 
            "title": "Forge Networking to Remastered Migration Guide"
        }, 
        {
            "location": "/authoritative-design/", 
            "text": "Authoritative Design\n\n\nOften you will hear the term \nauthoritative server\n and in most cases, it is used to mean \nauthoritative game logic\n. So, we would like to first go over the difference between the two as we often state that Forge Networking (including Remastered) is \nauthoritative server\n by design.\n\n\nAuthoritative Server:  When all network traffic goes through the server before it is relayed to other clients. In other words, clients do not communicate with each other directly.\n\n\nAuthoritative Game Logic:  When all your game code is written in a way where the server is completely in control of the flow and owns all of the network objects. This is unique to your game and how your game plays, it can be complex based on your game and we would suggest exploring the idea of not having authoritative game logic unless your game requires it. Games that require it often are games that have long term tracking (such as Battlefield) or track data for users in a database (such as an MMO). Games that plan to have non-tracked multiplayer (such as Minecraft) would not opt into having full server authority due to the overhead of complexity.\n\n\nSo when we say that Forge Networking (and Remastered) is an \nauthoritative server\n we are talking about the former where all network traffic goes through the server first and then is relayed to all of the clients.", 
            "title": "Authoritative design"
        }, 
        {
            "location": "/authoritative-design/#authoritative-design", 
            "text": "Often you will hear the term  authoritative server  and in most cases, it is used to mean  authoritative game logic . So, we would like to first go over the difference between the two as we often state that Forge Networking (including Remastered) is  authoritative server  by design.  Authoritative Server:  When all network traffic goes through the server before it is relayed to other clients. In other words, clients do not communicate with each other directly.  Authoritative Game Logic:  When all your game code is written in a way where the server is completely in control of the flow and owns all of the network objects. This is unique to your game and how your game plays, it can be complex based on your game and we would suggest exploring the idea of not having authoritative game logic unless your game requires it. Games that require it often are games that have long term tracking (such as Battlefield) or track data for users in a database (such as an MMO). Games that plan to have non-tracked multiplayer (such as Minecraft) would not opt into having full server authority due to the overhead of complexity.  So when we say that Forge Networking (and Remastered) is an  authoritative server  we are talking about the former where all network traffic goes through the server first and then is relayed to all of the clients.", 
            "title": "Authoritative Design"
        }, 
        {
            "location": "/GettingStarted/getting-started/", 
            "text": "Getting Started\n\n\nThe following is collection of examples/tutorials to get you up and running with Forge Networking. Our goal with these examples are to help you learn the basics of the engine quickly through guided step by step processes. We do cover more in-depth explanations of the various components of the engine outside of the examples, however we do suggest going through these examples first before taking a deeper dive into the complexities and extensions of the engine found in other sections of this documentation.\n\n\n\n\nBasic Moving Cube Example\n\n\nBasic RPC Example\n\n\nBasic Instantiation Example\n\n\nJump Start Guide\n\n\nGame Lobby Example\n\n\n\n\nWant to watch some Jumpstart videos?", 
            "title": "Getting started"
        }, 
        {
            "location": "/GettingStarted/getting-started/#getting-started", 
            "text": "The following is collection of examples/tutorials to get you up and running with Forge Networking. Our goal with these examples are to help you learn the basics of the engine quickly through guided step by step processes. We do cover more in-depth explanations of the various components of the engine outside of the examples, however we do suggest going through these examples first before taking a deeper dive into the complexities and extensions of the engine found in other sections of this documentation.   Basic Moving Cube Example  Basic RPC Example  Basic Instantiation Example  Jump Start Guide  Game Lobby Example", 
            "title": "Getting Started"
        }, 
        {
            "location": "/GettingStarted/getting-started/#want-to-watch-some-jumpstart-videos", 
            "text": "", 
            "title": "Want to watch some Jumpstart videos?"
        }, 
        {
            "location": "/GettingStarted/basic-moving-cube-example/", 
            "text": "Basic Moving Cube Example\n\n\nThis example is not a continuation of other examples and should be treated as if it were done in a new project.\n\n\nIn this example, we are going to make a simple game where we have a cube in the scene that is owned by the server and all the clients can see it being moved by the server.\n\n\nPlanning Network Code\n\n\nSo, one of the first things we want to think about is our \nNetwork Contract\n. This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will see a cube, then the cube will move around in sync with the server, who is the person actually moving the cube. To accomplish this, we need to:\n\n\n\n\nHave a cube already in the scene\n\n\nSynchronize the position and rotation of the cube to all the clients from the server\n\n\nThe transformations should be smooth so we need to interpolate them\n\n\n\n\nNetwork Contract Wizard\n\n\nNow that we know that we need to sync the \nposition\n and \nrotation\n of a cube, we can design our network contract for that object. We will first open the \nNetwork Contract Wizard\n which is a UI provided by the Bearded Man Studios team to make it easy to design your \nnetwork contracts\n in a easy way. To open this menu, go into Unity and select \"Window-\nForge Networking-\nNetwork Contract Wizard\".\n\n\n\n\nOnce you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the \nName\n fields, the \nFields\n field, and the \nRemote Procedure Calls\n field.\n\n\n\n\nThe \nName\n field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated.\n\n\nThe \nFields\n section shows all of the various fields that our network should be aware of. In this case, we are going to want to make a \nposition\n and \nrotation\n field which are \nVector3\n and \nQuaternion\n respectively. \nNote, you can name these fields whatever you like, these are just friendly variable names for you (and your team) to know what they are for when used\n\n\nThe \nRemote Procedure Calls\n field is where you will design any Remote Procedure Call (RPC) function signatures. We are not going to go over this field in this tutorial as we do not need it for the goal we are attempting to accomplish.\n\n\n\n\nLet's begin by naming our Network Object:\n\n\n\n\nLet's set the name for our Network object to \nBasicCube\n\n\nClick the \nAdd Field\n button\n\n\nName the new field \nposition\n\n\nSet the type to \nVector3\n\n\nClick the \nInterpolate\n button\n\n\nSet the interpolate time (the text field that pops up after clicking the \nInterpolate\n button) as \n0.15\n\n\nClick the \nAdd Field\n button\n\n\nName the new field \nrotation\n\n\nSet the type to \nQuaternion\n\n\nClick the \nInterpolate\n button\n\n\nSet the interpolate time (the text field that pops up after clicking the \nInterpolate\n button) as \n0.15\n\n\nClick the \nSave \n Compile\n button\n\n\n\n\n\n\nExtending Generated Classes\n\n\nWhen we use the \nNetwork Contract Wizard (NCW)\n we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class in particular that we want to extend from, this class name will be \nBasicCubeBehavior\n. The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Let's now create a C# file in Unity and write our basic game logic, we will name this file \nBasicCube\n.\n\n\n\n\nOpen the newly created C# file\n\n\nAdd \nusing BeardedManStudios.Forge.Networking.Generated;\n to the using statements\n\n\nDerive the class from \nBasicCubeBehavior\n\n\nWrite the rest of the logic for the cube as seen below\n\n\n\n\nBasicCube\n\n\nusing UnityEngine;\n\nusing BeardedManStudios.Forge.Networking.Generated;\npublic class BasicCube : BasicCubeBehavior\n{\n    /// \nsummary\n\n    /// The speed that the cube will move by when the user presses a\n    /// Horizontal or Vertical mapped key\n    /// \n/summary\n\n    public float speed = 5.0f;\n\n    private void Update()\n    {\n        // If we are not the owner of this network object then we should\n        // move this cube to the position/rotation dictated by the owner\n        if (!networkObject.IsOwner)\n        {\n            transform.position = networkObject.position;\n            transform.rotation = networkObject.rotation;\n            return;\n        }\n\n        // Let the owner move the cube around with the arrow keys\n        transform.position += new Vector3(Input.GetAxis(\nHorizontal\n) 0, Input.GetAxis(\nVertical\n)).normalized * speed * Time.deltaTime;\n\n        // If we are the owner of the object we should send the new position\n        // and rotation across the network for receivers to move to in the above code\n        networkObject.position = transform.position;\n        networkObject.rotation = transform.rotation;\n\n        // Note: Forge Networking takes care of only sending the delta, so there\n        // is no need for you to do that manually\n    }\n}\n\n\n\n\nAs you can see from the code snippet above, you can determine if the current player is the owner of the object using the \nnetworkObject.IsOwner\n boolean comparison. This will allow you to make code specifically based on the owner of the object. In this case, since the cube is going to be in the scene at start, it's owner is the \nserver\n. In the snippet above the client (non owner) will update the transform position and rotation of the cube (the object this script is going to be attached to) to the position and rotation received from the server. Since we turned on interpolation, all of the smoothing is done \"behind the scenes\". Now the server in this case will just assign the \nposition\n and \nrotation\n variables of the networkObject. These \nare\n the two fields we created in the NCW by the way. All generated network objects from the NCW will have a \nnetworkObject\n member variable that you can access from the deriving child. Whenever you assign a field of this object it is replicated across the network if the assigning user is the owner of the object.\n\n\nScene Setup\n\n\nNow that we have done all the network programming required for our end goal, it is time to setup our scene.\n\n\n\n\nCreate a new scene in unity\n\n\nCreate a cube for your floor\n\n\nSet the position of this cube on the \nx\n , \ny\n , and \nz\n to \n0\n , \n0\n , \n0\n respectively\n\n\nSet this cube's scale on the \nx\n , \ny\n , and \nz\n to \n25\n , \n0.1\n , \n25\n respectively\n\n\nCreate another cube which will act as the active moving cube\n\n\nSet the position of this cube on the \nx\n , \ny\n , and \nz\n to \n0\n , \n3\n , \n0\n respectively\n\n\nAttach a 3D \nRigidbody\n Component to the cube\n\n\nAttach our \nBasicCube\n script to this cube\n\n\nSave the scene as \nBasicCube\n\n\nOpen up the build properties for Unity\n\n\nAdd the \nMultiplayerMenu\n scene as the first scene\n\n\nAdd your \nBasicCube\n scene as the second scene\n\n\n\n\nTest\n\n\nNow that we have setup our scene and everything else, it is time to test the game.\n\n\n\n\nOpen the \nBuild Settings\n\n\nClick on \nPlayer Settings...\n\n\nOpen the \nResolution and Presentation\n section\n\n\nTurn on \nRun In Background*\n\n\nGo back to \nBuild Settings\n\n\nClick on \nBuild And Run\n\n\nOnce the game is open, return to the Unity Editor\n\n\nOpen the \nMultiplayerMenu\n scene\n\n\nClick the play button\n\n\nClick the \nHost (127.0.0.1:15937)\n button on the bottom of the game view\n\n\nGo back to the built game\n\n\nMake sure the host ip address is set to \n127.0.0.1\n\n\nMake sure the host port is set to \n15937\n\n\nClick the \nConnect\n button\n\n\nSelect the server game instance (Unity Editor)\n\n\n\n\nNow if you move around the cube in the editor, you will see the movements replicated to the clients.\n\n\nTroubleshooting\n\n\nGetting a null reference exception?\n\n\nThe most common user errors with this part of the documentation are:\n\n\n\n\nForgot to turn on Run in Background*\n\n\nTried pressing the play button in the scene and not loading the Multiplayer Menu scene first\n\n\nNot setting up the multiplayer menu scene as index 0 and the demo scene as index 1", 
            "title": "Basic moving cube example"
        }, 
        {
            "location": "/GettingStarted/basic-moving-cube-example/#basic-moving-cube-example", 
            "text": "This example is not a continuation of other examples and should be treated as if it were done in a new project.  In this example, we are going to make a simple game where we have a cube in the scene that is owned by the server and all the clients can see it being moved by the server.", 
            "title": "Basic Moving Cube Example"
        }, 
        {
            "location": "/GettingStarted/basic-moving-cube-example/#planning-network-code", 
            "text": "So, one of the first things we want to think about is our  Network Contract . This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will see a cube, then the cube will move around in sync with the server, who is the person actually moving the cube. To accomplish this, we need to:   Have a cube already in the scene  Synchronize the position and rotation of the cube to all the clients from the server  The transformations should be smooth so we need to interpolate them", 
            "title": "Planning Network Code"
        }, 
        {
            "location": "/GettingStarted/basic-moving-cube-example/#network-contract-wizard", 
            "text": "Now that we know that we need to sync the  position  and  rotation  of a cube, we can design our network contract for that object. We will first open the  Network Contract Wizard  which is a UI provided by the Bearded Man Studios team to make it easy to design your  network contracts  in a easy way. To open this menu, go into Unity and select \"Window- Forge Networking- Network Contract Wizard\".   Once you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the  Name  fields, the  Fields  field, and the  Remote Procedure Calls  field.   The  Name  field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated.  The  Fields  section shows all of the various fields that our network should be aware of. In this case, we are going to want to make a  position  and  rotation  field which are  Vector3  and  Quaternion  respectively.  Note, you can name these fields whatever you like, these are just friendly variable names for you (and your team) to know what they are for when used  The  Remote Procedure Calls  field is where you will design any Remote Procedure Call (RPC) function signatures. We are not going to go over this field in this tutorial as we do not need it for the goal we are attempting to accomplish.   Let's begin by naming our Network Object:   Let's set the name for our Network object to  BasicCube  Click the  Add Field  button  Name the new field  position  Set the type to  Vector3  Click the  Interpolate  button  Set the interpolate time (the text field that pops up after clicking the  Interpolate  button) as  0.15  Click the  Add Field  button  Name the new field  rotation  Set the type to  Quaternion  Click the  Interpolate  button  Set the interpolate time (the text field that pops up after clicking the  Interpolate  button) as  0.15  Click the  Save   Compile  button", 
            "title": "Network Contract Wizard"
        }, 
        {
            "location": "/GettingStarted/basic-moving-cube-example/#extending-generated-classes", 
            "text": "When we use the  Network Contract Wizard (NCW)  we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class in particular that we want to extend from, this class name will be  BasicCubeBehavior . The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Let's now create a C# file in Unity and write our basic game logic, we will name this file  BasicCube .   Open the newly created C# file  Add  using BeardedManStudios.Forge.Networking.Generated;  to the using statements  Derive the class from  BasicCubeBehavior  Write the rest of the logic for the cube as seen below", 
            "title": "Extending Generated Classes"
        }, 
        {
            "location": "/GettingStarted/basic-moving-cube-example/#basiccube", 
            "text": "using UnityEngine;\n\nusing BeardedManStudios.Forge.Networking.Generated;\npublic class BasicCube : BasicCubeBehavior\n{\n    ///  summary \n    /// The speed that the cube will move by when the user presses a\n    /// Horizontal or Vertical mapped key\n    ///  /summary \n    public float speed = 5.0f;\n\n    private void Update()\n    {\n        // If we are not the owner of this network object then we should\n        // move this cube to the position/rotation dictated by the owner\n        if (!networkObject.IsOwner)\n        {\n            transform.position = networkObject.position;\n            transform.rotation = networkObject.rotation;\n            return;\n        }\n\n        // Let the owner move the cube around with the arrow keys\n        transform.position += new Vector3(Input.GetAxis( Horizontal ) 0, Input.GetAxis( Vertical )).normalized * speed * Time.deltaTime;\n\n        // If we are the owner of the object we should send the new position\n        // and rotation across the network for receivers to move to in the above code\n        networkObject.position = transform.position;\n        networkObject.rotation = transform.rotation;\n\n        // Note: Forge Networking takes care of only sending the delta, so there\n        // is no need for you to do that manually\n    }\n}  As you can see from the code snippet above, you can determine if the current player is the owner of the object using the  networkObject.IsOwner  boolean comparison. This will allow you to make code specifically based on the owner of the object. In this case, since the cube is going to be in the scene at start, it's owner is the  server . In the snippet above the client (non owner) will update the transform position and rotation of the cube (the object this script is going to be attached to) to the position and rotation received from the server. Since we turned on interpolation, all of the smoothing is done \"behind the scenes\". Now the server in this case will just assign the  position  and  rotation  variables of the networkObject. These  are  the two fields we created in the NCW by the way. All generated network objects from the NCW will have a  networkObject  member variable that you can access from the deriving child. Whenever you assign a field of this object it is replicated across the network if the assigning user is the owner of the object.", 
            "title": "BasicCube"
        }, 
        {
            "location": "/GettingStarted/basic-moving-cube-example/#scene-setup", 
            "text": "Now that we have done all the network programming required for our end goal, it is time to setup our scene.   Create a new scene in unity  Create a cube for your floor  Set the position of this cube on the  x  ,  y  , and  z  to  0  ,  0  ,  0  respectively  Set this cube's scale on the  x  ,  y  , and  z  to  25  ,  0.1  ,  25  respectively  Create another cube which will act as the active moving cube  Set the position of this cube on the  x  ,  y  , and  z  to  0  ,  3  ,  0  respectively  Attach a 3D  Rigidbody  Component to the cube  Attach our  BasicCube  script to this cube  Save the scene as  BasicCube  Open up the build properties for Unity  Add the  MultiplayerMenu  scene as the first scene  Add your  BasicCube  scene as the second scene", 
            "title": "Scene Setup"
        }, 
        {
            "location": "/GettingStarted/basic-moving-cube-example/#test", 
            "text": "Now that we have setup our scene and everything else, it is time to test the game.   Open the  Build Settings  Click on  Player Settings...  Open the  Resolution and Presentation  section  Turn on  Run In Background*  Go back to  Build Settings  Click on  Build And Run  Once the game is open, return to the Unity Editor  Open the  MultiplayerMenu  scene  Click the play button  Click the  Host (127.0.0.1:15937)  button on the bottom of the game view  Go back to the built game  Make sure the host ip address is set to  127.0.0.1  Make sure the host port is set to  15937  Click the  Connect  button  Select the server game instance (Unity Editor)   Now if you move around the cube in the editor, you will see the movements replicated to the clients.", 
            "title": "Test"
        }, 
        {
            "location": "/GettingStarted/basic-moving-cube-example/#troubleshooting", 
            "text": "Getting a null reference exception?  The most common user errors with this part of the documentation are:   Forgot to turn on Run in Background*  Tried pressing the play button in the scene and not loading the Multiplayer Menu scene first  Not setting up the multiplayer menu scene as index 0 and the demo scene as index 1", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/", 
            "text": "Basic RPC Example\n\n\nThis example is not a continuation of other examples and should be treated as if it were done in a new project.\n\n\nIn this example we are going to go over how to use the built in RPC methods inside of Forge Networking Remastered. In this example we are going to make a scene that already has a cube in it, then if anyone presses the up arrow key it will move the cube up, if anyone presses the down arrow key, it will move the cube down.\n\n\nPlanning Network Code\n\n\nSo, one of the first things we want to think about is our \nNetwork Contract\n. This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will see a cube, if that client or any other connection (server or client) presses the up or down arrow key the cube will move in the appropriate direction for everyone connected:\n\n\n\n\nHave a cube already in the scene\n\n\nPress up arrow key to move the cube up via RPC method\n\n\nPress the down arrow key to move the cube down via RPC method\n\n\n\n\nNetwork Contract Wizard\n\n\nNow that we know that we need to sync the \nposition\n and \nrotation\n of a cube, we can design our network contract for that object. We will first open the \nNetwork Contract Wizard\n which is a UI provided by the Bearded Man Studios team to make it easy to design your \nnetwork contracts\n in a easy way. To open this menu, go into Unity and select \"Window-\nForge Networking-\nNetwork Contract Wizard\".\n\n\n\n\nOnce you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard (NCW) as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the \nName\n fields, the \nFields\n field, and the \nRemote Procedure Calls\n field.\n\n\n\n\nThe \nName\n field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated.\n\n\nThe \nFields\n section shows all of the various fields that our network should be aware of.\n\n\nThe \nRemote Procedure Calls\n field is where you will design any Remote Procedure Call (RPC) function signatures. This is going to be our main area of focus for this example.\n\n\n\n\nSetting up the contract option 1\n\n\nIn this option, we will create 2 RPC methods with no arguments. One RPC is to move the cube up and the other is to move the cube down. \nNOTE: Only pick option 1 or 2 to follow\n\n\nLet's begin by naming our Network Object:\n\n\n\n\nLet's set the name for our Network object to \nMoveCube\n\n\nClick the \nAdd RPC\n button\n\n\nName the new RPC \nMoveUp\n\n\nClick the \nAdd RPC\n button\n\n\nName the new RPC \nMoveDown\n\n\nClick the \nSave \n Compile\n button\n\n\n\n\n\n\nSetting up the contract option 2\n\n\nIn this option, we will create 1 RPC with 1 argument that denotes the direction to move the cube. \nNOTE: Only pick option 1 or 2 to follow\n\n\nLet's begin by naming our Network Object:\n\n\n\n\nLet's set the name for our Network object to \nMoveCube\n\n\nClick the \nAdd RPC\n button\n\n\nName the new RPC \nMove\n\n\nClick the arrow to open \nArguments\n next to the RPC name input box\n\n\nClick the green button that appears below the RPC name input box\n\n\nSelect \nVector3\n from the dropdown option list\n\n\nClick the \nSave \n Compile\n button\n\n\n\n\n\n\nIn this example, you may be curious what the \nVector3\n selection was for. This particular selection was to set the data types that will be sent as arguments to this method. Since we will be sending a direction to move in, this is a \nVector3\n , that means that we would need to pick it. The order of these type selections (if we had more than one) are explicit. That is to say that the order you select them in, is the order that you would pass argument types in, just as if you were writing a method in C#.\n\n\nExtending Generated Classes\n\n\nWhen we use the \nNetwork Contract Wizard (NCW)\n we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class that we want to extend from, this class name will be \" \nMoveCubeBehavior\n\". The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Let's now create a C# file in Unity and write our basic game logic, we will name this file \" \nMoveCube\n\".\n\n\n\n\nOpen the newly created C# file\n\n\nAdd \nusing BeardedManStudios.Forge.Networking.Generated;\n to the using statements\n\n\nDerive the class from \nBasicCubeBehavior\n\n\nWrite the rest of the logic for the cube as seen below\n\n\n\n\nCode if option 1 was selected\n\n\nMoveCube\n\n\nusing UnityEngine;\nusing BeardedManStudios.Forge.Networking.Generated;\nusing BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Unity;\npublic class MoveCube : MoveCubeBehavior\n{\n    private void Update()\n    {\n        // Move the cube up in world space if the up arrow was pressed\n        if (Input.GetKeyDown(KeyCode.UpArrow))\n            networkObject.SendRpc(RPC_MOVE_UP, Receivers.All);\n\n        // Move the cube down in world space if the down arrow was pressed\n        else if (Input.GetKeyDown(KeyCode.DownArrow))\n            networkObject.SendRpc(RPC_MOVE_DOWN, Receivers.All);\n    }\n\n    /// \nsummary\n\n    /// Used to move the cube that this script is attached to up\n    /// \n/summary\n\n    /// \nparam name=\nargs\nnull\n/param\n\n    public override void MoveUp(RpcArgs args)     \n    {\n        // RPC calls are not made from the main thread for performance, since we\n        // are interacting with Unity enginge objects, we will need to make sure\n        // to run the logic on the main thread\n        MainThreadManager.Run(() =\n\n        {\n            transform.position += Vector3.up;\n        });\n    }\n\n    /// \nsummary\n\n    /// Used to move the cube that this script is attached to down\n    /// \n/summary\n\n    /// \nparam name=\nargs\nnull\n/param\n\n    public override void MoveDown(RpcArgs args)     \n    {\n        // RPC calls are not made from the main thread for performance, since we\n        // are interacting with Unity engine objects, we will need to make sure\n        // to run the logic on the main thread\n        MainThreadManager.Run(() =\n\n        {\n            transform.position += Vector3.down;\n        });\n    }\n}\n\n\n\n\nAs you can see from the code snippet above an RPC is called using the \nnetworkObject.SendRPC\n method. The first argument is the name of the method and the second argument is the receivers of the object which could be set to things like AllBuffered, Others, etc. The moment the RPC method is called it is sent on the network to be replicated to the other clients (including server if called from a client). \nNote\n: \nIn this example, it doesn't use a buffered call and it does not actually synchronize the position, so the client should be connected before the cube is moved. \nNote 2\n: _Notice that we use \nMainThreadManager\n to run the move logic in this example, if you have not used the \nMainThreadManager\n before or would like more information about threading in Unity, please view \nthis page\n.\n\n\nCode if option 2 was selected\n\n\nMoveCube\n\n\nusing UnityEngine;\nusing BeardedManStudios.Forge.Networking.Generated;\nusing BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Unity;\npublic class MoveCube : MoveCubeBehavior {\n    private void Update()\n    {\n        // Move the cube up in world space if the up arrow was pressed\n        if (Input.GetKeyDown(KeyCode.UpArrow))\n            networkObject.SendRpc(RPC_MOVE, Receivers.All, Vector3.up);\n\n        // Move the cube down in world space if the down arrow was pressed\n        else if (Input.GetKeyDown(KeyCode.DownArrow))\n            networkObject.SendRpc(RPC_MOVE, Receivers.All, Vector3.down);\n    }\n\n    /// \nsummary\n\n    /// Used to move the cube that this script is attached to\n    /// \n/summary\n\n    /// \nparam name=\nargs\n\n    /// [0] Vector3 The direction/distance to move this cube by\n    /// \n/param\n\n    public override void Move(RpcArgs args)\n    {\n        // RPC calls are not made from the main thread for performance, since we\n        // are interacting with Unity engine objects, we will need to make sure\n        // to run the logic on the main thread\n        MainThreadManager.Run(() =\n\n        {\n            transform.position += args.GetNext\nVector3\n();\n        });\n    }\n}\n\n\n\n\nAs you can see from the code snippet above an RPC is called using the \nnetworkObject.SendRPC\n method. The first argument is the name of the method, the second argument is the receivers of the object which could be set to things like AllBuffered, Others, etc, and the last argument(s) are the arguments for the method. The arguments are mapped to the \nobject[] args\n of the method in the order that they were sent in. The moment the RPC method is called it is sent on the network to be replicated to the other clients (including server if called from a client). \nNote\n: \nIn this example, it doesn't use a buffered call and it does not actually synchronize the position, so the client should be connected before the cube is moved.\n \nNote 2\n: \nNotice that we use \nMainThreadManager\n to run the move logic in this example, if you have not used the \nMainThreadManager\n before or would like more information about threading in Unity, please view \nthis page\n.\n\n\nScene Setup\n\n\nNow that we have done all of the network programming required for our end goal, it is time to setup our scene.\n\n\n\n\nCreate a new scene in unity\n\n\nCreate a cube which will act as the active moving cube\n\n\nSet the position of this cube on the \nx\n , \ny\n , and \nz\n to \n0\n , \n0\n , \n0\n respectively\n\n\nAttach our \nMoveCube\n script to this cube\n\n\nSave the scene as \nMoveCube\n\n\nOpen up the build properties for Unity\n\n\nAdd the \nMultiplayerMenu\n scene as the first scene\n\n\nAdd your \nMoveCube\n scene as the second scene\n\n\n\n\nTest\n\n\nNow that we have setup our scene and everything else, it is time to test the game.\n\n\n\n\nOpen the \nBuild Settings\n\n\nClick on \nPlayer Settings...\n\n\nOpen the \nResolution and Presentation\n section\n\n\nTurn on \nRun In Background*\n\n\nGo back to \nBuild Settings\n\n\nClick on \nBuild And Run\n\n\nOnce the game is open, return to the Unity Editor\n\n\nOpen the \nMultiplayerMenu\n scene\n\n\nClick the play button\n\n\nClick the \nHost (127.0.0.1:15937)\n button on the bottom of the game view\n\n\nGo back to the built game\n\n\nMake sure the host ip address is set to \n127.0.0.1\n\n\nMake sure the host port is set to \n15937\n\n\nClick the \nConnect\n button\n\n\nSelect the server instance (Unity Editor) then press the up and down arrow keys\n\n\nSelect the client instance then press the up and down arrow keys\n\n\n\n\nYou will see the server movements replicated to the client and the client movements replicated to the server\n\n\nTroubleshooting\n\n\nGetting a null reference exception?\n\n\nThe most common user errors with this part of the documentation are:\n\n\n\n\nForgot to turn on Run in Background*\n\n\nTried pressing the play button in the scene and not loading the Multiplayer Menu scene first\n\n\nNot setting up the multiplayer menu scene as index 0 and the demo scene as index 1", 
            "title": "Basic rpc example"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#basic-rpc-example", 
            "text": "This example is not a continuation of other examples and should be treated as if it were done in a new project.  In this example we are going to go over how to use the built in RPC methods inside of Forge Networking Remastered. In this example we are going to make a scene that already has a cube in it, then if anyone presses the up arrow key it will move the cube up, if anyone presses the down arrow key, it will move the cube down.", 
            "title": "Basic RPC Example"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#planning-network-code", 
            "text": "So, one of the first things we want to think about is our  Network Contract . This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will see a cube, if that client or any other connection (server or client) presses the up or down arrow key the cube will move in the appropriate direction for everyone connected:   Have a cube already in the scene  Press up arrow key to move the cube up via RPC method  Press the down arrow key to move the cube down via RPC method", 
            "title": "Planning Network Code"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#network-contract-wizard", 
            "text": "Now that we know that we need to sync the  position  and  rotation  of a cube, we can design our network contract for that object. We will first open the  Network Contract Wizard  which is a UI provided by the Bearded Man Studios team to make it easy to design your  network contracts  in a easy way. To open this menu, go into Unity and select \"Window- Forge Networking- Network Contract Wizard\".   Once you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard (NCW) as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the  Name  fields, the  Fields  field, and the  Remote Procedure Calls  field.   The  Name  field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated.  The  Fields  section shows all of the various fields that our network should be aware of.  The  Remote Procedure Calls  field is where you will design any Remote Procedure Call (RPC) function signatures. This is going to be our main area of focus for this example.", 
            "title": "Network Contract Wizard"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#setting-up-the-contract-option-1", 
            "text": "In this option, we will create 2 RPC methods with no arguments. One RPC is to move the cube up and the other is to move the cube down.  NOTE: Only pick option 1 or 2 to follow  Let's begin by naming our Network Object:   Let's set the name for our Network object to  MoveCube  Click the  Add RPC  button  Name the new RPC  MoveUp  Click the  Add RPC  button  Name the new RPC  MoveDown  Click the  Save   Compile  button", 
            "title": "Setting up the contract option 1"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#setting-up-the-contract-option-2", 
            "text": "In this option, we will create 1 RPC with 1 argument that denotes the direction to move the cube.  NOTE: Only pick option 1 or 2 to follow  Let's begin by naming our Network Object:   Let's set the name for our Network object to  MoveCube  Click the  Add RPC  button  Name the new RPC  Move  Click the arrow to open  Arguments  next to the RPC name input box  Click the green button that appears below the RPC name input box  Select  Vector3  from the dropdown option list  Click the  Save   Compile  button    In this example, you may be curious what the  Vector3  selection was for. This particular selection was to set the data types that will be sent as arguments to this method. Since we will be sending a direction to move in, this is a  Vector3  , that means that we would need to pick it. The order of these type selections (if we had more than one) are explicit. That is to say that the order you select them in, is the order that you would pass argument types in, just as if you were writing a method in C#.", 
            "title": "Setting up the contract option 2"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#extending-generated-classes", 
            "text": "When we use the  Network Contract Wizard (NCW)  we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class that we want to extend from, this class name will be \"  MoveCubeBehavior \". The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Let's now create a C# file in Unity and write our basic game logic, we will name this file \"  MoveCube \".   Open the newly created C# file  Add  using BeardedManStudios.Forge.Networking.Generated;  to the using statements  Derive the class from  BasicCubeBehavior  Write the rest of the logic for the cube as seen below", 
            "title": "Extending Generated Classes"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#code-if-option-1-was-selected", 
            "text": "", 
            "title": "Code if option 1 was selected"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#movecube", 
            "text": "using UnityEngine;\nusing BeardedManStudios.Forge.Networking.Generated;\nusing BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Unity;\npublic class MoveCube : MoveCubeBehavior\n{\n    private void Update()\n    {\n        // Move the cube up in world space if the up arrow was pressed\n        if (Input.GetKeyDown(KeyCode.UpArrow))\n            networkObject.SendRpc(RPC_MOVE_UP, Receivers.All);\n\n        // Move the cube down in world space if the down arrow was pressed\n        else if (Input.GetKeyDown(KeyCode.DownArrow))\n            networkObject.SendRpc(RPC_MOVE_DOWN, Receivers.All);\n    }\n\n    ///  summary \n    /// Used to move the cube that this script is attached to up\n    ///  /summary \n    ///  param name= args null /param \n    public override void MoveUp(RpcArgs args)     \n    {\n        // RPC calls are not made from the main thread for performance, since we\n        // are interacting with Unity enginge objects, we will need to make sure\n        // to run the logic on the main thread\n        MainThreadManager.Run(() = \n        {\n            transform.position += Vector3.up;\n        });\n    }\n\n    ///  summary \n    /// Used to move the cube that this script is attached to down\n    ///  /summary \n    ///  param name= args null /param \n    public override void MoveDown(RpcArgs args)     \n    {\n        // RPC calls are not made from the main thread for performance, since we\n        // are interacting with Unity engine objects, we will need to make sure\n        // to run the logic on the main thread\n        MainThreadManager.Run(() = \n        {\n            transform.position += Vector3.down;\n        });\n    }\n}  As you can see from the code snippet above an RPC is called using the  networkObject.SendRPC  method. The first argument is the name of the method and the second argument is the receivers of the object which could be set to things like AllBuffered, Others, etc. The moment the RPC method is called it is sent on the network to be replicated to the other clients (including server if called from a client).  Note :  In this example, it doesn't use a buffered call and it does not actually synchronize the position, so the client should be connected before the cube is moved.  Note 2 : _Notice that we use  MainThreadManager  to run the move logic in this example, if you have not used the  MainThreadManager  before or would like more information about threading in Unity, please view  this page .", 
            "title": "MoveCube"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#code-if-option-2-was-selected", 
            "text": "", 
            "title": "Code if option 2 was selected"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#movecube_1", 
            "text": "using UnityEngine;\nusing BeardedManStudios.Forge.Networking.Generated;\nusing BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Unity;\npublic class MoveCube : MoveCubeBehavior {\n    private void Update()\n    {\n        // Move the cube up in world space if the up arrow was pressed\n        if (Input.GetKeyDown(KeyCode.UpArrow))\n            networkObject.SendRpc(RPC_MOVE, Receivers.All, Vector3.up);\n\n        // Move the cube down in world space if the down arrow was pressed\n        else if (Input.GetKeyDown(KeyCode.DownArrow))\n            networkObject.SendRpc(RPC_MOVE, Receivers.All, Vector3.down);\n    }\n\n    ///  summary \n    /// Used to move the cube that this script is attached to\n    ///  /summary \n    ///  param name= args \n    /// [0] Vector3 The direction/distance to move this cube by\n    ///  /param \n    public override void Move(RpcArgs args)\n    {\n        // RPC calls are not made from the main thread for performance, since we\n        // are interacting with Unity engine objects, we will need to make sure\n        // to run the logic on the main thread\n        MainThreadManager.Run(() = \n        {\n            transform.position += args.GetNext Vector3 ();\n        });\n    }\n}  As you can see from the code snippet above an RPC is called using the  networkObject.SendRPC  method. The first argument is the name of the method, the second argument is the receivers of the object which could be set to things like AllBuffered, Others, etc, and the last argument(s) are the arguments for the method. The arguments are mapped to the  object[] args  of the method in the order that they were sent in. The moment the RPC method is called it is sent on the network to be replicated to the other clients (including server if called from a client).  Note :  In this example, it doesn't use a buffered call and it does not actually synchronize the position, so the client should be connected before the cube is moved.   Note 2 :  Notice that we use  MainThreadManager  to run the move logic in this example, if you have not used the  MainThreadManager  before or would like more information about threading in Unity, please view  this page .", 
            "title": "MoveCube"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#scene-setup", 
            "text": "Now that we have done all of the network programming required for our end goal, it is time to setup our scene.   Create a new scene in unity  Create a cube which will act as the active moving cube  Set the position of this cube on the  x  ,  y  , and  z  to  0  ,  0  ,  0  respectively  Attach our  MoveCube  script to this cube  Save the scene as  MoveCube  Open up the build properties for Unity  Add the  MultiplayerMenu  scene as the first scene  Add your  MoveCube  scene as the second scene", 
            "title": "Scene Setup"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#test", 
            "text": "Now that we have setup our scene and everything else, it is time to test the game.   Open the  Build Settings  Click on  Player Settings...  Open the  Resolution and Presentation  section  Turn on  Run In Background*  Go back to  Build Settings  Click on  Build And Run  Once the game is open, return to the Unity Editor  Open the  MultiplayerMenu  scene  Click the play button  Click the  Host (127.0.0.1:15937)  button on the bottom of the game view  Go back to the built game  Make sure the host ip address is set to  127.0.0.1  Make sure the host port is set to  15937  Click the  Connect  button  Select the server instance (Unity Editor) then press the up and down arrow keys  Select the client instance then press the up and down arrow keys   You will see the server movements replicated to the client and the client movements replicated to the server", 
            "title": "Test"
        }, 
        {
            "location": "/GettingStarted/basic-rpc-example/#troubleshooting", 
            "text": "Getting a null reference exception?  The most common user errors with this part of the documentation are:   Forgot to turn on Run in Background*  Tried pressing the play button in the scene and not loading the Multiplayer Menu scene first  Not setting up the multiplayer menu scene as index 0 and the demo scene as index 1", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/", 
            "text": "Basic Instantiation Example\n\n\nNote: We assume that you have gone through the\n \nBasic Moving Cube Example\n \nand the\n \nBasic RPC Example\n \nbefore going through this example.\n\n\nThis example is not a continuation of other examples and should be treated as if it were done in a new project.\n\n\nIn this example we are going to create a simple cube to act as the player object. The \"player\" should be able to move their individual cube using the \nhorizontal\n and \nvertical\n axis input. For this we will create a scene without any cubes in it, then when a connection is made or the server is created, we will spawn a cube \"player\" for the newly connected client or created server.\n\n\nPlanning Network Code\n\n\nSo one of the first things we want to think about is our \nNetwork Contract\n. This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will create a player cube for itself, it will also see all of the other connected cubes and their movements:\n\n\n\n\nPlayer creates a cube for itself when connected\n\n\nSynchronize the position and rotation of the player cube to all the clients and server\n\n\nThe transformations should be smooth so we need to interpolate them\n\n\n\n\nNetwork Contract Wizard\n\n\nNow that we know that we need to sync the \nposition\n and \nrotation\n of a cube, we can design our network contract for that object. We will first open the \nNetwork Contract Wizard\n which is a UI provided by the Bearded Man Studios team to make it easy to design your \nnetwork contracts\n in a easy way. To open this menu, go into Unity and select \"Window-\nForge Networking-\nNetwork Contract Wizard\".\n\n\n\n\nOnce you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the \nNetwork Contract Wizard\n as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the \nName\n fi elds, the \nFields\n field, and the \nRemote Procedure Calls\n field.\n\n\n\n\nThe \nName\n field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated.\n\n\nThe \nFields\n section shows all of the various fields that our network should be aware of. In this case we are going to want to make a \npositi on\n and \nrotation\n field which are \nVector3\n and \nQuaternion\n respectively. \nNote, you can name these fields whatever you like, these are just friendly variable names for you (and your team) to know what they are for when used\n\n\nThe \nRemote Procedure Calls\n field is where you will design any Remote Procedure Call (RPC) function signatures. We are not going to go over this field in this tutorial as we do not need it for the goal we are attempting to accomplish.\n\n\n\n\nLets begin by naming our Network Object:\n\n\n\n\nLets set the name for our Network object to \" \nPlayerCube\n\" (without quotes)\n\n\nClick the \nAdd Field\n button\n\n\nName the new field \nposition\n\n\nSet the type to \nVector3\n\n\nClick the \nInterpolate\n button\n\n\nSet the interpolate time (the text field that pops up after clicking the \nInterpolate\n button) as \n0.15\n\n\nClick the \nAdd Field\n button\n\n\nName the new field \nrotation\n\n\nSet the type to \nQuaternion\n\n\nClick the \nInterpolate\n button\n\n\nSet the interpolate time (the text field that pops up after clicking the \nInterpolate\n button) as \n0.15\n 12.  Click the \nSave \n Compile\n button\n\n\n\n\n\n\nExtending Generated Classes\n\n\nWhen we use the \nNetwork Contract Wizard (NCW)\n we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class in particular that we want to extend from, this class name will be \" \nPlayerCubeBehavior\n\". The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Lets now create a C# file in Unity and write our basic game logic, we will name this file \" \nPlayerCube\n\".\n\n\n\n\nOpen the newly created C# file\n\n\nAdd \nusing BeardedManStudios.Forge.Networking.Generated;\n to the using statements\n\n\nDerive the class from \nPlayerCubeBehavior\n\n\nWrite the rest of the logic for the cube as seen below\n\n\n\n\nPlayerCube\n\n\nusing UnityEngine;\nusing BeardedManStudios.Forge.Networking.Generated;\n\npublic class PlayerCube : PlayerCubeBehavior\n{\n    /// \nsummary\n\n    /// The speed that this cube should move by when there are axis inputs\n    /// \n/summary\n\n    public float speed = 5.0f;\n\n    private void Update()\n    {\n        // If this is not owned by the current network client then it needs to\n        // assign it to the position and rotation specified\n        if (!networkObject.IsOwner)\n        {\n            // Assign the position of this cube to the position sent on the network\n            transform.position = networkObject.position;\n\n            // Assign the rotation of this cube to the rotation sent on the network\n            transform.rotation = networkObject.rotation;\n\n            // Stop the function here and don't run any more code in this function\n            return;\n        }\n\n        // Get the movement based on the axis input values\n        Vector3 translation = new Vector3(Input.GetAxis(\nHorizontal\n), 0, Input.GetAxis(\nVertical\n)).normalized;\n\n        // Scale the speed to normalize for processors\n        translation *= speed * Time.deltaTime;\n\n        // Move the object by the given translation\n        transform.position += translation;\n\n        // Just a random rotation on all axis\n        transform.Rotate(new Vector3(speed, speed, speed) * 0.25f);\n\n        // Since we are the owner, tell the network the updated position\n        networkObject.position = transform.position;\n\n        // Since we are the owner, tell the network the updated rotation\n        networkObject.rotation = transform.rotation;\n\n        // Note: Forge Networking takes care of only sending the delta, so there\n        // is no need for you to do that manually\n    }\n}\n\n\n\n\nSetting up prefab\n\n\nSince we are going to instantiate this object when a player connects, we will need a prefab that identifies this object. To quickly create a prefab that has a cube we will use the standard Unity process.\n\n\n\n\nRight click\n on the \nHierarchy\n\n\nHover our mouse over \n3D Object\n\n\nClick on \nCube\n in the following context menu\n\n\n\n\nNow that we have created a cube we need to set it up with the class \nPlayerCube\n class we just created\n\n\n\n\nSelect the cube\n\n\nClick on the \nAdd Component\n button in the \nInspector\n\n\nType in \nPlayerCube\n into the search\n\n\nClick the \nPlayerCube\n script to attach it\n\n\n\n\nNow that we have setup our player object it is time for us to create the prefab that will be instantiated when clients connect.\n\n\n\n\nSelect the cube in the \nHierarchy\n\n\nDrag the cube into the \nProject\n area to create the prefab\n\n\nRename this prefab \nPlayerCube\n , this step is not required, just helps the example stay cohesive\n\n\n\n\nWith this we are prepared to setup our \nNetworkManager\n to support the new instantiation of the object.\n\n\nAttaching the PlayerCube prefab for instantiation\n\n\nIf you search the project directory you will find a prefab named \nNetworkManager\n. This is a default prefab we have created for you to get started. You \ncan\n make your own prefab or alter this one if you wish to extend behavior. Now we will go through the process of attaching our created \nPlayerCube\n prefab to this \nNetworkManager\n\n\n\n\nSelect the \nNetworkManager\n prefab in the project\n\n\nLocate the field named \nPlayer Cube Network Object\n\n\nYou will notice that this is an array, set the \nSize\n to 1\n\n\nClick the radial (circle) on the right of the \nElement 0\n input field\n\n\nLocate and select the \nPlayerCube\n prefab\n\n\n\n\nSetup Instantiation \n Scene\n\n\nNow that we have setup our \nNetworkManager\n we are ready to make our instantiate code. To do this we will create a script that will instantiate our player\n\n\n\n\nOpen up a new scene\n\n\nCreate a new C# script named \nGameLogic\n\n\nOpen the newly created C# file\n\n\nAdd \nusing BeardedManStudios.Forge.Networking.Unity;\n to the using statements\n\n\nWrite the rest of the logic for instantiating the cube (seen below)\n\n\nAttach the newly created script to the \nMain Camera\n object in the scene (this is just to have the script in the scene, no other particular reason)\n\n\nSave the scene as \nGameScene\n\n\nAdd the \nMultiplayerMenu\n scene as the first scene\n\n\nAdd your \nGameScene\n scene as the second scene\n\n\n\n\nGameLogic\n\n\nusing UnityEngine;\nusing BeardedManStudios.Forge.Networking.Unity;\npublic class GameLogic : MonoBehaviour\n{\n    private void Start()\n    {\n        NetworkManager.Instance.InstantiatePlayerCube();\n    }\n}\n\n\n\n\nTest\n\n\nNow that we have setup our scene and everything else, it is time to test the game.\n\n\n\n\nOpen the \nBuild Settings\n\n\nClick on \nPlayer Settings...\n\n\nOpen the \nResolution and Presentation\n section\n\n\nTurn on \nRun In Background*\n\n\nGo back to \nBuild Settings\n\n\nClick on \nBuild And Run\n\n\nOnce the game is open, return to the Unity Editor\n\n\nOpen the \nMultiplayerMenu\n scene\n\n\nClick the play button\n\n\nClick the \nHost (127.0.0.1:15937)\n button on the bottom of the game view\n\n\nGo back to the built game\n\n\nMake sure the host ip address is set to \n127.0.0.1\n\n\nMake sure the host port is set to \n15937\n\n\nClick the \nConnect\n button\n\n\nSelect the server game instance (Unity Editor)\n\n\n\n\nNow if you move around the cube in the editor, you will see the movements replicated to the client(s). If you move the cube around in the client(s) you will see the cube moving on the server. Our code has the cube constantly rotating so you will see them doing that as well.\n\n\nTroubleshooting\n\n\nGetting a null reference exception?\n\n\nThe most common user errors with this part of the documentation are:\n\n\n\n\nForgot to turn on \nRun in Background*\n\n\nTried pressing the play button in the scene and not loading the \nMultiplayerMenu\n scene first\n\n\nNot setting up the \nMultiplayerMenu\n scene as index 0 and the demo scene as index 1", 
            "title": "Basic instantiation example"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#basic-instantiation-example", 
            "text": "Note: We assume that you have gone through the   Basic Moving Cube Example   and the   Basic RPC Example   before going through this example.  This example is not a continuation of other examples and should be treated as if it were done in a new project.  In this example we are going to create a simple cube to act as the player object. The \"player\" should be able to move their individual cube using the  horizontal  and  vertical  axis input. For this we will create a scene without any cubes in it, then when a connection is made or the server is created, we will spawn a cube \"player\" for the newly connected client or created server.", 
            "title": "Basic Instantiation Example"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#planning-network-code", 
            "text": "So one of the first things we want to think about is our  Network Contract . This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will create a player cube for itself, it will also see all of the other connected cubes and their movements:   Player creates a cube for itself when connected  Synchronize the position and rotation of the player cube to all the clients and server  The transformations should be smooth so we need to interpolate them", 
            "title": "Planning Network Code"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#network-contract-wizard", 
            "text": "Now that we know that we need to sync the  position  and  rotation  of a cube, we can design our network contract for that object. We will first open the  Network Contract Wizard  which is a UI provided by the Bearded Man Studios team to make it easy to design your  network contracts  in a easy way. To open this menu, go into Unity and select \"Window- Forge Networking- Network Contract Wizard\".   Once you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the  Network Contract Wizard  as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the  Name  fi elds, the  Fields  field, and the  Remote Procedure Calls  field.   The  Name  field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated.  The  Fields  section shows all of the various fields that our network should be aware of. In this case we are going to want to make a  positi on  and  rotation  field which are  Vector3  and  Quaternion  respectively.  Note, you can name these fields whatever you like, these are just friendly variable names for you (and your team) to know what they are for when used  The  Remote Procedure Calls  field is where you will design any Remote Procedure Call (RPC) function signatures. We are not going to go over this field in this tutorial as we do not need it for the goal we are attempting to accomplish.   Lets begin by naming our Network Object:   Lets set the name for our Network object to \"  PlayerCube \" (without quotes)  Click the  Add Field  button  Name the new field  position  Set the type to  Vector3  Click the  Interpolate  button  Set the interpolate time (the text field that pops up after clicking the  Interpolate  button) as  0.15  Click the  Add Field  button  Name the new field  rotation  Set the type to  Quaternion  Click the  Interpolate  button  Set the interpolate time (the text field that pops up after clicking the  Interpolate  button) as  0.15  12.  Click the  Save   Compile  button", 
            "title": "Network Contract Wizard"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#extending-generated-classes", 
            "text": "When we use the  Network Contract Wizard (NCW)  we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class in particular that we want to extend from, this class name will be \"  PlayerCubeBehavior \". The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Lets now create a C# file in Unity and write our basic game logic, we will name this file \"  PlayerCube \".   Open the newly created C# file  Add  using BeardedManStudios.Forge.Networking.Generated;  to the using statements  Derive the class from  PlayerCubeBehavior  Write the rest of the logic for the cube as seen below", 
            "title": "Extending Generated Classes"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#playercube", 
            "text": "using UnityEngine;\nusing BeardedManStudios.Forge.Networking.Generated;\n\npublic class PlayerCube : PlayerCubeBehavior\n{\n    ///  summary \n    /// The speed that this cube should move by when there are axis inputs\n    ///  /summary \n    public float speed = 5.0f;\n\n    private void Update()\n    {\n        // If this is not owned by the current network client then it needs to\n        // assign it to the position and rotation specified\n        if (!networkObject.IsOwner)\n        {\n            // Assign the position of this cube to the position sent on the network\n            transform.position = networkObject.position;\n\n            // Assign the rotation of this cube to the rotation sent on the network\n            transform.rotation = networkObject.rotation;\n\n            // Stop the function here and don't run any more code in this function\n            return;\n        }\n\n        // Get the movement based on the axis input values\n        Vector3 translation = new Vector3(Input.GetAxis( Horizontal ), 0, Input.GetAxis( Vertical )).normalized;\n\n        // Scale the speed to normalize for processors\n        translation *= speed * Time.deltaTime;\n\n        // Move the object by the given translation\n        transform.position += translation;\n\n        // Just a random rotation on all axis\n        transform.Rotate(new Vector3(speed, speed, speed) * 0.25f);\n\n        // Since we are the owner, tell the network the updated position\n        networkObject.position = transform.position;\n\n        // Since we are the owner, tell the network the updated rotation\n        networkObject.rotation = transform.rotation;\n\n        // Note: Forge Networking takes care of only sending the delta, so there\n        // is no need for you to do that manually\n    }\n}", 
            "title": "PlayerCube"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#setting-up-prefab", 
            "text": "Since we are going to instantiate this object when a player connects, we will need a prefab that identifies this object. To quickly create a prefab that has a cube we will use the standard Unity process.   Right click  on the  Hierarchy  Hover our mouse over  3D Object  Click on  Cube  in the following context menu   Now that we have created a cube we need to set it up with the class  PlayerCube  class we just created   Select the cube  Click on the  Add Component  button in the  Inspector  Type in  PlayerCube  into the search  Click the  PlayerCube  script to attach it   Now that we have setup our player object it is time for us to create the prefab that will be instantiated when clients connect.   Select the cube in the  Hierarchy  Drag the cube into the  Project  area to create the prefab  Rename this prefab  PlayerCube  , this step is not required, just helps the example stay cohesive   With this we are prepared to setup our  NetworkManager  to support the new instantiation of the object.", 
            "title": "Setting up prefab"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#attaching-the-playercube-prefab-for-instantiation", 
            "text": "If you search the project directory you will find a prefab named  NetworkManager . This is a default prefab we have created for you to get started. You  can  make your own prefab or alter this one if you wish to extend behavior. Now we will go through the process of attaching our created  PlayerCube  prefab to this  NetworkManager   Select the  NetworkManager  prefab in the project  Locate the field named  Player Cube Network Object  You will notice that this is an array, set the  Size  to 1  Click the radial (circle) on the right of the  Element 0  input field  Locate and select the  PlayerCube  prefab", 
            "title": "Attaching the PlayerCube prefab for instantiation"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#setup-instantiation-scene", 
            "text": "Now that we have setup our  NetworkManager  we are ready to make our instantiate code. To do this we will create a script that will instantiate our player   Open up a new scene  Create a new C# script named  GameLogic  Open the newly created C# file  Add  using BeardedManStudios.Forge.Networking.Unity;  to the using statements  Write the rest of the logic for instantiating the cube (seen below)  Attach the newly created script to the  Main Camera  object in the scene (this is just to have the script in the scene, no other particular reason)  Save the scene as  GameScene  Add the  MultiplayerMenu  scene as the first scene  Add your  GameScene  scene as the second scene", 
            "title": "Setup Instantiation &amp; Scene"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#gamelogic", 
            "text": "using UnityEngine;\nusing BeardedManStudios.Forge.Networking.Unity;\npublic class GameLogic : MonoBehaviour\n{\n    private void Start()\n    {\n        NetworkManager.Instance.InstantiatePlayerCube();\n    }\n}", 
            "title": "GameLogic"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#test", 
            "text": "Now that we have setup our scene and everything else, it is time to test the game.   Open the  Build Settings  Click on  Player Settings...  Open the  Resolution and Presentation  section  Turn on  Run In Background*  Go back to  Build Settings  Click on  Build And Run  Once the game is open, return to the Unity Editor  Open the  MultiplayerMenu  scene  Click the play button  Click the  Host (127.0.0.1:15937)  button on the bottom of the game view  Go back to the built game  Make sure the host ip address is set to  127.0.0.1  Make sure the host port is set to  15937  Click the  Connect  button  Select the server game instance (Unity Editor)   Now if you move around the cube in the editor, you will see the movements replicated to the client(s). If you move the cube around in the client(s) you will see the cube moving on the server. Our code has the cube constantly rotating so you will see them doing that as well.", 
            "title": "Test"
        }, 
        {
            "location": "/GettingStarted/basic-instantiation-example/#troubleshooting", 
            "text": "Getting a null reference exception?  The most common user errors with this part of the documentation are:   Forgot to turn on  Run in Background*  Tried pressing the play button in the scene and not loading the  MultiplayerMenu  scene first  Not setting up the  MultiplayerMenu  scene as index 0 and the demo scene as index 1", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/", 
            "text": "Jump Start Guide\n\n\nThis example will go through all of the major uses of Forge Networking Remastered. You will learn the basic building blocks required to build any online multiplayer game using Forge Networking Remastered (FNR).\n\n\nIntroduction\n\n\nThe game we will be creating for this example is very simple. We will have two or more players that can see each other as capsules and we will have a volume (trigger), in this trigger if our player activates it (triggers it) then it will spawn a sphere to the center of the map that will have a rigidbody and random x and z force. Note that the trigger will need to be destroyed when the ball is spawned in order to prevent it from spawning more than one sphere. When the sphere is collided with y the player, then the sphere is destroyed and we add a point to the player who touched the sphere.\n\n\nVery First Step\n\n\nThe first step before adding any networking to your game is to identify where the critical points to add networking will be. Below is a list of information we know that will need to be sent across the network in order for the game to play as expected on all connections.\n\n\n\n\nSpawn player\n\n\nSync player positions\n\n\nSync player names\n\n\nDestroy trigger after touch\n\n\nSpawn sphere\n\n\nSync sphere position\n\n\nChange sphere velocity on spawn\n\n\nAdd points for colliding with sphere\n\n\nChange sphere position after collision\n\n\n\n\nNext we can go through each of our required network fields and determine which ones should be done with an RPC, network instantiate, network destroy, and which ones should be done by synchronizing a variable.\n\n\n\n\nInstantiate\n Spawn player\n\n\nVariable\n Sync player positions\n\n\nRPC\n Sync player names\n\n\nDestroy\n Remove trigger after touch\n\n\nInstantiate\n Spawn sphere\n\n\nVariable\n Sync sphere position\n\n\nRPC\n Change sphere velocity on spawn\n\n\nRPC\n Show the last person who got the ball\n\n\nRPC\n Change sphere position and velocity after collision\n\n\n\n\nBy doing this we are easily able to see what we should do next when we move onto the Network Contract Wizard (NCW).\n\n\nSetup the Game\n\n\nNext, before we setup our networking logic, we will want to setup our base game and all of it's objects and prefabs (No scripting yet).\n\n\nFirst we will create the basic world for our players to run around in.\n\n\n\n\nCreate folder:  Scenes\n\n\nCreate folder:  Scripts\n\n\nCreate folder:  Prefabs\n\n\nCreate folder:  Materials\n\n\nCreate a new scene\n\n\nDelete the \nMain Camera\n\n\nSave your scene as a new scene into \nScenes\n folder\n\n\nCreate a material in \nMaterials\n folder\n\n\nName:  Trigger\n\n\nColor:  0, 255, 0, 128\n\n\nSet Rendering Mode to Transparent\n\n\n\n\n\n\n\n\nCreate a material in \nMaterials\n folder\n\n\n\n\nName:  GameBall\n\n\nColor:  0, 0, 255, 255 Do the following in the Scene we just created.\n\n\n\n\n\n\n\n\nCreate a cube:\n\n\n\n\nPosition:  0, 0, 0\n\n\nRotation:  0, 0, 0\n\n\nScale:  25, 0.1, 25\n\n\nName:  Floor\n\n\n\n\n\n\nCreate a cube\n\n\nPosition:  -12.5, 5, 0\n\n\nRotation:  0, 0, 0\n\n\nScale:  0.1, 10, 25\n\n\nName:  Left Wall\n\n\n\n\n\n\nCreate a cube\n\n\nPosition:  12.5, 5, 0\n\n\nRotation:  0, 0, 0\n\n\nScale:  0.1, 10, 25\n\n\nName:  Right Wall\n\n\n\n\n\n\nCreate a cube\n\n\nPosition:  0, 5, -12.5\n\n\nRotation:  0, 0, 0\n\n\nScale:  25, 10, 0.1\n\n\nName:  Front Wall\n\n\n\n\n\n\nCreate a cube\n\n\nPosition:  0, 5, 12.5\n\n\nRotation:  0, 0, 0\n\n\nScale:  25, 10, 0.1\n\n\nName:  Back Wall\n\n\n\n\n\n\nCreate a cube\n\n\nPosition:  7.5, 5, 7.5\n\n\nRotation:  0, 0, 0\n\n\nScale:  10, 10, 10\n\n\nName:  Start Trigger\n\n\nSet Material to the \nTrigger\n material we created\n\n\nCheck the \nIs Trigger\n box in the box collider component on this object\n\n\n\n\n\n\nCreate a sphere\n\n\nPosition:  0, 10, 0\n\n\nRotation: 0, 0, 0\n\n\nScale:  1, 1, 1\n\n\nName:  GameBall\n\n\nSet Material to the \nGameBall\n material we created\n\n\nAdd a \nRigidbody\n component\n\n\nSave as a Prefab in the \nPrefabs\n folder\n\n\nDelete from scene\n\n\n\n\n\n\nCreate an empty Game Object\n\n\nPosition:  0, 0, 0\n\n\nRotation:  0, 0, 0\n\n\nScale:  1, 1, 1\n\n\nName:  Game Logic\n\n\n\n\n\n\nSelect the menu item \nGame Object\nUI\nText\n\n\nThe \nText\n that is created in the \nHierarchy\n\n\nRename it to \nLast Scored\n\n\nChange the \nText\n field to be empty\n\n\nSet the \nAnchor Preset\n to \nTop Left\n \n(this is the one with the top left being highlighted in the anchor image)\n e.  Set the \nPivot X\n to 0\n\n\nSet the \nPivot Y\n to 1\n\n\nSet \nPos X\n to 0\n\n\nSet \nPos Y\n to 0\n\n\nSet \nPos Z\n to 0\n\n\nSet \nWidth\n to 500\n\n\n\n\n\n\nSave the scene\n\n\n\n\nNow we have completed the setup for our game, let's setup our \nBuild Settings\n\n\n\n\nOpen Build Settings from \nFile\nBuild Settings\n (Ctrl + Shift + B on windows)\n\n\nAdd \nMultiplayerMenu\n scene as the 0th scene index\n\n\nAdd your newly saved scene as the 1st index\n\n\nClick \nPlayer Settings...\n\n\nTurn on \nRun In Background\n\n\n\n\nNow all that is left to do is setup our \nPlayer\n prefab and then we will be ready to jump into setting up our network.\n\n\n\n\nIn Unity select \nAssets\nImport Package\nCharacters\n\n\nClick the Import button\n\n\nOpen the \nStandard Assets\nCharacters\nFirstPersonCharacter\nPrefabs\n directory\n\n\nDrag the \nFPSController\n prefab into the scene\n\n\nRename the prefab to \nPlayer\n\n\nAdd a \nMesh Filter\n component\n\n\nAdd a \nMesh Renderer\n component\n\n\nSelect the \nCapsule\n as the \nMesh\n in the \nMeshFilter\n component\n\n\nOpen the \nMaterials\n drop down in the \nMesh Renderer\n\n\nSelect \nDefault-Material\n in \nElement 0\n\n\nAdd a \nSphere Collider\n\n\nSet \nY\n to -0.5\n\n\nSet \nRadius\n to 0.5\n\n\n\n\n\n\nAdd another \nSphere Collider\n\n\nSet \nY\n to 0.5\n\n\nSet \nRadius\n to 0.5\n\n\n\n\n\n\nDrag the \nPlayer\n GameObject from the \nHierarchy\n into the \nPrefabs\n folder that we made in the beginning\n\n\nDelete the \nPlayer\n Game Object from the scene \n\n\nSave the project\n\n\n\n\nThe reason we are adding 2 sphere Colliders is because (at the time of this writing) the Character Controller is not reliable for detecting collisions. You have to \"rub\" up on the object a bit before it is detected. By adding the sphere colliders to our character, this issue will be resolved.\n\n\nNow you are ready to start setting up your network contract using the \nNetwork Contract Wizard\n.\n\n\nNetwork Contract Wizard\n\n\nThe Network Contract Wizard (NCW) is responsible for creating the blueprint of the network communication. We will use this UI to setup the basic classes, fields, and remote procedure calls needed for our network communication. To get started, open the Network Contract Wizard UI by going to \nWindow\nForge Networking\nNetwork Contract Wizard\n within Unity. In this window you will be presented with all the current network classes.\n\n\nIf you included the \nBearded Man Studios Inc\n examples folder then you should see a couple pre-made options initially.\n\n\nNow let's get started on making the network contract for our simple game:\n\n\n\n\nClick the \nCreate\n button\n\n\nType in \nPlayer\n into the name box\n\n\nClick the \nAdd Field\n button\n\n\nType \nposition\n into the text box\n\n\nSelect the drop down\n\n\nSelect \nVECTOR3\n from the options\n\n\nClick the \nInterpolate\n button and leave the value at \n0.15\n\n\n\n\n\n\nClick the \nAdd RPC\n button\n\n\nType \nUpdateName\n into the text field\n\n\nOpen the \nArguments\n cascade\n    1.Click the \n button\n\n\nType \nnewName\n into the text field\n\n\nClick the drop down iv.  Select \nSTRING\n from the drop down\n\n\n\n\n\n\n\n\n\n\nClick \nSave \n Compile\n\n\n\n\nWhat this will do is create and modify some classes in the \nGenerated\n folder of your project. Before we continue to add the other network contracts, let's setup our \nPlayer\n class.\n\n\n\n\nOpen the \nScripts\n folder\n\n\nCreate a new C# script named \nPlayer\n\n\nOpen the \nPrefabs\n folder and select the \nPlayer\n prefab\n\n\nClick \nAdd Component\n\n\nAdd the \nPlayer\n script to the prefab\n\n\nSelect the \nScripts\n folder\n\n\nOpen the \nPlayer.cs\n script you just created \n\n\nInsert the following code\n\n\n\n\nPlayer.cs**\n\n\n// We use this namespace as it is where our PlayerBehavior was generated using BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Generated;\nusing UnityEngine;\nusing UnityStandardAssets.Characters.FirstPerson;\n\n// We extend PlayerBehavior which extends NetworkBehavior which extends MonoBehaviour\npublic class Player : PlayerBehavior\n{\n    private string[] nameParts = new string[] { \ncrazy\n, \ncat\n, \ndog\n, \nhomie\n, \nbobble\n, \nmr\n, \nms\n, \nmrs\n, \ncastle\n, \nflip\n, \nflop\n };\n\n    public string Name { get; private set; }\n\n    protected override void NetworkStart()\n    {\n        base.NetworkStart();\n\n        if (!networkObject.IsOwner)\n        {\n            // Don't render through a camera that is not ours\n            // Don't listen to audio through a listener that is not ours\n            transform.GetChild(0).gameObject.SetActive(false);\n\n            // Don't accept inputs from objects that are not ours\n            GetComponent\nFirstPersonController\n().enabled = false;\n\n            // There is no reason to try and simulate physics since the position is\n            // being sent across the network anyway\n            Destroy(GetComponent\nRigidbody\n());\n        }\n\n        // Assign the name when this object is setup on the network\n        ChangeName();\n    }\n\n    public void ChangeName()\n    {\n        // Only the owning client of this object can assign the name\n        if (!networkObject.IsOwner)\n        return;\n        // Get a random index for the first name\n        int first = Random.Range(0, nameParts.Length - 1);\n        // Get a random index for the last name\n        int last = Random.Range(0, nameParts.Length - 1);\n\n        // Assign the name to the random selection\n        Name = nameParts[first] + \n \n + nameParts[last];\n\n        // Send an RPC to let everyone know what the name is for this player\n        // We use \nAllBuffered\n so that if people come late they will get the\n        // latest name for this object\n        // We pass in \nName\n for the args because we have 1 argument that is to\n        // be a string as it is set in the NCW\n        networkObject.SendRpc(RPC_UPDATE_NAME, Receivers.AllBuffered, Name);\n    }\n\n    // Default Unity update method\n    private void Update()\n    {\n        // Check to see if we are the owner of this player\n        if (!networkObject.IsOwner)\n        {\n            // If we are not the owner then we set the position to the\n            // position that is syndicated across the network for this player\n            transform.position = networkObject.position;\n            return;\n        }\n\n        // When our position changes the networkObject.position will detect the\n        // change based on this assignment automatically, this data will then be\n        // syndicated across the network on the next update pass for this networkObject\n        networkObject.position = transform.position;\n    }\n\n    // Override the abstract RPC method that we made in the NCW\n    public override void UpdateName(RpcArgs args)\n    {\n        // Since there is only 1 argument and it is a string we can safely\n        // cast the first argument to a string knowing that it is going to\n        // be the name for this player\n        Name = args.GetNext\nstring\n();\n    }\n}\n\n\n\n\nThis is all the code we need to allow for all of the connections to see the movement of the players. The next thing we need is to be able to actually instantiate our \nPlayer\n prefab since it will not be in the scene at the start of the game. To do this let's open the \nNCW\n window again.\n\n\n\n\nClick the \nCreate\n button\n\n\nType in \nGameLogic\n in the name box\n\n\nClick the \nAdd RPC\n button\n\n\nType \nPlayerScored\n into the text field\n\n\nOpen the \nArguments\n cascade\n\n\nClick the \n button\n\n\nType \nplayerName\n into the text field\n\n\nClick the drop down iv.  Select \nSTRING\n from the drop down\n\n\n\n\n\n\n\n\n\n\nClick \nSave \n Compile\n\n\n\n\nWhat this will do is create and modify some classes in the \nGenerated\n folder of your project. Before we continue to add the other network contracts, let's setup our \nGameLogic\n class.\n\n\n\n\nOpen the \nScripts\n folder\n\n\nCreate a new C# script named \nGameLogic\n\n\nSelect the \nGame Logic\n Game Object from the \nHierarchy\n of our previously saved scene\n\n\nClick \nAdd Component\n\n\nAdd the \nGameLogic\n script to the Game Object\n\n\nSelect the \nScripts\n folder\n\n\nOpen the \nGameLogic.cs\n script you just created\n\n\nInsert the following code\n\n\n\n\nGameManager.cs\n\n\n// We use this namespace as it is where our GameLogicBehavior was generated\nusing BeardedManStudios.Forge.Networking.Generated;\nusing BeardedManStudios.Forge.Networking.Unity;\nusing UnityEngine;\nusing UnityEngine.UI;\n\n// We extend GameLogicBehavior which extends NetworkBehavior which extends MonoBehaviour\npublic class GameLogic : GameLogicBehavior\n{\n    public Text scoreLabel;\n    private void Start()\n    {\n        // This will be called on every client, so each client will essentially instantiate\n        // their own player on the network. We also pass in the position we want them to spawn at\n        NetworkManager.Instance.InstantiatePlayer(position: new Vector3(0, 5, 0));\n    }\n\n    // Override the abstract RPC method that we made in the NCW\n    public override void PlayerScored(RpcArgs args)\n    {\n        // Since there is only 1 argument and it is a string we can safely\n        // cast the first argument to a string knowing that it is going to\n        // be the name for the scoring player\n        string playerName = args.GetNext\nstring\n();\n\n        // Update the UI to show the last player that scored\n        scoreLabel.text = \nLast player to score was: \n + playerName;\n    }\n}\n\n\n\n\nNow we are able to not only spawn the player, but we are also able to print out the last player that scored to the screen. Talking about scoring, we possibly want to get the ball rolling (if you would excuse the expression) and instantiate the \nball\n and serialize it's position to all the clients. However just before that, lets fill out our scoreLabel object on our \nGame Logic\n Game Object.\n\n\n\n\nSelect the \nGame Logic\n from the \nhierarchy\n\n\nDrag the \nLast Scored\n UI Game Object from the \nhierarchy\n to the \nScore Label\n field on the \nGameLogic\n script\n\n\n\n\nOkay, now we are actually ready to make the ball now! So let's start by opening up the \nNCW\n window once again.\n\n\n\n\nClick the \nCreate\n button\n\n\nType in \nGameBall\n into the name box\n\n\nClick the \nAdd Field\n button\n\n\nType \nposition\n into the text box\n\n\nSelect the drop down\n\n\nSelect \nVECTOR3\n from the options\n\n\nClick the \nInterpolate\n button and leave the value at \n0.15\n\n\n\n\n\n\nClick \nSave \n Compile\n\n\n\n\nWhat this will do is create and modify some classes in the \nGenerated\n folder of your project. Before we continue to add the other network contracts, let's setup our \nGameBall\n class.\n\n\n\n\nOpen the \nScripts\n folder\n\n\nCreate a new C# script named \nGameBall\n\n\nOpen the \nPrefabs\n folder and select the \nGameBall\n prefab\n\n\nClick \nAdd Component\n\n\nAdd the \nGameBall\n script to the prefab\n\n\nSelect the \nScripts\n folder\n\n\nOpen the \nGameBall.cs\n script you just created\n\n\nInsert the following code\n\n\n\n\nGameBall.cs\n\n\n// We use this namespace as it is where our BallBehavior was generated\nusing BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Generated;\nusing BeardedManStudios.Forge.Networking.Unity;\nusing UnityEngine;\n\n// We extend BallBehavior which extends NetworkBehavior which extends MonoBehaviour\npublic class GameBall : GameBallBehavior\n{\n    private Rigidbody rigidbodyRef;\n    private GameLogic gameLogic;\n\n    private void Awake()\n    {\n        rigidbodyRef = GetComponent\nRigidbody\n();\n        gameLogic = FindObjectOfType\nGameLogic\n();\n    }\n\n    // Default Unity update method\n    private void Update()\n    {\n        // Check to see if we are the owner of this ball\n        if (!networkObject.IsOwner)\n        {\n            // If we are not the owner then we set the position to the\n            // position that is syndicated across the network for this ball\n            transform.position = networkObject.position;\n            return;\n        }\n\n        // When our position changes the networkObject.position will detect the\n        // change based on this assignment automatically, this data will then be\n        // syndicated across the network on the next update pass for this networkObject\n        networkObject.position = transform.position;\n    }\n\n    public void Reset()\n    {\n        // Move the ball to 0, 10, 0\n        transform.position = Vector3.up * 10;\n\n        // Reset the velocity for this object to zero\n        rigidbodyRef.velocity = Vector3.zero;\n\n        // Create a random force to apply to this object between 300 to 500 or -300 to -500\n        Vector3 force = new Vector3(0, 0, 0);\n        force.x = Random.Range(300, 500);\n        force.z = Random.Range(300, 500);\n\n        // Randomly invert along the number line by 50%\n        if (Random.value \n 0.5f)\n            force.x *= -1;\n\n        if (Random.value \n 0.5f)\n            force.z *= -1;\n\n        // Add the random force to the ball\n        rigidbodyRef.AddForce(force);\n    }\n\n    private void OnCollisionEnter(Collision c)\n    {\n        // We are making this authoritative by only\n        // allowing the server to call it\n        if (!networkObject.IsServer)\n            return;\n\n        // Only move if a player touched the ball\n        if (c.GetComponent\nPlayer\n() == null)\n            return;\n\n        // Call an RPC on the Game Logic to print the player's name as the last\n        // player to touch the ball\n        gameLogic.networkObject.SendRpc(GameLogicBehavior.RPC_PLAYER_SCORED, Receivers.All,\n\n        c.GetComponent\nPlayer\n().Name);\n\n        // Reset the ball\n        Reset();\n    }\n}\n\n\n\n\nWith the ball complete, we are finally ready to move onto the last script that we will need to create, the behavior for the trigger that starts the whole game!\n\n\n\n\nOpen the \nScripts\n folder\n\n\nCreate a new C# script named \nGameTrigger\n\n\nSelect the \nStart Trigger\n Game Object from the \nHierarchy\n of our previously saved scene\n\n\nClick \nAdd Component\n\n\nAdd the \nGameTrigger\n script to the Game Object\n\n\nSelect the \nScripts\n folder\n\n\nOpen the \nGameTrigger.cs\n script you just created\n\n\nInsert the following code\n\n\n\n\nGameTrigger.cs\n\n\nusing BeardedManStudios.Forge.Networking.Unity;\nusing UnityEngine;\n\npublic class GameTrigger : MonoBehaviour\n{\n    private bool started;\n\n    private void Update()\n    {\n        // If the game started we will remove this trigger from the scene\n        if (FindObjectOfType\nGameBall\n() != null)\n            Destroy(gameObject);\n    }\n\n    private void OnTriggerEnter(Collider c)\n    {\n        // Since we added 2 sphere colliders to the player, we need to\n        // make sure to only trigger this 1 time\n        if (started)\n            return;\n\n        // Only allow the server player to start the game so that the\n        // server is the owner of the ball, otherwise if a client is the\n        // owner of the ball, if they disconnect, the ball will be destroyed\n        if (!NetworkManager.Instance.IsServer)\n            return;\n\n        Player player = c.GetComponent\nPlayer\n();\n\n        if (player == null)\n            return;\n\n        started = true;\n\n        // We need to create the ball on the network\n        GameBall ball = NetworkManager.Instance.InstantiateGameBall() as GameBall;\n\n        // Reset the ball position and give it a random velocity\n        ball.Reset();\n\n        // We no longer need this trigger, the game has started\n        Destroy(gameObject);\n    }\n}\n\n\n\n\nFinalization of our game!\n\n\nNow that we have finished all of the network code, we need to tell Forge what prefabs are suppose to be instantiated when we make those \nNetworkManager.Instance.Instantiat...\n calls.\n\n\n\n\nOpen \nBearded Man Studios Inc\nPrefabs\n\n\nSelect the prefab named \nNetworkManager\n\n\nLocate the various empty fields in the \nNetworkManager\n component that is attached to this prefab\n\n\nIn the \nGameBall Network Object\n array field, put the \nGameBall\n prefab from the \nPrefabs\n folder as the \nElement 0\n (0th index)\n\n\nIn the \nPlayer Network Object\n array field, put the \nPlayer\n prefab from the \nPrefabs\n folder as the \nElement 0\n (0th index)\n\n\n\n\nCongratulations\n\n\nYou have completed the steps for this tutorial. All that is left is to build, run and test it out. To do this just build the project as you normally would do within the Unity Editor.\n\n\n\n\nBuild the project\n\n\nRun 2 instances of the project\n\n\nSelect \nHost\n in one instance\n\n\nClick \nConnect\n in the second instance\n\n\nYou may be prompted to allow access to the application on the firewall, which you will need to accept\n\n\n\n\nTroubleshooting\n\n\nGetting a null reference exception?\n\n\nThe most common user errors with this part of the documentation are:\n\n\n\n\nForgot to turn on Run in Background*\n\n\nTried pressing the play button in the scene and not loading the Multiplayer Menu scene first\n\n\nNot setting up the multiplayer menu scene as index 0 and the demo scene as index 1", 
            "title": "Jump start guide"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#jump-start-guide", 
            "text": "This example will go through all of the major uses of Forge Networking Remastered. You will learn the basic building blocks required to build any online multiplayer game using Forge Networking Remastered (FNR).", 
            "title": "Jump Start Guide"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#introduction", 
            "text": "The game we will be creating for this example is very simple. We will have two or more players that can see each other as capsules and we will have a volume (trigger), in this trigger if our player activates it (triggers it) then it will spawn a sphere to the center of the map that will have a rigidbody and random x and z force. Note that the trigger will need to be destroyed when the ball is spawned in order to prevent it from spawning more than one sphere. When the sphere is collided with y the player, then the sphere is destroyed and we add a point to the player who touched the sphere.", 
            "title": "Introduction"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#very-first-step", 
            "text": "The first step before adding any networking to your game is to identify where the critical points to add networking will be. Below is a list of information we know that will need to be sent across the network in order for the game to play as expected on all connections.   Spawn player  Sync player positions  Sync player names  Destroy trigger after touch  Spawn sphere  Sync sphere position  Change sphere velocity on spawn  Add points for colliding with sphere  Change sphere position after collision   Next we can go through each of our required network fields and determine which ones should be done with an RPC, network instantiate, network destroy, and which ones should be done by synchronizing a variable.   Instantiate  Spawn player  Variable  Sync player positions  RPC  Sync player names  Destroy  Remove trigger after touch  Instantiate  Spawn sphere  Variable  Sync sphere position  RPC  Change sphere velocity on spawn  RPC  Show the last person who got the ball  RPC  Change sphere position and velocity after collision   By doing this we are easily able to see what we should do next when we move onto the Network Contract Wizard (NCW).", 
            "title": "Very First Step"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#setup-the-game", 
            "text": "Next, before we setup our networking logic, we will want to setup our base game and all of it's objects and prefabs (No scripting yet).  First we will create the basic world for our players to run around in.   Create folder:  Scenes  Create folder:  Scripts  Create folder:  Prefabs  Create folder:  Materials  Create a new scene  Delete the  Main Camera  Save your scene as a new scene into  Scenes  folder  Create a material in  Materials  folder  Name:  Trigger  Color:  0, 255, 0, 128  Set Rendering Mode to Transparent     Create a material in  Materials  folder   Name:  GameBall  Color:  0, 0, 255, 255 Do the following in the Scene we just created.     Create a cube:   Position:  0, 0, 0  Rotation:  0, 0, 0  Scale:  25, 0.1, 25  Name:  Floor    Create a cube  Position:  -12.5, 5, 0  Rotation:  0, 0, 0  Scale:  0.1, 10, 25  Name:  Left Wall    Create a cube  Position:  12.5, 5, 0  Rotation:  0, 0, 0  Scale:  0.1, 10, 25  Name:  Right Wall    Create a cube  Position:  0, 5, -12.5  Rotation:  0, 0, 0  Scale:  25, 10, 0.1  Name:  Front Wall    Create a cube  Position:  0, 5, 12.5  Rotation:  0, 0, 0  Scale:  25, 10, 0.1  Name:  Back Wall    Create a cube  Position:  7.5, 5, 7.5  Rotation:  0, 0, 0  Scale:  10, 10, 10  Name:  Start Trigger  Set Material to the  Trigger  material we created  Check the  Is Trigger  box in the box collider component on this object    Create a sphere  Position:  0, 10, 0  Rotation: 0, 0, 0  Scale:  1, 1, 1  Name:  GameBall  Set Material to the  GameBall  material we created  Add a  Rigidbody  component  Save as a Prefab in the  Prefabs  folder  Delete from scene    Create an empty Game Object  Position:  0, 0, 0  Rotation:  0, 0, 0  Scale:  1, 1, 1  Name:  Game Logic    Select the menu item  Game Object UI Text  The  Text  that is created in the  Hierarchy  Rename it to  Last Scored  Change the  Text  field to be empty  Set the  Anchor Preset  to  Top Left   (this is the one with the top left being highlighted in the anchor image)  e.  Set the  Pivot X  to 0  Set the  Pivot Y  to 1  Set  Pos X  to 0  Set  Pos Y  to 0  Set  Pos Z  to 0  Set  Width  to 500    Save the scene   Now we have completed the setup for our game, let's setup our  Build Settings   Open Build Settings from  File Build Settings  (Ctrl + Shift + B on windows)  Add  MultiplayerMenu  scene as the 0th scene index  Add your newly saved scene as the 1st index  Click  Player Settings...  Turn on  Run In Background   Now all that is left to do is setup our  Player  prefab and then we will be ready to jump into setting up our network.   In Unity select  Assets Import Package Characters  Click the Import button  Open the  Standard Assets Characters FirstPersonCharacter Prefabs  directory  Drag the  FPSController  prefab into the scene  Rename the prefab to  Player  Add a  Mesh Filter  component  Add a  Mesh Renderer  component  Select the  Capsule  as the  Mesh  in the  MeshFilter  component  Open the  Materials  drop down in the  Mesh Renderer  Select  Default-Material  in  Element 0  Add a  Sphere Collider  Set  Y  to -0.5  Set  Radius  to 0.5    Add another  Sphere Collider  Set  Y  to 0.5  Set  Radius  to 0.5    Drag the  Player  GameObject from the  Hierarchy  into the  Prefabs  folder that we made in the beginning  Delete the  Player  Game Object from the scene   Save the project   The reason we are adding 2 sphere Colliders is because (at the time of this writing) the Character Controller is not reliable for detecting collisions. You have to \"rub\" up on the object a bit before it is detected. By adding the sphere colliders to our character, this issue will be resolved.  Now you are ready to start setting up your network contract using the  Network Contract Wizard .", 
            "title": "Setup the Game"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#network-contract-wizard", 
            "text": "The Network Contract Wizard (NCW) is responsible for creating the blueprint of the network communication. We will use this UI to setup the basic classes, fields, and remote procedure calls needed for our network communication. To get started, open the Network Contract Wizard UI by going to  Window Forge Networking Network Contract Wizard  within Unity. In this window you will be presented with all the current network classes.  If you included the  Bearded Man Studios Inc  examples folder then you should see a couple pre-made options initially.  Now let's get started on making the network contract for our simple game:   Click the  Create  button  Type in  Player  into the name box  Click the  Add Field  button  Type  position  into the text box  Select the drop down  Select  VECTOR3  from the options  Click the  Interpolate  button and leave the value at  0.15    Click the  Add RPC  button  Type  UpdateName  into the text field  Open the  Arguments  cascade\n    1.Click the   button  Type  newName  into the text field  Click the drop down iv.  Select  STRING  from the drop down      Click  Save   Compile   What this will do is create and modify some classes in the  Generated  folder of your project. Before we continue to add the other network contracts, let's setup our  Player  class.   Open the  Scripts  folder  Create a new C# script named  Player  Open the  Prefabs  folder and select the  Player  prefab  Click  Add Component  Add the  Player  script to the prefab  Select the  Scripts  folder  Open the  Player.cs  script you just created   Insert the following code", 
            "title": "Network Contract Wizard"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#playercs", 
            "text": "// We use this namespace as it is where our PlayerBehavior was generated using BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Generated;\nusing UnityEngine;\nusing UnityStandardAssets.Characters.FirstPerson;\n\n// We extend PlayerBehavior which extends NetworkBehavior which extends MonoBehaviour\npublic class Player : PlayerBehavior\n{\n    private string[] nameParts = new string[] {  crazy ,  cat ,  dog ,  homie ,  bobble ,  mr ,  ms ,  mrs ,  castle ,  flip ,  flop  };\n\n    public string Name { get; private set; }\n\n    protected override void NetworkStart()\n    {\n        base.NetworkStart();\n\n        if (!networkObject.IsOwner)\n        {\n            // Don't render through a camera that is not ours\n            // Don't listen to audio through a listener that is not ours\n            transform.GetChild(0).gameObject.SetActive(false);\n\n            // Don't accept inputs from objects that are not ours\n            GetComponent FirstPersonController ().enabled = false;\n\n            // There is no reason to try and simulate physics since the position is\n            // being sent across the network anyway\n            Destroy(GetComponent Rigidbody ());\n        }\n\n        // Assign the name when this object is setup on the network\n        ChangeName();\n    }\n\n    public void ChangeName()\n    {\n        // Only the owning client of this object can assign the name\n        if (!networkObject.IsOwner)\n        return;\n        // Get a random index for the first name\n        int first = Random.Range(0, nameParts.Length - 1);\n        // Get a random index for the last name\n        int last = Random.Range(0, nameParts.Length - 1);\n\n        // Assign the name to the random selection\n        Name = nameParts[first] +     + nameParts[last];\n\n        // Send an RPC to let everyone know what the name is for this player\n        // We use  AllBuffered  so that if people come late they will get the\n        // latest name for this object\n        // We pass in  Name  for the args because we have 1 argument that is to\n        // be a string as it is set in the NCW\n        networkObject.SendRpc(RPC_UPDATE_NAME, Receivers.AllBuffered, Name);\n    }\n\n    // Default Unity update method\n    private void Update()\n    {\n        // Check to see if we are the owner of this player\n        if (!networkObject.IsOwner)\n        {\n            // If we are not the owner then we set the position to the\n            // position that is syndicated across the network for this player\n            transform.position = networkObject.position;\n            return;\n        }\n\n        // When our position changes the networkObject.position will detect the\n        // change based on this assignment automatically, this data will then be\n        // syndicated across the network on the next update pass for this networkObject\n        networkObject.position = transform.position;\n    }\n\n    // Override the abstract RPC method that we made in the NCW\n    public override void UpdateName(RpcArgs args)\n    {\n        // Since there is only 1 argument and it is a string we can safely\n        // cast the first argument to a string knowing that it is going to\n        // be the name for this player\n        Name = args.GetNext string ();\n    }\n}  This is all the code we need to allow for all of the connections to see the movement of the players. The next thing we need is to be able to actually instantiate our  Player  prefab since it will not be in the scene at the start of the game. To do this let's open the  NCW  window again.   Click the  Create  button  Type in  GameLogic  in the name box  Click the  Add RPC  button  Type  PlayerScored  into the text field  Open the  Arguments  cascade  Click the   button  Type  playerName  into the text field  Click the drop down iv.  Select  STRING  from the drop down      Click  Save   Compile   What this will do is create and modify some classes in the  Generated  folder of your project. Before we continue to add the other network contracts, let's setup our  GameLogic  class.   Open the  Scripts  folder  Create a new C# script named  GameLogic  Select the  Game Logic  Game Object from the  Hierarchy  of our previously saved scene  Click  Add Component  Add the  GameLogic  script to the Game Object  Select the  Scripts  folder  Open the  GameLogic.cs  script you just created  Insert the following code", 
            "title": "Player.cs**"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#gamemanagercs", 
            "text": "// We use this namespace as it is where our GameLogicBehavior was generated\nusing BeardedManStudios.Forge.Networking.Generated;\nusing BeardedManStudios.Forge.Networking.Unity;\nusing UnityEngine;\nusing UnityEngine.UI;\n\n// We extend GameLogicBehavior which extends NetworkBehavior which extends MonoBehaviour\npublic class GameLogic : GameLogicBehavior\n{\n    public Text scoreLabel;\n    private void Start()\n    {\n        // This will be called on every client, so each client will essentially instantiate\n        // their own player on the network. We also pass in the position we want them to spawn at\n        NetworkManager.Instance.InstantiatePlayer(position: new Vector3(0, 5, 0));\n    }\n\n    // Override the abstract RPC method that we made in the NCW\n    public override void PlayerScored(RpcArgs args)\n    {\n        // Since there is only 1 argument and it is a string we can safely\n        // cast the first argument to a string knowing that it is going to\n        // be the name for the scoring player\n        string playerName = args.GetNext string ();\n\n        // Update the UI to show the last player that scored\n        scoreLabel.text =  Last player to score was:   + playerName;\n    }\n}  Now we are able to not only spawn the player, but we are also able to print out the last player that scored to the screen. Talking about scoring, we possibly want to get the ball rolling (if you would excuse the expression) and instantiate the  ball  and serialize it's position to all the clients. However just before that, lets fill out our scoreLabel object on our  Game Logic  Game Object.   Select the  Game Logic  from the  hierarchy  Drag the  Last Scored  UI Game Object from the  hierarchy  to the  Score Label  field on the  GameLogic  script   Okay, now we are actually ready to make the ball now! So let's start by opening up the  NCW  window once again.   Click the  Create  button  Type in  GameBall  into the name box  Click the  Add Field  button  Type  position  into the text box  Select the drop down  Select  VECTOR3  from the options  Click the  Interpolate  button and leave the value at  0.15    Click  Save   Compile   What this will do is create and modify some classes in the  Generated  folder of your project. Before we continue to add the other network contracts, let's setup our  GameBall  class.   Open the  Scripts  folder  Create a new C# script named  GameBall  Open the  Prefabs  folder and select the  GameBall  prefab  Click  Add Component  Add the  GameBall  script to the prefab  Select the  Scripts  folder  Open the  GameBall.cs  script you just created  Insert the following code", 
            "title": "GameManager.cs"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#gameballcs", 
            "text": "// We use this namespace as it is where our BallBehavior was generated\nusing BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Generated;\nusing BeardedManStudios.Forge.Networking.Unity;\nusing UnityEngine;\n\n// We extend BallBehavior which extends NetworkBehavior which extends MonoBehaviour\npublic class GameBall : GameBallBehavior\n{\n    private Rigidbody rigidbodyRef;\n    private GameLogic gameLogic;\n\n    private void Awake()\n    {\n        rigidbodyRef = GetComponent Rigidbody ();\n        gameLogic = FindObjectOfType GameLogic ();\n    }\n\n    // Default Unity update method\n    private void Update()\n    {\n        // Check to see if we are the owner of this ball\n        if (!networkObject.IsOwner)\n        {\n            // If we are not the owner then we set the position to the\n            // position that is syndicated across the network for this ball\n            transform.position = networkObject.position;\n            return;\n        }\n\n        // When our position changes the networkObject.position will detect the\n        // change based on this assignment automatically, this data will then be\n        // syndicated across the network on the next update pass for this networkObject\n        networkObject.position = transform.position;\n    }\n\n    public void Reset()\n    {\n        // Move the ball to 0, 10, 0\n        transform.position = Vector3.up * 10;\n\n        // Reset the velocity for this object to zero\n        rigidbodyRef.velocity = Vector3.zero;\n\n        // Create a random force to apply to this object between 300 to 500 or -300 to -500\n        Vector3 force = new Vector3(0, 0, 0);\n        force.x = Random.Range(300, 500);\n        force.z = Random.Range(300, 500);\n\n        // Randomly invert along the number line by 50%\n        if (Random.value   0.5f)\n            force.x *= -1;\n\n        if (Random.value   0.5f)\n            force.z *= -1;\n\n        // Add the random force to the ball\n        rigidbodyRef.AddForce(force);\n    }\n\n    private void OnCollisionEnter(Collision c)\n    {\n        // We are making this authoritative by only\n        // allowing the server to call it\n        if (!networkObject.IsServer)\n            return;\n\n        // Only move if a player touched the ball\n        if (c.GetComponent Player () == null)\n            return;\n\n        // Call an RPC on the Game Logic to print the player's name as the last\n        // player to touch the ball\n        gameLogic.networkObject.SendRpc(GameLogicBehavior.RPC_PLAYER_SCORED, Receivers.All,\n\n        c.GetComponent Player ().Name);\n\n        // Reset the ball\n        Reset();\n    }\n}  With the ball complete, we are finally ready to move onto the last script that we will need to create, the behavior for the trigger that starts the whole game!   Open the  Scripts  folder  Create a new C# script named  GameTrigger  Select the  Start Trigger  Game Object from the  Hierarchy  of our previously saved scene  Click  Add Component  Add the  GameTrigger  script to the Game Object  Select the  Scripts  folder  Open the  GameTrigger.cs  script you just created  Insert the following code", 
            "title": "GameBall.cs"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#gametriggercs", 
            "text": "using BeardedManStudios.Forge.Networking.Unity;\nusing UnityEngine;\n\npublic class GameTrigger : MonoBehaviour\n{\n    private bool started;\n\n    private void Update()\n    {\n        // If the game started we will remove this trigger from the scene\n        if (FindObjectOfType GameBall () != null)\n            Destroy(gameObject);\n    }\n\n    private void OnTriggerEnter(Collider c)\n    {\n        // Since we added 2 sphere colliders to the player, we need to\n        // make sure to only trigger this 1 time\n        if (started)\n            return;\n\n        // Only allow the server player to start the game so that the\n        // server is the owner of the ball, otherwise if a client is the\n        // owner of the ball, if they disconnect, the ball will be destroyed\n        if (!NetworkManager.Instance.IsServer)\n            return;\n\n        Player player = c.GetComponent Player ();\n\n        if (player == null)\n            return;\n\n        started = true;\n\n        // We need to create the ball on the network\n        GameBall ball = NetworkManager.Instance.InstantiateGameBall() as GameBall;\n\n        // Reset the ball position and give it a random velocity\n        ball.Reset();\n\n        // We no longer need this trigger, the game has started\n        Destroy(gameObject);\n    }\n}  Finalization of our game!  Now that we have finished all of the network code, we need to tell Forge what prefabs are suppose to be instantiated when we make those  NetworkManager.Instance.Instantiat...  calls.   Open  Bearded Man Studios Inc Prefabs  Select the prefab named  NetworkManager  Locate the various empty fields in the  NetworkManager  component that is attached to this prefab  In the  GameBall Network Object  array field, put the  GameBall  prefab from the  Prefabs  folder as the  Element 0  (0th index)  In the  Player Network Object  array field, put the  Player  prefab from the  Prefabs  folder as the  Element 0  (0th index)", 
            "title": "GameTrigger.cs"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#congratulations", 
            "text": "You have completed the steps for this tutorial. All that is left is to build, run and test it out. To do this just build the project as you normally would do within the Unity Editor.   Build the project  Run 2 instances of the project  Select  Host  in one instance  Click  Connect  in the second instance  You may be prompted to allow access to the application on the firewall, which you will need to accept", 
            "title": "Congratulations"
        }, 
        {
            "location": "/GettingStarted/jump-start-guide/#troubleshooting", 
            "text": "Getting a null reference exception?  The most common user errors with this part of the documentation are:   Forgot to turn on Run in Background*  Tried pressing the play button in the scene and not loading the Multiplayer Menu scene first  Not setting up the multiplayer menu scene as index 0 and the demo scene as index 1", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/NetworkContractWizard/network-contract-wizard-ncw/", 
            "text": "Network Contract Wizard (NCW)\n\n\nThe Network Contract Wizard is the new way for you to implement networking for your game/app.\n\n\nTo do so you will need to go to \nWindow-\nForge Networking-\nNetwork Contract Wizard\n as shown in the example below.\n\n\n\n\nAfter opening the window you will be presented with this.\n\n\n\n\n\n\n1)Toggle lighting on/off for the editor window only. This will make it easier for your eyes depending on what lighting situation you have.\n\n\n2)Create, this will make networked objects for you to use for your game/app. (You will spend most of your time hitting this beautifully designedbutton).\n\n\n3)Deletion, this will properly delete the networked objects that you have made.\n\n\n\n\nNote: You are able to tap any of the NetwrokObjects to modify them as well.\n\n\nCreation Menu\n\n\n\n\n\n\n1)Name field for you to name your networked object (Do not use the same name as ones already made)\n\n\n2)Add fields (This is where you would add variables to sync across the network)\n\n\n3)Add RPC (This is where you would create callbacks for other clients to messages/data being sent)\n\n\n\n\nAdding a Field\n\n\n\n\n\n\n1)The name of the variable\n\n\n2)The type of variable this will be\n\n\n3)There are many different types to select from (This is just an example of selecting int for this variable) Note: The trash bin next to this variable will delete it.\n\n\n\n\nAdding a RPC\n\n\n\n\n\n\n1)Name of the RPC\n\n\n2)Arguments for this RPC that will be sent across the network.\n\n\n3)Value type that can be passed across the network.\n\n\n4)Deletion of this RPC\n\n\n5)Deletion of this Value Type\n\n\n6)Add more Value Types for the arguments\n\n\n\n\nMain Menu Deletion\n\n\n\n\n\n\n1)This will trash this Networked Object correctly.\n\n\n2)You will be prompted with this window when doing so.\n\n\n\n\nProject Directory\n\n\n\n\nYou will notice that all generated code will be located in your project directory under \nGenerated\n.\n\n\nNote: This will be changeable from the editor in the future.\n\n\nNote: if you are getting RPCs lagging, then being called all at once, make sure \"autoconnect profiler\" is turned off in your build settings.", 
            "title": "Network contract wizard ncw"
        }, 
        {
            "location": "/NetworkContractWizard/network-contract-wizard-ncw/#network-contract-wizard-ncw", 
            "text": "The Network Contract Wizard is the new way for you to implement networking for your game/app.  To do so you will need to go to  Window- Forge Networking- Network Contract Wizard  as shown in the example below.   After opening the window you will be presented with this.    1)Toggle lighting on/off for the editor window only. This will make it easier for your eyes depending on what lighting situation you have.  2)Create, this will make networked objects for you to use for your game/app. (You will spend most of your time hitting this beautifully designedbutton).  3)Deletion, this will properly delete the networked objects that you have made.   Note: You are able to tap any of the NetwrokObjects to modify them as well.  Creation Menu    1)Name field for you to name your networked object (Do not use the same name as ones already made)  2)Add fields (This is where you would add variables to sync across the network)  3)Add RPC (This is where you would create callbacks for other clients to messages/data being sent)   Adding a Field    1)The name of the variable  2)The type of variable this will be  3)There are many different types to select from (This is just an example of selecting int for this variable) Note: The trash bin next to this variable will delete it.   Adding a RPC    1)Name of the RPC  2)Arguments for this RPC that will be sent across the network.  3)Value type that can be passed across the network.  4)Deletion of this RPC  5)Deletion of this Value Type  6)Add more Value Types for the arguments   Main Menu Deletion    1)This will trash this Networked Object correctly.  2)You will be prompted with this window when doing so.   Project Directory   You will notice that all generated code will be located in your project directory under  Generated .  Note: This will be changeable from the editor in the future.  Note: if you are getting RPCs lagging, then being called all at once, make sure \"autoconnect profiler\" is turned off in your build settings.", 
            "title": "Network Contract Wizard (NCW)"
        }, 
        {
            "location": "/NetworkContractWizard/extending-generated-classes/", 
            "text": "Extending Generated Classes\n\n\nYou may have noticed by now that Forge Networking Remastered (FNR) will generate network code through the Network Contract Wizard (NCW) . The main purpose of this is to completely remove reflection and make the system easier to test and debug. The generated code will hook into the Forge Networking core framework and setup hooks and connections so that you, as the user of the API, does not have to do all that repetitive work and you can just focus on developing your product.\n\n\nIf you have looked through the generated code you may have seen that the classes that are generated are \npartial\n classes. If you are unfamiliar with partial classes, we would like to invite you to review the standard \nMSDN C# documentation\n for \npartial classes\n. If you are familiar with the concept of partial classes then you are already a step closer to being able to easily extend the generated code.\n\n\nIn many cases it would be advantageous for us to be able to \nadd more\n code to generated code. This is because we may have multiple different objects inheriting or using the classes that are generated. In this scenario, it would not make sense to write another class and make sure to remember to attach it to every object that uses the class in question. There are scenarios where you would just like to be able to manually add more options to a generated class for further use or for utility sake. To do this, all you need to do is create a new class with the same name as the target class in question. Then make sure to place the keyword \npartial\n just before you type the \nclass\n keyword.\n\n\npublic partial class MyClass //\u2026\n\n\n\n\nPartial classes are essentially compiled together into one combined class, so it is like editing the source file without having to actually change the source file.", 
            "title": "Extending generated classes"
        }, 
        {
            "location": "/NetworkContractWizard/extending-generated-classes/#extending-generated-classes", 
            "text": "You may have noticed by now that Forge Networking Remastered (FNR) will generate network code through the Network Contract Wizard (NCW) . The main purpose of this is to completely remove reflection and make the system easier to test and debug. The generated code will hook into the Forge Networking core framework and setup hooks and connections so that you, as the user of the API, does not have to do all that repetitive work and you can just focus on developing your product.  If you have looked through the generated code you may have seen that the classes that are generated are  partial  classes. If you are unfamiliar with partial classes, we would like to invite you to review the standard  MSDN C# documentation  for  partial classes . If you are familiar with the concept of partial classes then you are already a step closer to being able to easily extend the generated code.  In many cases it would be advantageous for us to be able to  add more  code to generated code. This is because we may have multiple different objects inheriting or using the classes that are generated. In this scenario, it would not make sense to write another class and make sure to remember to attach it to every object that uses the class in question. There are scenarios where you would just like to be able to manually add more options to a generated class for further use or for utility sake. To do this, all you need to do is create a new class with the same name as the target class in question. Then make sure to place the keyword  partial  just before you type the  class  keyword.  public partial class MyClass //\u2026  Partial classes are essentially compiled together into one combined class, so it is like editing the source file without having to actually change the source file.", 
            "title": "Extending Generated Classes"
        }, 
        {
            "location": "/NetworkContractWizard/name-collision-issues/", 
            "text": "Name Collision Issues\n\n\nAs you may have read in Network Object, the network object has an owner. This owner is responsible for updating the Fields. Since there is one owner of an object, you may want to update who owns an object at runtime. For example, if there is a car on the street, it may be currently owned by the server (because the server spawned the object), however a player gets into the car to drive it, now we would want the player to own the car and update it's variables. To do this we have two methods that are a part of the Network Object and one extra method to override to validate ownership changes on the server.", 
            "title": "Name collision issues"
        }, 
        {
            "location": "/NetworkContractWizard/name-collision-issues/#name-collision-issues", 
            "text": "As you may have read in Network Object, the network object has an owner. This owner is responsible for updating the Fields. Since there is one owner of an object, you may want to update who owns an object at runtime. For example, if there is a car on the street, it may be currently owned by the server (because the server spawned the object), however a player gets into the car to drive it, now we would want the player to own the car and update it's variables. To do this we have two methods that are a part of the Network Object and one extra method to override to validate ownership changes on the server.", 
            "title": "Name Collision Issues"
        }, 
        {
            "location": "/NetworkObject/changing-ownership/", 
            "text": "Changing Ownership\n\n\nThere are two different methods to use for changing ownership of an object; one for the client and one for the server. The client method is \nTakeOwnership\n and has no arguments. Any client can call this method on the \nnetworkObject\n to request ownership of an object. The method that you would use to force ownership from the server is \nAssignOwnership\n which has an argument \nNetworkingPlayer\n (the player who is going to be the new owner for the network object). Only the server can call this method on the \nnetworkObject\n due to it's authoritative nature. If a client were to call this method, nothing would happen.\n\n\nAs for verifying an ownership change request, which if you don't do it will just accept the change ownership request, there is one method to override. We live in a world where we just can't trust our clients to send us messages that they should be in the way that we wish them to. Clients may want to cheat the system and try to exploit the network for fun or just so that they can win. Because of this we have created a simple method for you to override in order to check any game critical RPCs that are received from the client and verify them. Before continuing with this part of the documentation, please review the Extending Generated Classes documentation to learn more about \npartial\n classes.\n\n\nWhen we use the Network Contract Wizard (NCW), it will create 2 generated classes; one for our MonoBehaviour and one for our NetworkObject.\n\n\nThe one that we want to focus on in this example is the generated NetworkObject. So let's say that we opened up the Network Contract Wizard (NCW) and we created a contract named \nCar\n ; this will generate a NetworkObject class named \nCarNetworkObject\n. Now in another folder (not in the Generated folder) you will create a new C# script called \nCarNetworkObject\n. In here you will create your \npartial class\n for the \nCarNetworkObje ct\n and you will override the \nAllowOwnershipChange\n method like so:\n\n\nAllowOwnershipChange\n\n\nprotected override bool AllowOwnershipChange(NetworkingPlayer newOwner)\n{\n    // The newOwner is the NetworkingPlayer that is requesting the ownership change, you can get the current owner with just \nOwner\n\n}\n\n\n\n\nNotice that you need to return a boolean from this function. If you return \ntrue\n then the ownership change will be allowed to go through, it will be invoked on the server and on the clients. If you return \nfalse\n then the ownership change will not be invoked at all and will be dropped.", 
            "title": "Changing ownership"
        }, 
        {
            "location": "/NetworkObject/changing-ownership/#changing-ownership", 
            "text": "There are two different methods to use for changing ownership of an object; one for the client and one for the server. The client method is  TakeOwnership  and has no arguments. Any client can call this method on the  networkObject  to request ownership of an object. The method that you would use to force ownership from the server is  AssignOwnership  which has an argument  NetworkingPlayer  (the player who is going to be the new owner for the network object). Only the server can call this method on the  networkObject  due to it's authoritative nature. If a client were to call this method, nothing would happen.  As for verifying an ownership change request, which if you don't do it will just accept the change ownership request, there is one method to override. We live in a world where we just can't trust our clients to send us messages that they should be in the way that we wish them to. Clients may want to cheat the system and try to exploit the network for fun or just so that they can win. Because of this we have created a simple method for you to override in order to check any game critical RPCs that are received from the client and verify them. Before continuing with this part of the documentation, please review the Extending Generated Classes documentation to learn more about  partial  classes.  When we use the Network Contract Wizard (NCW), it will create 2 generated classes; one for our MonoBehaviour and one for our NetworkObject.  The one that we want to focus on in this example is the generated NetworkObject. So let's say that we opened up the Network Contract Wizard (NCW) and we created a contract named  Car  ; this will generate a NetworkObject class named  CarNetworkObject . Now in another folder (not in the Generated folder) you will create a new C# script called  CarNetworkObject . In here you will create your  partial class  for the  CarNetworkObje ct  and you will override the  AllowOwnershipChange  method like so:", 
            "title": "Changing Ownership"
        }, 
        {
            "location": "/NetworkObject/changing-ownership/#allowownershipchange", 
            "text": "protected override bool AllowOwnershipChange(NetworkingPlayer newOwner)\n{\n    // The newOwner is the NetworkingPlayer that is requesting the ownership change, you can get the current owner with just  Owner \n}  Notice that you need to return a boolean from this function. If you return  true  then the ownership change will be allowed to go through, it will be invoked on the server and on the clients. If you return  false  then the ownership change will not be invoked at all and will be dropped.", 
            "title": "AllowOwnershipChange"
        }, 
        {
            "location": "/NetworkObject/destroying-the-network-object/", 
            "text": "Destroying the Network Object\n\n\nOne of the most common actions that you may want to do on the network is to destroy the various network objects that you create. Any object that has a \nnetworkObject\n or that derives from one of the generated classes made by the Network Contract Wizard (NCW) can be destroyed on the network. If you have a reference to the object you wish to destroy then it is just a matter of calling one function:\n\n\nnetworkObject.Destroy();\n\n\n\n\nThis will not only destroy the Network Object, but it will also call the UnityEngine.GameObject::Destroy method on the gameObject that the networkObject is attached to. If you wish to know when an object is destroyed you can register to the NetworkObject::onDestroy event.\n\n\nnetworkObject.onDestroy += MyMethod;", 
            "title": "Destroying the network object"
        }, 
        {
            "location": "/NetworkObject/destroying-the-network-object/#destroying-the-network-object", 
            "text": "One of the most common actions that you may want to do on the network is to destroy the various network objects that you create. Any object that has a  networkObject  or that derives from one of the generated classes made by the Network Contract Wizard (NCW) can be destroyed on the network. If you have a reference to the object you wish to destroy then it is just a matter of calling one function:  networkObject.Destroy();  This will not only destroy the Network Object, but it will also call the UnityEngine.GameObject::Destroy method on the gameObject that the networkObject is attached to. If you wish to know when an object is destroyed you can register to the NetworkObject::onDestroy event.  networkObject.onDestroy += MyMethod;", 
            "title": "Destroying the Network Object"
        }, 
        {
            "location": "/NetworkObject/fields/", 
            "text": "Fields\n\n\nThe Network Object (most commonly seen as Network Object) is a variable found in the classes that were generated from using the Network Contract Wizard (NCW). When you create a field in the Network Contract Wizard (NCW) for a generated type, then it will be added as a property of that generated type. Below are the currently supported types of fields allowed in a network object field.\n\n\n\n\n\n\n\n\nField\n\n\nSize\n\n\n\n\n\n\n\n\n\n\nbyte\n\n\n8 bits\n\n\n\n\n\n\nsbyte\n\n\n8 bits\n\n\n\n\n\n\nshort\n\n\n16 bits\n\n\n\n\n\n\nushort\n\n\n16 bits\n\n\n\n\n\n\nint\n\n\n32 bits\n\n\n\n\n\n\nuint\n\n\n32 bits\n\n\n\n\n\n\nlong\n\n\n64 bits\n\n\n\n\n\n\nulong\n\n\n64 bits\n\n\n\n\n\n\nfloat\n\n\n32 bits\n\n\n\n\n\n\ndouble\n\n\n64 bits\n\n\n\n\n\n\nchar\n\n\n8 bits\n\n\n\n\n\n\nstring\n\n\n32 bits + length * 8\n\n\n\n\n\n\nVector\n\n\n96 bits\n\n\n\n\n\n\nVector2\n\n\n64 bits\n\n\n\n\n\n\nVector3\n\n\n96 bits\n\n\n\n\n\n\nVector4\n\n\n128 bits\n\n\n\n\n\n\nQuaternion\n\n\n128 bits\n\n\n\n\n\n\nColor\n\n\n128 bits\n\n\n\n\n\n\n\n\nField Usage\n\n\nWhen you generate a class it will be generated with a \nnetworkObject\n variable. This variable has all of the fields that you described in the Network Contract Wizard (NCW) built into it. For example, if you created a field in the Network Contract Wizard (NCW) that was named position and was selected to be a VECTOR3 then you will have access to it by doing \nnetworkObject.position\n. One thing that you will notice when doing this is that this field is actually a C# property, but we will explain this momentarily.\n\n\nOn some fields (such as VECTOR3) you will notice that it has a greyed out button labeled interpolate. If you were to click this, it will turn on interpolation for this field. You can set the interpolation time by assigning the text input field to the right of the button once it is active, default is 0.15. If you are not familiar with interpolation, basically when we send messages across the network we are dealing with millisecond gaps of information, this will cause objects to seem as though they were teleporting or lagging. By using interpolation, you can smooth out these movements to look more natural.\n\n\nBehind the Scenes\n\n\nWhat is going on behind the scenes? Well let's start with where we left off in the last section on how the fields are actually properties. These properties have a getter/setter on each one. The getter will simply return a private field in the generated network object class; however, the setter does a few more actions. When you assign the value of the property, the setter will first set the private field to the value specified. Next a dirty flag will be set to tell the network to syndicate the change for that variable on the next network update for this object. What this dirty flag allows is for FNR to be able to only pick fields that have changed and send those across the network. This reduces the amount of data being sent by a lot depending on how often other variables are updated.", 
            "title": "Fields"
        }, 
        {
            "location": "/NetworkObject/fields/#fields", 
            "text": "The Network Object (most commonly seen as Network Object) is a variable found in the classes that were generated from using the Network Contract Wizard (NCW). When you create a field in the Network Contract Wizard (NCW) for a generated type, then it will be added as a property of that generated type. Below are the currently supported types of fields allowed in a network object field.     Field  Size      byte  8 bits    sbyte  8 bits    short  16 bits    ushort  16 bits    int  32 bits    uint  32 bits    long  64 bits    ulong  64 bits    float  32 bits    double  64 bits    char  8 bits    string  32 bits + length * 8    Vector  96 bits    Vector2  64 bits    Vector3  96 bits    Vector4  128 bits    Quaternion  128 bits    Color  128 bits", 
            "title": "Fields"
        }, 
        {
            "location": "/NetworkObject/fields/#field-usage", 
            "text": "When you generate a class it will be generated with a  networkObject  variable. This variable has all of the fields that you described in the Network Contract Wizard (NCW) built into it. For example, if you created a field in the Network Contract Wizard (NCW) that was named position and was selected to be a VECTOR3 then you will have access to it by doing  networkObject.position . One thing that you will notice when doing this is that this field is actually a C# property, but we will explain this momentarily.  On some fields (such as VECTOR3) you will notice that it has a greyed out button labeled interpolate. If you were to click this, it will turn on interpolation for this field. You can set the interpolation time by assigning the text input field to the right of the button once it is active, default is 0.15. If you are not familiar with interpolation, basically when we send messages across the network we are dealing with millisecond gaps of information, this will cause objects to seem as though they were teleporting or lagging. By using interpolation, you can smooth out these movements to look more natural.", 
            "title": "Field Usage"
        }, 
        {
            "location": "/NetworkObject/fields/#behind-the-scenes", 
            "text": "What is going on behind the scenes? Well let's start with where we left off in the last section on how the fields are actually properties. These properties have a getter/setter on each one. The getter will simply return a private field in the generated network object class; however, the setter does a few more actions. When you assign the value of the property, the setter will first set the private field to the value specified. Next a dirty flag will be set to tell the network to syndicate the change for that variable on the next network update for this object. What this dirty flag allows is for FNR to be able to only pick fields that have changed and send those across the network. This reduces the amount of data being sent by a lot depending on how often other variables are updated.", 
            "title": "Behind the Scenes"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/remote-procedure-calls/", 
            "text": "Remote Procedure Calls\n\n\nRemote procedure calls (RPC) is a way to call functions over the network. So lets imagine that you (\nClientA\n) had a method named \n\"Explode\"\n and I (\nClientB\n) wanted to call that \n\"Explode\"\n method on your machine so that we both see the fireworks at the same time. Your main quesion might be:\n\n\n\n\n\"Well how can I call that function so that we both can see the fireworks explode at the same time?\"\n\n\n\n\nThe answer of course is by doing a Remote Procedure call. A RPC can be called on a specific client, all clients, buffered clients, etc. \nRPCs use a reliable protocol - They always come in the right order and reception of RPCs is confirmed.\nTo get you quickly started, check out the \nBasic RPC Example\n. Once you have gone through that example and consumed all of its educational value, feel free to brows the below links for more information.\n\n\n\n\nBuffered RPCs\n\n\nSending RPC To Single Player\n\n\nRpcArgs and RpcInfo Structs\n\n\nRPC Validation by Server\n\n\nReplacing Previous Buffered RPCs\n\n\nClearing Buffered RPCs", 
            "title": "Remote procedure calls"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/remote-procedure-calls/#remote-procedure-calls", 
            "text": "Remote procedure calls (RPC) is a way to call functions over the network. So lets imagine that you ( ClientA ) had a method named  \"Explode\"  and I ( ClientB ) wanted to call that  \"Explode\"  method on your machine so that we both see the fireworks at the same time. Your main quesion might be:   \"Well how can I call that function so that we both can see the fireworks explode at the same time?\"   The answer of course is by doing a Remote Procedure call. A RPC can be called on a specific client, all clients, buffered clients, etc. \nRPCs use a reliable protocol - They always come in the right order and reception of RPCs is confirmed.\nTo get you quickly started, check out the  Basic RPC Example . Once you have gone through that example and consumed all of its educational value, feel free to brows the below links for more information.   Buffered RPCs  Sending RPC To Single Player  RpcArgs and RpcInfo Structs  RPC Validation by Server  Replacing Previous Buffered RPCs  Clearing Buffered RPCs", 
            "title": "Remote Procedure Calls"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/buffered-rpcs/", 
            "text": "Buffered RPCs\n\n\nSo you've probably gone through the \nBasic RPC Example\n by now and are curious about the various \nReceivers\n are that you could add when calling an RPC. If you browsed through the available \nReceivers\n you would have noticed ones suffixed with the word \nBuffered\n. For example \nAllBuffered\n or \nOthersBuffered\n. Buffering of RPC calls is important for players who are going to be joining the game late. For example let us say that you blew up a barrel at some point in the game. Now imagine someone coming into the game for the first time well after you blew up the barrel. How is that player going to know that the barrel is blown up so that they can't blow it up again? One solution you may try is using \nBuffered RPCs\n woo!\n\n\nWhat happens with buffered RPCs is that the RPC is stored on the server. The moment that a player has been accepted they will first receive all of the currently active network objects. Once the player has confirmed that they have received the network objects then the server will send down the buffered RPCs. Effectively calling the explode barrel RPC that was called a long time ago. Now of course this is a bad example of something to do gameplay-wise because then the player who just joined would have a bunch of barrels exploding out of nowhere, but you should be able to understand the purpose of buffered RPCs now.\n\n\nSo to buffer an RPC all you have to do is select a \nReceivers\n which has a \nBuffered\n prefix as seen below:\n\n\nfloat explosionVelocity = 99.98f;\nnetworkObject.SendRpc(RPC_BLOWUP_BARREL, Receivers.AllBuffered, explosionVelocity);", 
            "title": "Buffered rpcs"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/buffered-rpcs/#buffered-rpcs", 
            "text": "So you've probably gone through the  Basic RPC Example  by now and are curious about the various  Receivers  are that you could add when calling an RPC. If you browsed through the available  Receivers  you would have noticed ones suffixed with the word  Buffered . For example  AllBuffered  or  OthersBuffered . Buffering of RPC calls is important for players who are going to be joining the game late. For example let us say that you blew up a barrel at some point in the game. Now imagine someone coming into the game for the first time well after you blew up the barrel. How is that player going to know that the barrel is blown up so that they can't blow it up again? One solution you may try is using  Buffered RPCs  woo!  What happens with buffered RPCs is that the RPC is stored on the server. The moment that a player has been accepted they will first receive all of the currently active network objects. Once the player has confirmed that they have received the network objects then the server will send down the buffered RPCs. Effectively calling the explode barrel RPC that was called a long time ago. Now of course this is a bad example of something to do gameplay-wise because then the player who just joined would have a bunch of barrels exploding out of nowhere, but you should be able to understand the purpose of buffered RPCs now.  So to buffer an RPC all you have to do is select a  Receivers  which has a  Buffered  prefix as seen below:  float explosionVelocity = 99.98f;\nnetworkObject.SendRpc(RPC_BLOWUP_BARREL, Receivers.AllBuffered, explosionVelocity);", 
            "title": "Buffered RPCs"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/", 
            "text": "Sending RPC to a Single Player\n\n\nDuring your development process you may find that you have to send an RPC to a single player and nobody else. This is especially useful to target players that are just connecting to the server to send them needed data that is not buffered already.\n\n\nGeneral Example\n\n\n// targetPlayer is a NetworkingPlayer refence we got from the NetWorker::Players list or anywhere else\n// args is an object array\n\nnetworkObject.SendRpc(targetPlayer, RPC_RPC_NAME, args);\n\n\n\n\nPlayer Accept (join) Example\n\n\n// Somewhere in your code\n\nif (networker.IsServer)\n    networker.playerAccepted += PlayerAcceptedSetup;\n\n// ...\n\nprivate void PlayerAcceptedSetup(NetworkingPlayer newPlayer, Networker sender)\n{\n    networkObject.SendRpc(newPlayer, RPC_RPC_NAME, args);\n}\n\n\n\n\nNotes\n\n\nThis player targeting with RPCs are done on the server. Clients do not have direct access to each other since all network traffic goes through the server (which makes it \nauthoritative\n). You can use Receivers.Owner to target the owning player of the network object from any client though.", 
            "title": "Sending rpc to a single player"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/#sending-rpc-to-a-single-player", 
            "text": "During your development process you may find that you have to send an RPC to a single player and nobody else. This is especially useful to target players that are just connecting to the server to send them needed data that is not buffered already.", 
            "title": "Sending RPC to a Single Player"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/#general-example", 
            "text": "// targetPlayer is a NetworkingPlayer refence we got from the NetWorker::Players list or anywhere else\n// args is an object array\n\nnetworkObject.SendRpc(targetPlayer, RPC_RPC_NAME, args);", 
            "title": "General Example"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/#player-accept-join-example", 
            "text": "// Somewhere in your code\n\nif (networker.IsServer)\n    networker.playerAccepted += PlayerAcceptedSetup;\n\n// ...\n\nprivate void PlayerAcceptedSetup(NetworkingPlayer newPlayer, Networker sender)\n{\n    networkObject.SendRpc(newPlayer, RPC_RPC_NAME, args);\n}", 
            "title": "Player Accept (join) Example"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/#notes", 
            "text": "This player targeting with RPCs are done on the server. Clients do not have direct access to each other since all network traffic goes through the server (which makes it  authoritative ). You can use Receivers.Owner to target the owning player of the network object from any client though.", 
            "title": "Notes"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/", 
            "text": "RpcArgs and RpcInfo Structs\n\n\nWhen you setup a Remote Procedure Call you will notice that the argument supplied to this is called \nRpcArgs\n. This is a struct that helps ease the pain of getting objects from the network byte array. This \nRpcArgs\n has a \nInfo\n member variable which is a \nRpcInfo\n struct. This one argument to your RPC helps you get not only the data you sent on the network, but some other useful network meta-data as well.\n\n\nGetting Data From RpcArgs\n\n\nThe RpcArgs is a wrapper around the network data with one important method that you actually care about. This method is the \nRpcArgs::GetNext\n method. This is an overloaded method with 2 overloads, the first being the parameter-less easy-use method and the other being the more advanced object selection by index method. If you look at the signature for the overload with the \nint index\n parameter, you may be thinking \"what is index for?\". This index is the index of the object you wish to pull from the network byte array. So lets say that you called a RPC with 3 arguments (a int, a string, and a float). If you wanted to get the float you could use \nGetNext\nfloat\n(2)\n where \n2\n is the index of arguments. the int being \n0\n, the string being \n1\n, and the float being \n2\n. The power of the parameter-less \nGetNext\nT\n()\n method is that it auto moves to the next argument. So if you wanted to read the int, string and float from the preceeding example you would do the following:\n\n\nint num = args.GetNext\nint\n();\nstring name = args.GetNext\nstring\n();\nfloat val = args.GetNext\nfloat\n();\n\n\n\n\nWarning!!\n\n\nYou must pull out the arguments \nIN ORDER\n, if you do not, you will run into an error. So the following \nWILL NOT\n work for the same example because of the order of the network data:\n\n\nfloat val = args.GetNext\nfloat\n();\nstring name = args.GetNext\nstring\n();\nint num = args.GetNext\nint\n();\n\n\n\n\nUsing the Info\n\n\nCurrently, at the time of this writing, the \nInfo\n member variable in the \nRpcArgs\n has 2 properties. A \nNetworkingPlayer\n named \nSendingPlayer\n and a \nulong\n named \nTimeStep\n. The \nNetworkingPlayer\n is the sender of this RPC. \nNOTE\n This is only useful on the server, clients will always see the server as the sending player since all network traffic first goes though the server. The \nulong\n is used to know what timestamp that this message was sent at from the sender (this is time in milliseconds since the server started).\n\n\nSendingPlayer.Networker.IsServer and SendingPlayer.IsHost\n\n\nYou may notice in client execution that the value of \nSendingPlayer.Networker.IsServer\n is \nFalse\n but the value of \nSendingPlayer.IsHost\n is \nTrue\n and this has caused some confusion for the community. The way that you should think of \nSendingPlayer.Networker\n is that it is the NetWorker that is \nused TO\n communicate \nwith\n the server, it is not the server's NetWorker. So if it is the NetWorker used to talk to the server, then it is this client's NetWorker, which makes the \nIsServer\n getter \nFalse\n. This is actually why we created the \nIsHost\n boolean to help aid this confusion and it is less code to get to.", 
            "title": "Rpcargs and rpcinfo structs"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#rpcargs-and-rpcinfo-structs", 
            "text": "When you setup a Remote Procedure Call you will notice that the argument supplied to this is called  RpcArgs . This is a struct that helps ease the pain of getting objects from the network byte array. This  RpcArgs  has a  Info  member variable which is a  RpcInfo  struct. This one argument to your RPC helps you get not only the data you sent on the network, but some other useful network meta-data as well.", 
            "title": "RpcArgs and RpcInfo Structs"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#getting-data-from-rpcargs", 
            "text": "The RpcArgs is a wrapper around the network data with one important method that you actually care about. This method is the  RpcArgs::GetNext  method. This is an overloaded method with 2 overloads, the first being the parameter-less easy-use method and the other being the more advanced object selection by index method. If you look at the signature for the overload with the  int index  parameter, you may be thinking \"what is index for?\". This index is the index of the object you wish to pull from the network byte array. So lets say that you called a RPC with 3 arguments (a int, a string, and a float). If you wanted to get the float you could use  GetNext float (2)  where  2  is the index of arguments. the int being  0 , the string being  1 , and the float being  2 . The power of the parameter-less  GetNext T ()  method is that it auto moves to the next argument. So if you wanted to read the int, string and float from the preceeding example you would do the following:  int num = args.GetNext int ();\nstring name = args.GetNext string ();\nfloat val = args.GetNext float ();", 
            "title": "Getting Data From RpcArgs"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#warning", 
            "text": "You must pull out the arguments  IN ORDER , if you do not, you will run into an error. So the following  WILL NOT  work for the same example because of the order of the network data:  float val = args.GetNext float ();\nstring name = args.GetNext string ();\nint num = args.GetNext int ();", 
            "title": "Warning!!"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#using-the-info", 
            "text": "Currently, at the time of this writing, the  Info  member variable in the  RpcArgs  has 2 properties. A  NetworkingPlayer  named  SendingPlayer  and a  ulong  named  TimeStep . The  NetworkingPlayer  is the sender of this RPC.  NOTE  This is only useful on the server, clients will always see the server as the sending player since all network traffic first goes though the server. The  ulong  is used to know what timestamp that this message was sent at from the sender (this is time in milliseconds since the server started).", 
            "title": "Using the Info"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#sendingplayernetworkerisserver-and-sendingplayerishost", 
            "text": "You may notice in client execution that the value of  SendingPlayer.Networker.IsServer  is  False  but the value of  SendingPlayer.IsHost  is  True  and this has caused some confusion for the community. The way that you should think of  SendingPlayer.Networker  is that it is the NetWorker that is  used TO  communicate  with  the server, it is not the server's NetWorker. So if it is the NetWorker used to talk to the server, then it is this client's NetWorker, which makes the  IsServer  getter  False . This is actually why we created the  IsHost  boolean to help aid this confusion and it is less code to get to.", 
            "title": "SendingPlayer.Networker.IsServer and SendingPlayer.IsHost"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/rpc-validation-by-server/", 
            "text": "RPC Validation by Server\n\n\nWe live in a world where we just can't trust our clients to send us messages that they should be in the way that we wish them to. Clients may want to cheat the system and try to exploit the network for fun or just so that they can win. Because of this we have created a simple method for you to override in order to check any game critical RPCs that are received from the client and verify them. Before continuing with this part of the documentation, please review the Extending Generated Classes documentation to learn more about \npartial\n classes.\n\n\nWhen we use the Network Contract Wizard (NCW), it will create 2 generated classes; one for our MonoBehaviour and one for our NetworkObject.\n\n\nThe one that we want to focus on in this example is the generated NetworkObject. So let's say that we opened up the Network Contract Wizard (NCW) and we created a contract named \nBall\n ; this will generate a NetworkObject class named \nBallNetworkObject\n. Now in another folder (not in the Generated folder) you will create a new C# script called \nBallNetworkObject\n. In here you will create your \npartial class\n for the \nBallNetworkObj ect\n and you will override the \nServerAllowRpc\n method like so:\n\n\nServerAllowRpc\n\n\nnamespace BeardedManStudios.Forge.Networking.Generated\n{\n    public partial class BallNetworkObject : NetworkObject\n    {\n        protected override bool ServerAllowRpc(byte methodId, Receivers receivers, RpcArgs args)\n        {\n            // The methodName is the name of the RPC that is trying to be called right now\n            // The receivers is who the client is trying to send the RPC to\n            // The args are the arguments that were sent as part of the RPC message and what the receivers will receive as arguments to the call\n        }\n    }\n}\n\n\n\n\nNotice that you need to return a boolean from this function. If you return \ntrue\n then the RPC will be allowed to go through, it will be invoked on the server and on the clients (if specified in Receivers). If you return \nfalse\n then the RPC will not be invoked at all and will be dropped.", 
            "title": "Rpc validation by server"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/rpc-validation-by-server/#rpc-validation-by-server", 
            "text": "We live in a world where we just can't trust our clients to send us messages that they should be in the way that we wish them to. Clients may want to cheat the system and try to exploit the network for fun or just so that they can win. Because of this we have created a simple method for you to override in order to check any game critical RPCs that are received from the client and verify them. Before continuing with this part of the documentation, please review the Extending Generated Classes documentation to learn more about  partial  classes.  When we use the Network Contract Wizard (NCW), it will create 2 generated classes; one for our MonoBehaviour and one for our NetworkObject.  The one that we want to focus on in this example is the generated NetworkObject. So let's say that we opened up the Network Contract Wizard (NCW) and we created a contract named  Ball  ; this will generate a NetworkObject class named  BallNetworkObject . Now in another folder (not in the Generated folder) you will create a new C# script called  BallNetworkObject . In here you will create your  partial class  for the  BallNetworkObj ect  and you will override the  ServerAllowRpc  method like so:", 
            "title": "RPC Validation by Server"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/rpc-validation-by-server/#serverallowrpc", 
            "text": "namespace BeardedManStudios.Forge.Networking.Generated\n{\n    public partial class BallNetworkObject : NetworkObject\n    {\n        protected override bool ServerAllowRpc(byte methodId, Receivers receivers, RpcArgs args)\n        {\n            // The methodName is the name of the RPC that is trying to be called right now\n            // The receivers is who the client is trying to send the RPC to\n            // The args are the arguments that were sent as part of the RPC message and what the receivers will receive as arguments to the call\n        }\n    }\n}  Notice that you need to return a boolean from this function. If you return  true  then the RPC will be allowed to go through, it will be invoked on the server and on the clients (if specified in Receivers). If you return  false  then the RPC will not be invoked at all and will be dropped.", 
            "title": "ServerAllowRpc"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/replacing-previous-buffered-rpcs/", 
            "text": "Replacing Previous Buffered RPCs\n\n\nThere are times where the buffered data that you want to send to new players that connect needs to be updated. Let's say that you were sending the current color of the winning team to a connecting player. Though you could run this on \nplayerAccepted\n you might choose to do this with a buffered RPC. Unfortunately the currently winning team may change and so the color would need to be buffered yet again. If you were to keep buffering the team color you may end up with a buffer of 50 RPCs, so all 50 would get sent in order to the connecting player. Instead you can choose to replace the last call to a buffered RPC which will remove the last RPC called on \nthis specific\n game object with the given RPC string name with the one you are currently executing. This is done easily by passing \ntrue\n to the \nSendRpc\n method overload that has the \nreplacePrevious\n argument:\n\n\nbool replacePrevious = true;\nnetworkObject.SendRpc(RPC_MY_RPC_NAME, replacePrevious, Receivers.AllBuffered, new object[] { \nargs go here\n });", 
            "title": "Replacing previous buffered rpcs"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/replacing-previous-buffered-rpcs/#replacing-previous-buffered-rpcs", 
            "text": "There are times where the buffered data that you want to send to new players that connect needs to be updated. Let's say that you were sending the current color of the winning team to a connecting player. Though you could run this on  playerAccepted  you might choose to do this with a buffered RPC. Unfortunately the currently winning team may change and so the color would need to be buffered yet again. If you were to keep buffering the team color you may end up with a buffer of 50 RPCs, so all 50 would get sent in order to the connecting player. Instead you can choose to replace the last call to a buffered RPC which will remove the last RPC called on  this specific  game object with the given RPC string name with the one you are currently executing. This is done easily by passing  true  to the  SendRpc  method overload that has the  replacePrevious  argument:  bool replacePrevious = true;\nnetworkObject.SendRpc(RPC_MY_RPC_NAME, replacePrevious, Receivers.AllBuffered, new object[] {  args go here  });", 
            "title": "Replacing Previous Buffered RPCs"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/clearing-buffered-rpcs/", 
            "text": "Clearing Buffered RPCs\n\n\nWhen buffering RPC calls you may have noticed that the buffered call exists for the entire life-span of the network object. This is so that critical functions can be performed on an object to clients who connect later (after the RPC was executed). The problem you may run into with this is that you would need to delete the object to reset the level or partly reset the level. This of course presents the problem of managing and instantiating objects remotely. To resolve this issue, you can clear out the buffered RPCs of an object using the \nNetworkObject::ClearRpcBuffer.\n This will request for the buffered RPCs of a specific object to be cleared on the server if called from the client, otherwise it will immediately clear the buffered RPCs for the network object in question if called from the server.", 
            "title": "Clearing buffered rpcs"
        }, 
        {
            "location": "/NetworkObject/RemoteProcedureCalls/clearing-buffered-rpcs/#clearing-buffered-rpcs", 
            "text": "When buffering RPC calls you may have noticed that the buffered call exists for the entire life-span of the network object. This is so that critical functions can be performed on an object to clients who connect later (after the RPC was executed). The problem you may run into with this is that you would need to delete the object to reset the level or partly reset the level. This of course presents the problem of managing and instantiating objects remotely. To resolve this issue, you can clear out the buffered RPCs of an object using the  NetworkObject::ClearRpcBuffer.  This will request for the buffered RPCs of a specific object to be cleared on the server if called from the client, otherwise it will immediately clear the buffered RPCs for the network object in question if called from the server.", 
            "title": "Clearing Buffered RPCs"
        }, 
        {
            "location": "/UnityIntegration/gameobject-execution-order/", 
            "text": "GameObject Execution Order\n\n\nYou may be use to the standard method execution order in Unity and this can cause some confusion when it comes to when you are able to access the network object on a client. You see, when you create a network object \non the client\n it takes some time to get to the server, validate, and return back to the client. Because of this, the \nnetworkObject\n you are use to using may be null during the \nStart\n and \nAwake\n methods of your MonoBehaviour.\n\n\nNetworkStart\n\n\nTo resolve the issue with starting things once the networkObject has been setup, we have created a \nprotected\n method you can \noverride\n that will be called once the networkObject has been setup. You should do any initialization logic that is required for the network object in this method \ndon't forget to call the \nbase.NetworkStart()\n method\n.\n\n\nprotected override void NetworkStart()\n{\n    base.NetworkStart();\n    // TODO:  Your initialization code that relies on network setup for this object goes here\n}\n\n\n\n\nUpdate and FixedUpdate\n\n\nIf the network is a little slow, it is very possible that the \nnetworkObject\n is not setup by the time the first call to the \nUpdate\n or \nFixedUpdate\n happens in Unity. So make sure to do your \nnull\n checks or set some-kind of flag for when the object is ready to be used.\n\n\nprivate void Update()\n{\n    if (networkObject != null)\n    {\n        // TODO:  Whatever you need to do with the networkObject\n    }\n}", 
            "title": "Gameobject execution order"
        }, 
        {
            "location": "/UnityIntegration/gameobject-execution-order/#gameobject-execution-order", 
            "text": "You may be use to the standard method execution order in Unity and this can cause some confusion when it comes to when you are able to access the network object on a client. You see, when you create a network object  on the client  it takes some time to get to the server, validate, and return back to the client. Because of this, the  networkObject  you are use to using may be null during the  Start  and  Awake  methods of your MonoBehaviour.", 
            "title": "GameObject Execution Order"
        }, 
        {
            "location": "/UnityIntegration/gameobject-execution-order/#networkstart", 
            "text": "To resolve the issue with starting things once the networkObject has been setup, we have created a  protected  method you can  override  that will be called once the networkObject has been setup. You should do any initialization logic that is required for the network object in this method  don't forget to call the  base.NetworkStart()  method .  protected override void NetworkStart()\n{\n    base.NetworkStart();\n    // TODO:  Your initialization code that relies on network setup for this object goes here\n}", 
            "title": "NetworkStart"
        }, 
        {
            "location": "/UnityIntegration/gameobject-execution-order/#update-and-fixedupdate", 
            "text": "If the network is a little slow, it is very possible that the  networkObject  is not setup by the time the first call to the  Update  or  FixedUpdate  happens in Unity. So make sure to do your  null  checks or set some-kind of flag for when the object is ready to be used.  private void Update()\n{\n    if (networkObject != null)\n    {\n        // TODO:  Whatever you need to do with the networkObject\n    }\n}", 
            "title": "Update and FixedUpdate"
        }, 
        {
            "location": "/UnityIntegration/network-instantiation/", 
            "text": "Network Instantiation\n\n\nNetwork instantiation is how you are able to create objects on the network so that all other clients are able to see that object. Then you can update this object or send \nRemote Procedure Calls\n to the object to perform behaviors across the network or manage local behaviors.\n\n\nWhen you use the \nNetwork Contract Wizard\n you are able to generate what is known as a \"Network Object\". These objects can then be extended to have custom behavior and to implement network behaviors defined in the Network Contract Wizard (NCW). When you click the \"Save \n Compile\" option in the NCW an instantiate method will be created for the object you just defined in the NCW. So if you created a Network Object in the NCW named \nSuperBall\n then you could call the following code in Unity to create an instance of that \nSuperBall\n:\n\n\nNetworkManager.Instance.InstantiateSuperBall();\n\n\n\n\nIf you look at the input parameters of this method you will find that there are a few optional parameters:\n\n\n1. int index = 0\n2. Vector3? position = null\n3. Quaternion? rotation = null\n4. bool sendTransform = true\n\n\n\n\n\n\nThe index tells the network which prefab to instantiate (from the array set in the Network Manager prefab).\n\n\nThis is the position you wish to spawn the prefab at on the network. If left null then the object will spawn at the coordinates set in the prefab.\n\n\nThis is the rotation you wish to spawn the prefab at on the network. If left null then the object will spawn at the rotation set in the prefab.\n\n\nThis is used to know if the transform that is being assigned should be sent across the network. So if you filled out #2 and #3 then those values will be sent across the network and not just used locally. If you pass \nfalse\n then the prefab will spawn on the caller at the specified location, but it will be spawned at the prefab location on the other clients.\n\n\n\n\nYou may recall from the above #1 that you can set various prefabs to spawn for a given network object. That is to say that my \nSuperBall\n could have more than one prefab it spawns on, even a cube (I know crazy right?). To work with this you will need to locate the \nNetwork Manager\n prefab in the \nBearded Man Studios Inc/Prefabs\n folder. Once you select this prefab, you will notice that there is a \nNetworkPrefab\n component attached to it with a \nSuper Ball Network Object\n array that is empty. This is where you will drag and drop the various prefabs you wish to use as this type of network object. So we can drag a sphere and even a cube into this array.\n\n\nLet's say that we first put a sphere into the array and then we put a cube into the array. You will notice that the sphere has an index of \n0\n and the cube will have an index of \n1\n. This is the value that you will supply to the instantiate method when you call it. If you were to pass \n0\n, you would get a sphere and if you were to pass a \n1\n you would get a cube.\n\n\nGetting the GameObject From Instantiate\n\n\nWhat you may notice is that when you instantiate the \nSuperBall\n it will return a \nNetworkBehavior\n which will be your \nSuperBallBehavior\n that was generated. This object actually derives from the \nMonoBehaviour\n so you can directly access the gameObject, transform, and any standard \nMonoBehaviour\n field, property, and method as you would do normally.\n\n\nvar ball = NetworkManager.Instance.InstantiateSuperBall();\n\n// Access any standard MonoBehaviour elements as seen below from the ball reference\nDebug.Log(ball.gameObject.name);\nDebug.Log(ball.transform.position);\n\n\n\n\n\n\nNotes\n\n\nSo you may be thinking, well gee, a numbered index might be a little bit hard to keep track of, and if you do, then you are probably correct. Like all things software there are many ways that you can setup your project, but here are just 2 ideas that you can use to have a little better time managing the various prefabs you may use.\n\n\nMethod 1\n\n\nYou can create a class that is dedicated to mapping objects to strings or integers. Then you can access the \nNetworkManager.Instance\n and assign the array directly with \nNetworkManager.Instance.SuperBallNetworkObject = myArray;\n. By doing this you can create your own indexing and lookup logic for the prefabs that you can use to easily find the index for the prefab that should spawn on the network. After creating the mapping you just need to call your lookup method and have it do the rest of the work.\n\n\nMethod 2\n\n\nYou can create your own instantiate methods. You can wrap code around our code to spawn your objects. So imagine that you want to call the generated \nNetworkManager.Instance.InstantiateSuperBall\n method but you have some other stuff you always do before hand or that dynamically selects the proper index. In this case you can create a class that does all the helper logic before you call the instantiate method, then you would call the instantiate through this helper class.\n\n\nManual Attachment Method\n\n\nYou can create a NetworkObject without having to call this insantiate method which is directly linked to a prefab. This obviously isn't a topic for this section but you can find out more about this in the \nGetting Started\n examples about network insantiation.\n\n\nWarnings\n\n\nIf you are dynamically setting the array on the \nNetworkManager.Instance\n then you \nMUST\n make sure that the order being assigned is predictable on all clients. You can't exactly have the order of the array different on each client and expect it to still work properly can you?", 
            "title": "Network instantiation"
        }, 
        {
            "location": "/UnityIntegration/network-instantiation/#network-instantiation", 
            "text": "Network instantiation is how you are able to create objects on the network so that all other clients are able to see that object. Then you can update this object or send  Remote Procedure Calls  to the object to perform behaviors across the network or manage local behaviors.  When you use the  Network Contract Wizard  you are able to generate what is known as a \"Network Object\". These objects can then be extended to have custom behavior and to implement network behaviors defined in the Network Contract Wizard (NCW). When you click the \"Save   Compile\" option in the NCW an instantiate method will be created for the object you just defined in the NCW. So if you created a Network Object in the NCW named  SuperBall  then you could call the following code in Unity to create an instance of that  SuperBall :  NetworkManager.Instance.InstantiateSuperBall();  If you look at the input parameters of this method you will find that there are a few optional parameters:  1. int index = 0\n2. Vector3? position = null\n3. Quaternion? rotation = null\n4. bool sendTransform = true   The index tells the network which prefab to instantiate (from the array set in the Network Manager prefab).  This is the position you wish to spawn the prefab at on the network. If left null then the object will spawn at the coordinates set in the prefab.  This is the rotation you wish to spawn the prefab at on the network. If left null then the object will spawn at the rotation set in the prefab.  This is used to know if the transform that is being assigned should be sent across the network. So if you filled out #2 and #3 then those values will be sent across the network and not just used locally. If you pass  false  then the prefab will spawn on the caller at the specified location, but it will be spawned at the prefab location on the other clients.   You may recall from the above #1 that you can set various prefabs to spawn for a given network object. That is to say that my  SuperBall  could have more than one prefab it spawns on, even a cube (I know crazy right?). To work with this you will need to locate the  Network Manager  prefab in the  Bearded Man Studios Inc/Prefabs  folder. Once you select this prefab, you will notice that there is a  NetworkPrefab  component attached to it with a  Super Ball Network Object  array that is empty. This is where you will drag and drop the various prefabs you wish to use as this type of network object. So we can drag a sphere and even a cube into this array.  Let's say that we first put a sphere into the array and then we put a cube into the array. You will notice that the sphere has an index of  0  and the cube will have an index of  1 . This is the value that you will supply to the instantiate method when you call it. If you were to pass  0 , you would get a sphere and if you were to pass a  1  you would get a cube.", 
            "title": "Network Instantiation"
        }, 
        {
            "location": "/UnityIntegration/network-instantiation/#getting-the-gameobject-from-instantiate", 
            "text": "What you may notice is that when you instantiate the  SuperBall  it will return a  NetworkBehavior  which will be your  SuperBallBehavior  that was generated. This object actually derives from the  MonoBehaviour  so you can directly access the gameObject, transform, and any standard  MonoBehaviour  field, property, and method as you would do normally.  var ball = NetworkManager.Instance.InstantiateSuperBall();\n\n// Access any standard MonoBehaviour elements as seen below from the ball reference\nDebug.Log(ball.gameObject.name);\nDebug.Log(ball.transform.position);", 
            "title": "Getting the GameObject From Instantiate"
        }, 
        {
            "location": "/UnityIntegration/network-instantiation/#notes", 
            "text": "So you may be thinking, well gee, a numbered index might be a little bit hard to keep track of, and if you do, then you are probably correct. Like all things software there are many ways that you can setup your project, but here are just 2 ideas that you can use to have a little better time managing the various prefabs you may use.", 
            "title": "Notes"
        }, 
        {
            "location": "/UnityIntegration/network-instantiation/#method-1", 
            "text": "You can create a class that is dedicated to mapping objects to strings or integers. Then you can access the  NetworkManager.Instance  and assign the array directly with  NetworkManager.Instance.SuperBallNetworkObject = myArray; . By doing this you can create your own indexing and lookup logic for the prefabs that you can use to easily find the index for the prefab that should spawn on the network. After creating the mapping you just need to call your lookup method and have it do the rest of the work.", 
            "title": "Method 1"
        }, 
        {
            "location": "/UnityIntegration/network-instantiation/#method-2", 
            "text": "You can create your own instantiate methods. You can wrap code around our code to spawn your objects. So imagine that you want to call the generated  NetworkManager.Instance.InstantiateSuperBall  method but you have some other stuff you always do before hand or that dynamically selects the proper index. In this case you can create a class that does all the helper logic before you call the instantiate method, then you would call the instantiate through this helper class.", 
            "title": "Method 2"
        }, 
        {
            "location": "/UnityIntegration/network-instantiation/#manual-attachment-method", 
            "text": "You can create a NetworkObject without having to call this insantiate method which is directly linked to a prefab. This obviously isn't a topic for this section but you can find out more about this in the  Getting Started  examples about network insantiation.", 
            "title": "Manual Attachment Method"
        }, 
        {
            "location": "/UnityIntegration/network-instantiation/#warnings", 
            "text": "If you are dynamically setting the array on the  NetworkManager.Instance  then you  MUST  make sure that the order being assigned is predictable on all clients. You can't exactly have the order of the array different on each client and expect it to still work properly can you?", 
            "title": "Warnings"
        }, 
        {
            "location": "/UnityIntegration/threading-in-unity/", 
            "text": "Threading in Unity\n\n\nIf you have dealt with threading before and attempted to use it within Unity, then you probably know by now that you are not able to access the native Unity features from any thread other than the \nmain thread\n. This does raise a bit of a complication when it comes to a completely multithreaded system such as Forge Networking. We've decided that running only on the main thread restricts our users and ourselves from achieving the full potential in performance that we would like. For this reason, we allow the user to manage how code is offloaded to the main thread in their applications.\n\n\nWhat is threading?\n\n\nIf you are familiar with threading then you can skip this section.\n\n\nThis is not going to be a complicated explanation of what the processor is doing at a hardware level but a simple abstract explanation so that it is not such an unfamiliar topic. I'm sure by now we are all familiar with machines that say things like \ndual-core\n or \nquad-core\n or \nocta-core\n etc. Imagine if you will that the machine has 2 cpu chips when we say \ndual core\n if this were the case, you could also imagine that you can run 2 things at the same exact time. This works much like if you hired someone to fold papers, if you hired a second person to fold papers at the same time, then you could get twice the work done in the same amount of time at the same exact time. Now lets imagine that the papers were a variable such as an int, what if both employees finished folding a paper at the same exact time and they both reached for the next paper in the stack? Well only one person can alter one paper at a time, you could wind up with the paper being folded twice!\n\n\nNow that you have that basic understanding of a simple issue that comes up with parallel computing (threading) you can say, \"what if unity messes with the game object, but I do at the same time?\". Of course no good will come out of this, this is precisely why Unity does not allow you to manipulate Unity objects from an external thread. There are probably a large number of reasons that Unity has chosen not to simply allow you to lock a mutex, but I digress. For this reason, we have created a helper class named \nMainThreadManager\n which we will talk more in depth in a\n\n\nlater section.\n\n\nNOTE:  \n Many modern CPUs can have multiple threads per core, for example the i7-6700K has 2 threads per core making a 4 core processor with 8 threads.\n\n\nWhat runs on a separate thread in Forge?\n\n\nIn forge we have 2 critical threads for both the client and the server, and 1 extra critical thread for the server (in TCP mode). When in TCP mode the special thread that the server runs is the connection thread. This thread listens for new client connections and will begin the acceptance process from here. The other 2 threads that are shared on client and server, UDP and TCP, is the write and read threads. There is one long lived thread that is used for the reading of network messages. This reading thread will also execute RPC methods, read message events, and so forth. Almost everything that is processed on the network can be traced back to the read thread. The second thread, the write thread, is shared for all players. This thread is shared so that it can support thousands of connections/players at a time on lower end CPUs. This thread is an on-demand thread. It starts up when messages are being sent, and it shuts down when there are no more messages being sent. The client also uses the same write thread logic, however it is not as active as the server write thread for obvious reasons (it only communicates with the server and nobody else).\n\n\nCurrently the only network communication that you need to worry about as an end user that get's called on a separate thread is an RPC.", 
            "title": "Threading in unity"
        }, 
        {
            "location": "/UnityIntegration/threading-in-unity/#threading-in-unity", 
            "text": "If you have dealt with threading before and attempted to use it within Unity, then you probably know by now that you are not able to access the native Unity features from any thread other than the  main thread . This does raise a bit of a complication when it comes to a completely multithreaded system such as Forge Networking. We've decided that running only on the main thread restricts our users and ourselves from achieving the full potential in performance that we would like. For this reason, we allow the user to manage how code is offloaded to the main thread in their applications.  What is threading?  If you are familiar with threading then you can skip this section.  This is not going to be a complicated explanation of what the processor is doing at a hardware level but a simple abstract explanation so that it is not such an unfamiliar topic. I'm sure by now we are all familiar with machines that say things like  dual-core  or  quad-core  or  octa-core  etc. Imagine if you will that the machine has 2 cpu chips when we say  dual core  if this were the case, you could also imagine that you can run 2 things at the same exact time. This works much like if you hired someone to fold papers, if you hired a second person to fold papers at the same time, then you could get twice the work done in the same amount of time at the same exact time. Now lets imagine that the papers were a variable such as an int, what if both employees finished folding a paper at the same exact time and they both reached for the next paper in the stack? Well only one person can alter one paper at a time, you could wind up with the paper being folded twice!  Now that you have that basic understanding of a simple issue that comes up with parallel computing (threading) you can say, \"what if unity messes with the game object, but I do at the same time?\". Of course no good will come out of this, this is precisely why Unity does not allow you to manipulate Unity objects from an external thread. There are probably a large number of reasons that Unity has chosen not to simply allow you to lock a mutex, but I digress. For this reason, we have created a helper class named  MainThreadManager  which we will talk more in depth in a  later section.  NOTE:    Many modern CPUs can have multiple threads per core, for example the i7-6700K has 2 threads per core making a 4 core processor with 8 threads.  What runs on a separate thread in Forge?  In forge we have 2 critical threads for both the client and the server, and 1 extra critical thread for the server (in TCP mode). When in TCP mode the special thread that the server runs is the connection thread. This thread listens for new client connections and will begin the acceptance process from here. The other 2 threads that are shared on client and server, UDP and TCP, is the write and read threads. There is one long lived thread that is used for the reading of network messages. This reading thread will also execute RPC methods, read message events, and so forth. Almost everything that is processed on the network can be traced back to the read thread. The second thread, the write thread, is shared for all players. This thread is shared so that it can support thousands of connections/players at a time on lower end CPUs. This thread is an on-demand thread. It starts up when messages are being sent, and it shuts down when there are no more messages being sent. The client also uses the same write thread logic, however it is not as active as the server write thread for obvious reasons (it only communicates with the server and nobody else).  Currently the only network communication that you need to worry about as an end user that get's called on a separate thread is an RPC.", 
            "title": "Threading in Unity"
        }, 
        {
            "location": "/UnityIntegration/main-threading-rpcs/", 
            "text": "Main Threading RPCs\n\n\nThe RPC behaviors in Forge Networking work on the network reading thread for purposes of performance when it comes to reading network data. This means that accessing any Unity specific objects in this thread will cause an error (please see Threading in Unity). Many of our newer users will be unconformable working with function pointers, lambda expressions or threading so we have created an easy way for you to make all RPC calls perform on the main thread. At any point in your application you can assign the Rpc's \nMainThreadRunner\n object. By doing this you will essentially make all incoming RPC calls run on Unity's main thread. To do this you would do the following in your code.\n\n\nFor an example of this, please see the \nMultiplayerMenu.cs\n file and follow the \nuseMainThreadManagerForRPCs\n variable.\n\n\nIf you wish to manually say when to run an RPC on the main thread. You can always use the \nMainThreadManage.Run\n method to queue actions to perform on the main thread. To understand this further, please review Threading in Unity.", 
            "title": "Main threading rpcs"
        }, 
        {
            "location": "/UnityIntegration/main-threading-rpcs/#main-threading-rpcs", 
            "text": "The RPC behaviors in Forge Networking work on the network reading thread for purposes of performance when it comes to reading network data. This means that accessing any Unity specific objects in this thread will cause an error (please see Threading in Unity). Many of our newer users will be unconformable working with function pointers, lambda expressions or threading so we have created an easy way for you to make all RPC calls perform on the main thread. At any point in your application you can assign the Rpc's  MainThreadRunner  object. By doing this you will essentially make all incoming RPC calls run on Unity's main thread. To do this you would do the following in your code.  For an example of this, please see the  MultiplayerMenu.cs  file and follow the  useMainThreadManagerForRPCs  variable.  If you wish to manually say when to run an RPC on the main thread. You can always use the  MainThreadManage.Run  method to queue actions to perform on the main thread. To understand this further, please review Threading in Unity.", 
            "title": "Main Threading RPCs"
        }, 
        {
            "location": "/UnityIntegration/running-unity-specific-code-on-the-main-thread/", 
            "text": "Running Unity specific code on the main thread\n\n\nWe have created a helper class for you to be able to offload any logic to the main thread from a separate thread. This helper class is called \nMainT hreadManager\n and there are 2 main ways that you can use this class. The entry point for both methods of use is the static method \nRun\n ; see the code snippets below for practical uses. The examples below emulate a RPC method's contents.\n\n\nMainThreadManager.Run Function Pointer\n\n\npublic override void MyCustomRPC(object[] args)\n{\n    // Register the private function within this class to be called on the main thread\n    MainThreadManager.Run(OtherFunction);\n}\n\nprivate void OtherFunction()\n{\n    Debug.Log(\nHello World!\n);\n}\n\n\n\n\nYou can see that the above example requires another accessible method in order to pass it into the main thread manager's Run method.\n\n\nMainThreadManager.Run Lambda Expression\n\n\npublic override void MyCustomRPC(object[] args)\n{\n    // Setup a temporary method call (lambda expression) to be executed on the main thread\n    MainThreadManager.Run(() =\n { Debug.Log(\nHello World!\n); });\n}\n\n\n\n\nThe above is the preferred\n  \nmethod\n\n\nThe lambda expression is a native C# feature that allows you to essentially create an inline function at runtime. Please see \nthis website\n or the \noffi\n \ncial documentation\n for more information on lambda expressions.\n\n\nWhat does the Main Thread Manager do?\n\n\nThe Main Thread Manager is actually a pretty small and simple singleton class. When you send a method pointer or inline expression into the Run method it will be added to a queue. The Main Thread Manager is a Unity Game Object and will automatically create itself if one is not created already. Every \nFixedUpdate\n for this object, it will check to see if there are any pending methods in the queue, if so it will run them and remove them from the queue. By running these methods in the \nFixedUpdate\n they are automatically ran on the main thread.", 
            "title": "Running unity specific code on the main thread"
        }, 
        {
            "location": "/UnityIntegration/running-unity-specific-code-on-the-main-thread/#running-unity-specific-code-on-the-main-thread", 
            "text": "We have created a helper class for you to be able to offload any logic to the main thread from a separate thread. This helper class is called  MainT hreadManager  and there are 2 main ways that you can use this class. The entry point for both methods of use is the static method  Run  ; see the code snippets below for practical uses. The examples below emulate a RPC method's contents.", 
            "title": "Running Unity specific code on the main thread"
        }, 
        {
            "location": "/UnityIntegration/running-unity-specific-code-on-the-main-thread/#mainthreadmanagerrun-function-pointer", 
            "text": "public override void MyCustomRPC(object[] args)\n{\n    // Register the private function within this class to be called on the main thread\n    MainThreadManager.Run(OtherFunction);\n}\n\nprivate void OtherFunction()\n{\n    Debug.Log( Hello World! );\n}  You can see that the above example requires another accessible method in order to pass it into the main thread manager's Run method.", 
            "title": "MainThreadManager.Run Function Pointer"
        }, 
        {
            "location": "/UnityIntegration/running-unity-specific-code-on-the-main-thread/#mainthreadmanagerrun-lambda-expression", 
            "text": "public override void MyCustomRPC(object[] args)\n{\n    // Setup a temporary method call (lambda expression) to be executed on the main thread\n    MainThreadManager.Run(() =  { Debug.Log( Hello World! ); });\n}  The above is the preferred    method  The lambda expression is a native C# feature that allows you to essentially create an inline function at runtime. Please see  this website  or the  offi   cial documentation  for more information on lambda expressions.  What does the Main Thread Manager do?  The Main Thread Manager is actually a pretty small and simple singleton class. When you send a method pointer or inline expression into the Run method it will be added to a queue. The Main Thread Manager is a Unity Game Object and will automatically create itself if one is not created already. Every  FixedUpdate  for this object, it will check to see if there are any pending methods in the queue, if so it will run them and remove them from the queue. By running these methods in the  FixedUpdate  they are automatically ran on the main thread.", 
            "title": "MainThreadManager.Run Lambda Expression"
        }, 
        {
            "location": "/UnityIntegration/network-start/", 
            "text": "Unity Integration Network Start\n\n\nSince Unity does not work as fast as Forge Networking, there are a few control flow features that we've added into the Unity Integration to allow you to plan your network setup for network objects. When you implement your generated \nBehavior\n script that was generated from the \nNCW\n, you can override a function named \nNetworkStart\n. When the \nNetworkStart\n function is called, that means the object has been setup on the network and is ready to do things like send RPCs, update fields, etc. Below is an example of how to override the NetworkStart method in order to disable a camera on a game object that is not owned by the current instance and set our fields update interval.\n\n\nusing BeardedManStudios.Forge.Networking.Generated;\nusing UnityEngine;\n\npublic class NetCam : NetworkCameraBehavior\n{\n    protected override void NetworkStart()\n    {\n        base.NetworkStart();\n\n        cameraRef = GetComponent\nCamera\n();\n        networkObject.UpdateInterval = 100;\n\n        // If this is not our camera then we should not render using it\n        if (!networkObject.IsOwner)\n            cameraRef.enabled = false;\n    }\n}\n\n\n\n\nnetworkStarted Event\n\n\nFor your convenience, we've added a networkStarted event to \nNetworkBehavior\n so that you can do other operations on other objects that have a reference to the object in question. For example; if you instantitate the object (obviously from another script) and you want to do some special action on that object once it has been setup on the network, you can hook into this event.\n\n\nvar cameraPlayer = NetworkManager.Instance.InstantiateNetworkCamera();\ncameraPlayer.networkStarted += CameraReadyOnNetwork;\n\n// ...\n\nprivate void CameraReadyOnNetwork(NetworkBehavior playerCamera)\n{\n    UnityEngine.Debug.Log(\nThe player camera \n + playerCamera.name + \n has been setup on the network\n);\n}", 
            "title": "Network start"
        }, 
        {
            "location": "/UnityIntegration/network-start/#unity-integration-network-start", 
            "text": "Since Unity does not work as fast as Forge Networking, there are a few control flow features that we've added into the Unity Integration to allow you to plan your network setup for network objects. When you implement your generated  Behavior  script that was generated from the  NCW , you can override a function named  NetworkStart . When the  NetworkStart  function is called, that means the object has been setup on the network and is ready to do things like send RPCs, update fields, etc. Below is an example of how to override the NetworkStart method in order to disable a camera on a game object that is not owned by the current instance and set our fields update interval.  using BeardedManStudios.Forge.Networking.Generated;\nusing UnityEngine;\n\npublic class NetCam : NetworkCameraBehavior\n{\n    protected override void NetworkStart()\n    {\n        base.NetworkStart();\n\n        cameraRef = GetComponent Camera ();\n        networkObject.UpdateInterval = 100;\n\n        // If this is not our camera then we should not render using it\n        if (!networkObject.IsOwner)\n            cameraRef.enabled = false;\n    }\n}", 
            "title": "Unity Integration Network Start"
        }, 
        {
            "location": "/UnityIntegration/network-start/#networkstarted-event", 
            "text": "For your convenience, we've added a networkStarted event to  NetworkBehavior  so that you can do other operations on other objects that have a reference to the object in question. For example; if you instantitate the object (obviously from another script) and you want to do some special action on that object once it has been setup on the network, you can hook into this event.  var cameraPlayer = NetworkManager.Instance.InstantiateNetworkCamera();\ncameraPlayer.networkStarted += CameraReadyOnNetwork;\n\n// ...\n\nprivate void CameraReadyOnNetwork(NetworkBehavior playerCamera)\n{\n    UnityEngine.Debug.Log( The player camera   + playerCamera.name +   has been setup on the network );\n}", 
            "title": "networkStarted Event"
        }, 
        {
            "location": "/BasicNetworkSamples/server-hosting-code/", 
            "text": "Server Hosting Code\n\n\nSo you may have looked at the \nMultiplayerMenu.cs\n file and noticed there is a lot of amazing useful code samples there, but sometimes all that code can be a bit overwhelming and you just want to know \nHow do I start a server?\n. Below is a sample of how to start a UDP Server and a TCP Server.\n\n\nUDP Server\n\n\nint maxAllowedClients = 32;\nUDPServer server = new UDPServer(maxAllowedClients);\nserver.Connect();\n\n\n\n\nTCP Server\n\n\nint maxAllowedClients = 32;\nTCPServer server = new TCPServer(maxAllowedClients);\nserver.Connect();\n\n\n\n\nIt is worth noting that both \nUDPServer\n and \nTCPServer\n implement the \nIServer\n interface and derive from the \nNetWorker\n. So there are many casting and generic options to choose from. There are arguments that go into the \nConnect\n methods of these types, but they are for the \nMaster Server\n and \nNat Server\n.\n\n\nAssigning to Network Manager\n\n\nHard to believe?\n, Yes that is all the code you need to start up a server, now there is one more important piece of business we must complete. Since this server is most likely going to be the main communication \nNetWorker\n with the clients and the game, you are probably going to want to set it up as the default \nNetWorker\n for the \nNetworkManager\n to use. You can do this with the following:\n\n\n// The server object is the same object from the above code samples\nNetworkManager.Instance.Initialize(server);\n\n\n\n\nBy doing this, the passed in server will be the \nNetWorker\n that is used for all communication managed by the \nNetworkManager\n. This includes spawning objects, RPC calls on those objects, scene transitions and so forth.", 
            "title": "Server hosting code"
        }, 
        {
            "location": "/BasicNetworkSamples/server-hosting-code/#server-hosting-code", 
            "text": "So you may have looked at the  MultiplayerMenu.cs  file and noticed there is a lot of amazing useful code samples there, but sometimes all that code can be a bit overwhelming and you just want to know  How do I start a server? . Below is a sample of how to start a UDP Server and a TCP Server.", 
            "title": "Server Hosting Code"
        }, 
        {
            "location": "/BasicNetworkSamples/server-hosting-code/#udp-server", 
            "text": "int maxAllowedClients = 32;\nUDPServer server = new UDPServer(maxAllowedClients);\nserver.Connect();", 
            "title": "UDP Server"
        }, 
        {
            "location": "/BasicNetworkSamples/server-hosting-code/#tcp-server", 
            "text": "int maxAllowedClients = 32;\nTCPServer server = new TCPServer(maxAllowedClients);\nserver.Connect();  It is worth noting that both  UDPServer  and  TCPServer  implement the  IServer  interface and derive from the  NetWorker . So there are many casting and generic options to choose from. There are arguments that go into the  Connect  methods of these types, but they are for the  Master Server  and  Nat Server .", 
            "title": "TCP Server"
        }, 
        {
            "location": "/BasicNetworkSamples/server-hosting-code/#assigning-to-network-manager", 
            "text": "Hard to believe? , Yes that is all the code you need to start up a server, now there is one more important piece of business we must complete. Since this server is most likely going to be the main communication  NetWorker  with the clients and the game, you are probably going to want to set it up as the default  NetWorker  for the  NetworkManager  to use. You can do this with the following:  // The server object is the same object from the above code samples\nNetworkManager.Instance.Initialize(server);  By doing this, the passed in server will be the  NetWorker  that is used for all communication managed by the  NetworkManager . This includes spawning objects, RPC calls on those objects, scene transitions and so forth.", 
            "title": "Assigning to Network Manager"
        }, 
        {
            "location": "/BasicNetworkSamples/client-connecting-code/", 
            "text": "Client Connecting Code\n\n\nBefore you can take full advantage of setting up a client, you will probably want to setup \nserver hosting code\n so that the client has something to actually connect to. Below is a sample of how to start a UDP Client and a TCP Client.\n\n\nUDP Client\n\n\nstring hostAddress = \n127.0.0.1\n;\nushort port = 15937;\nUDPClient client = new UDPClient();\nclient.Connect(hostAddress, port);\n\n\n\n\nTCP Client\n\n\nTCPClient client = new TCPClient();\nclient.Connect(hostAddress, port);\n\n\n\n\nAssigning to Network Manager\n\n\nHard to believe?\n Yes that is all the code you need to start up a client, now there is one more important piece of business we must complete. Since this client is most likely going to be the main communication \nNetWorker\n with the server and the game, you are probably going to want to set it up as the default \nNetWorker\n for the \nNetworkManager\n to use. You can do this with the following:\n\n\n// The client object is the same object from the above code samples\nNetworkManager.Instance.Initialize(client);\n\n\n\n\nBy doing this, the passed in client will be the \nNetWorker\n that is used for all communication managed by the \nNetworkManager\n. This includes spawning objects, RPC calls on those objects, scene transitions and so forth.", 
            "title": "Client connecting code"
        }, 
        {
            "location": "/BasicNetworkSamples/client-connecting-code/#client-connecting-code", 
            "text": "Before you can take full advantage of setting up a client, you will probably want to setup  server hosting code  so that the client has something to actually connect to. Below is a sample of how to start a UDP Client and a TCP Client.", 
            "title": "Client Connecting Code"
        }, 
        {
            "location": "/BasicNetworkSamples/client-connecting-code/#udp-client", 
            "text": "string hostAddress =  127.0.0.1 ;\nushort port = 15937;\nUDPClient client = new UDPClient();\nclient.Connect(hostAddress, port);", 
            "title": "UDP Client"
        }, 
        {
            "location": "/BasicNetworkSamples/client-connecting-code/#tcp-client", 
            "text": "TCPClient client = new TCPClient();\nclient.Connect(hostAddress, port);", 
            "title": "TCP Client"
        }, 
        {
            "location": "/BasicNetworkSamples/client-connecting-code/#assigning-to-network-manager", 
            "text": "Hard to believe?  Yes that is all the code you need to start up a client, now there is one more important piece of business we must complete. Since this client is most likely going to be the main communication  NetWorker  with the server and the game, you are probably going to want to set it up as the default  NetWorker  for the  NetworkManager  to use. You can do this with the following:  // The client object is the same object from the above code samples\nNetworkManager.Instance.Initialize(client);  By doing this, the passed in client will be the  NetWorker  that is used for all communication managed by the  NetworkManager . This includes spawning objects, RPC calls on those objects, scene transitions and so forth.", 
            "title": "Assigning to Network Manager"
        }, 
        {
            "location": "/BasicNetworkSamples/server-disconnect-client-code/", 
            "text": "Server Disconnect Client Code\n\n\nSometimes it is necessary to manually disconnect a player from the server (on the server). First you will need to find out which NetworkingPlayer you are wishing to kick on the server. Once you have a reference to that player, you are going to want to call the disconnect on them. To do this you need to use the reference to your server's \nNetWorker\n.\n\n\n// We are going to force the disconnect of the client\nbool forcefully = true;\n\n// Consider the player you want to disconnect is the targetPlayer object\n// Also consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker)\n((IServer)serverNetworker).Disconnect(targetPlayer, forcefully);\n\n\n\n\nThat is it, you are ready to start kicking all of the players! :D", 
            "title": "Server disconnect client code"
        }, 
        {
            "location": "/BasicNetworkSamples/server-disconnect-client-code/#server-disconnect-client-code", 
            "text": "Sometimes it is necessary to manually disconnect a player from the server (on the server). First you will need to find out which NetworkingPlayer you are wishing to kick on the server. Once you have a reference to that player, you are going to want to call the disconnect on them. To do this you need to use the reference to your server's  NetWorker .  // We are going to force the disconnect of the client\nbool forcefully = true;\n\n// Consider the player you want to disconnect is the targetPlayer object\n// Also consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker)\n((IServer)serverNetworker).Disconnect(targetPlayer, forcefully);  That is it, you are ready to start kicking all of the players! :D", 
            "title": "Server Disconnect Client Code"
        }, 
        {
            "location": "/BasicNetworkSamples/ban-client-code/", 
            "text": "Ban Client Code\n\n\nSometimes clients are just annoying and you want your hosts to be able to ban players from joining the server for a given amount of time (or what could be forever). To do this you need to use the reference to your server's \nNetWorker\n.\n\n\n// The amount of time in minutes that we want to ban the player\nint minutesToBan = 60;  // 1 hour\n\n// Consider the player you want to disconnect is the targetPlayer object\n// We will want to get the players network id as we are going to do a generic ban\n// Note:  If you have the network id from the RPC or any other messaging you can ban from there\nulong playerId = targetPlayer.NetworkId;\n\n// Consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker)\n((IServer)serverNetworker).BanPlayer(playerId, minutesToBan)", 
            "title": "Ban client code"
        }, 
        {
            "location": "/BasicNetworkSamples/ban-client-code/#ban-client-code", 
            "text": "Sometimes clients are just annoying and you want your hosts to be able to ban players from joining the server for a given amount of time (or what could be forever). To do this you need to use the reference to your server's  NetWorker .  // The amount of time in minutes that we want to ban the player\nint minutesToBan = 60;  // 1 hour\n\n// Consider the player you want to disconnect is the targetPlayer object\n// We will want to get the players network id as we are going to do a generic ban\n// Note:  If you have the network id from the RPC or any other messaging you can ban from there\nulong playerId = targetPlayer.NetworkId;\n\n// Consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker)\n((IServer)serverNetworker).BanPlayer(playerId, minutesToBan)", 
            "title": "Ban Client Code"
        }, 
        {
            "location": "/BasicNetworkSamples/send-binary-frame/", 
            "text": "Send Binary Frame\n\n\nThe \nBinary\n frame (BeardedManStudios.Forge.Networking.Frame.Binary) is a child of the \nFrameStream\n object which is how all messages are sent in Forge (even our internal code). To use this you need to serialize your data to a byte[] or pack it into a BMSByte object (wrapper around byte[] for caching).\n\n\nFirst you need to create your data\n\n\nbyte[] data = { /* Your data */ };\n\n\n\n\nNext you need to create the frame, since you want to send it to a specific player you will need to make the receivers be Target\n\n\nconst MY_GROUP_ID = MessageGroupIds .START_OF_GENERIC_IDS + 1; // Just a random message group id that is not being used anywhere else\n// \u2026\nulong timestep = NetworkManager.Instance.Time.Timestep;\nbool isTcpClient = NetworkManager.Instance.Networker is TCPClient;\nbool isTcp = NetworkManager.Instance.Networker is BaseTCP;\nBinary bin = new Binary(timestep, isTcpClient, data, Receivers.Target, MY_GROUP_ID, isTcp);\n\n\n\n\nNow that you have your binary frame named \"bin\", you can send it across the network. This is assuming that you are sending this frame from the server\n\n\nif (networker is UDPServer)\n{\n    bool isReliable = true;\n    ((UDPServer)networker).Send(targetNetworkingPlayer, bin, isReliable);\n}\nelse\n    ((TCPServer)networker).Send(targetNetworkingPlayer, bin);\n\n\n\n\nTo read this message you need to listen to the NetWorker::binaryMessageReceived event on the client. You can filter by the group id you've specified\n\n\nNetworkManager.Instance.Networker.binaryMessageReceived += ReadBinary;\n\n// ...\n\nprivate void ReadBinary(NetworkingPlayer player, Binary frame)\n{\n    if (frame.GroupId != MY_GROUP_ID)\n        return;\n\n    // TODO:  Your code here\n}", 
            "title": "Send binary frame"
        }, 
        {
            "location": "/BasicNetworkSamples/send-binary-frame/#send-binary-frame", 
            "text": "The  Binary  frame (BeardedManStudios.Forge.Networking.Frame.Binary) is a child of the  FrameStream  object which is how all messages are sent in Forge (even our internal code). To use this you need to serialize your data to a byte[] or pack it into a BMSByte object (wrapper around byte[] for caching).  First you need to create your data  byte[] data = { /* Your data */ };  Next you need to create the frame, since you want to send it to a specific player you will need to make the receivers be Target  const MY_GROUP_ID = MessageGroupIds .START_OF_GENERIC_IDS + 1; // Just a random message group id that is not being used anywhere else\n// \u2026\nulong timestep = NetworkManager.Instance.Time.Timestep;\nbool isTcpClient = NetworkManager.Instance.Networker is TCPClient;\nbool isTcp = NetworkManager.Instance.Networker is BaseTCP;\nBinary bin = new Binary(timestep, isTcpClient, data, Receivers.Target, MY_GROUP_ID, isTcp);  Now that you have your binary frame named \"bin\", you can send it across the network. This is assuming that you are sending this frame from the server  if (networker is UDPServer)\n{\n    bool isReliable = true;\n    ((UDPServer)networker).Send(targetNetworkingPlayer, bin, isReliable);\n}\nelse\n    ((TCPServer)networker).Send(targetNetworkingPlayer, bin);  To read this message you need to listen to the NetWorker::binaryMessageReceived event on the client. You can filter by the group id you've specified  NetworkManager.Instance.Networker.binaryMessageReceived += ReadBinary;\n\n// ...\n\nprivate void ReadBinary(NetworkingPlayer player, Binary frame)\n{\n    if (frame.GroupId != MY_GROUP_ID)\n        return;\n\n    // TODO:  Your code here\n}", 
            "title": "Send Binary Frame"
        }, 
        {
            "location": "/BasicNetworkSamples/send-file/", 
            "text": "Send File\n\n\nForge Networking works with all kinds of data, but that doesn't exclude sending files across the network. At the end of the day, files are just an array of bytes (\nbyte[]\n) and by now, you probably know you can send that stuff over the network with Forge Networking. So let's get started with a simple desktop-\ndesktop file transfer shall we!\n\n\nThe Setup\n\n\nTo get started we are going to need to setup our environment so that we can quickly and easily test our code. So let's open up a project with Forge Networking imported into it to get started.\n\n\n1) Download the \ndeal-with-it.jpg\n image (cat image below)\n2) Open project with Forge Networking imported\n3) Create a folder named \nFileTransfer\n\n4) Copy the \ndeal-with-it.jpg\n image into the \nFileTransfer\n folder\n5) Create a new scene and save it into the \nFileTransfer\n folder named \nFileTransferTest\n\n6) Create a C# script in the \nFileTransfer\n folder named \nSendThatFile\n\n7) Open that script in your favorite editor\n8) Put the following code into the script\n\n\n\n\nNote that this code is not optimized but made simple for quick understanding\n\n\nusing BeardedManStudios;\nusing BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Frame;\nusing BeardedManStudios.Forge.Networking.Unity;\nusing System.IO;\nusing UnityEngine;\n\npublic class SendThatFile : MonoBehaviour\n{\n    public string filePath;\n    private bool sentFile;\n\n    private void Start()\n    {\n        NetworkManager.Instance.Networker.binaryMessageReceived += ReceiveFile;\n    }\n\n    private void ReceiveFile(NetworkingPlayer player, Binary frame)\n    {\n        // We are looking to read a very specific message\n        if (frame.GroupId != MessageGroupIds.START_OF_GENERIC_IDS + 1)\n            return;\n\n        Debug.Log(\nReading file!\n);\n\n        // Read the string from the beginning of the payload\n        string fileName = frame.StreamData.GetBasicType\nstring\n();\n\n        Debug.Log(\nFile name is \n + fileName);\n\n        if (File.Exists(fileName))\n        {\n            Debug.LogError(\nThe file \n + fileName + \n already exists!\n);\n            return;\n        }\n\n        // Write the rest of the payload as the contents of the file and\n        // use the file name that was extracted as the file's name\n        File.WriteAllBytes(fileName, frame.StreamData.CompressBytes());\n    }\n\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Space) \n !sentFile)\n        {\n            sentFile = true;\n\n            // Throw an error if this is not the server\n            var networker = NetworkManager.Instance.Networker;\n            if (!networker.IsServer)\n            {\n                Debug.LogError(\nOnly the server can send files in this example!\n);\n                return;\n            }\n\n            // Throw an error if the file does not exist\n            if (!File.Exists(filePath))\n            {\n                Debug.LogError(\nThe file \n + filePath + \n could not be found\n);\n                return;\n            }\n\n            // Prepare a byte array for sending\n            BMSByte allData = new BMSByte();\n\n            // Add the file name to the start of the payload\n            ObjectMapper.Instance.MapBytes(allData, Path.GetFileName(filePath));\n\n            // Add the data to the payload\n            allData.Append(File.ReadAllBytes(filePath));\n\n            // Send the file to all connected clients\n            Binary frame = new Binary(\n                networker.Time.Timestep,                    // The current timestep for this frame\n                false,                                      // We are server, no mask needed\n                allData,                                    // The file that is being sent\n                Receivers.Others,                           // Send to all clients\n                MessageGroupIds.START_OF_GENERIC_IDS + 1,   // Some random fake number\n                networker is TCPServer);\n\n            if (networker is UDPServer)\n                ((UDPServer)networker).Send(frame, true);\n            else\n                ((TCPServer)networker).SendAll(frame);\n        }\n    }\n}\n\n\n\n\nPreparing to run\n\n\n1) Open the Unity build menu\n2) Add the \nMultiplayerMenu\n scene as the first scene\n3) Add the \nFileTransferTest\n as the second scene\n4) Open the Player Settings...\n5) Turn on run in background\n6) Open the \nFileTransferTest\n scene\n7) Select the camera or any object in the scene\n8) Add the \nSendThatFile\n script to the object\n9) Update the \nFile Path\n field on the script to have the full path to the \ndeal-with-it.jpg\n image inside of the \nFileTransfer\n folder\n10) Save the scene\n11) Build and Run\n12) Open 2 instances of the game\n13) Set one to be the server then connect with the other\n14) Press the spacebar on the server\n15) Go into the build folder for the player and then go up a directory, you will notice a \ndeal-with-it.jpg\n has been created", 
            "title": "Send file"
        }, 
        {
            "location": "/BasicNetworkSamples/send-file/#send-file", 
            "text": "Forge Networking works with all kinds of data, but that doesn't exclude sending files across the network. At the end of the day, files are just an array of bytes ( byte[] ) and by now, you probably know you can send that stuff over the network with Forge Networking. So let's get started with a simple desktop- desktop file transfer shall we!", 
            "title": "Send File"
        }, 
        {
            "location": "/BasicNetworkSamples/send-file/#the-setup", 
            "text": "To get started we are going to need to setup our environment so that we can quickly and easily test our code. So let's open up a project with Forge Networking imported into it to get started.  1) Download the  deal-with-it.jpg  image (cat image below)\n2) Open project with Forge Networking imported\n3) Create a folder named  FileTransfer \n4) Copy the  deal-with-it.jpg  image into the  FileTransfer  folder\n5) Create a new scene and save it into the  FileTransfer  folder named  FileTransferTest \n6) Create a C# script in the  FileTransfer  folder named  SendThatFile \n7) Open that script in your favorite editor\n8) Put the following code into the script   Note that this code is not optimized but made simple for quick understanding  using BeardedManStudios;\nusing BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Frame;\nusing BeardedManStudios.Forge.Networking.Unity;\nusing System.IO;\nusing UnityEngine;\n\npublic class SendThatFile : MonoBehaviour\n{\n    public string filePath;\n    private bool sentFile;\n\n    private void Start()\n    {\n        NetworkManager.Instance.Networker.binaryMessageReceived += ReceiveFile;\n    }\n\n    private void ReceiveFile(NetworkingPlayer player, Binary frame)\n    {\n        // We are looking to read a very specific message\n        if (frame.GroupId != MessageGroupIds.START_OF_GENERIC_IDS + 1)\n            return;\n\n        Debug.Log( Reading file! );\n\n        // Read the string from the beginning of the payload\n        string fileName = frame.StreamData.GetBasicType string ();\n\n        Debug.Log( File name is   + fileName);\n\n        if (File.Exists(fileName))\n        {\n            Debug.LogError( The file   + fileName +   already exists! );\n            return;\n        }\n\n        // Write the rest of the payload as the contents of the file and\n        // use the file name that was extracted as the file's name\n        File.WriteAllBytes(fileName, frame.StreamData.CompressBytes());\n    }\n\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Space)   !sentFile)\n        {\n            sentFile = true;\n\n            // Throw an error if this is not the server\n            var networker = NetworkManager.Instance.Networker;\n            if (!networker.IsServer)\n            {\n                Debug.LogError( Only the server can send files in this example! );\n                return;\n            }\n\n            // Throw an error if the file does not exist\n            if (!File.Exists(filePath))\n            {\n                Debug.LogError( The file   + filePath +   could not be found );\n                return;\n            }\n\n            // Prepare a byte array for sending\n            BMSByte allData = new BMSByte();\n\n            // Add the file name to the start of the payload\n            ObjectMapper.Instance.MapBytes(allData, Path.GetFileName(filePath));\n\n            // Add the data to the payload\n            allData.Append(File.ReadAllBytes(filePath));\n\n            // Send the file to all connected clients\n            Binary frame = new Binary(\n                networker.Time.Timestep,                    // The current timestep for this frame\n                false,                                      // We are server, no mask needed\n                allData,                                    // The file that is being sent\n                Receivers.Others,                           // Send to all clients\n                MessageGroupIds.START_OF_GENERIC_IDS + 1,   // Some random fake number\n                networker is TCPServer);\n\n            if (networker is UDPServer)\n                ((UDPServer)networker).Send(frame, true);\n            else\n                ((TCPServer)networker).SendAll(frame);\n        }\n    }\n}", 
            "title": "The Setup"
        }, 
        {
            "location": "/BasicNetworkSamples/send-file/#preparing-to-run", 
            "text": "1) Open the Unity build menu\n2) Add the  MultiplayerMenu  scene as the first scene\n3) Add the  FileTransferTest  as the second scene\n4) Open the Player Settings...\n5) Turn on run in background\n6) Open the  FileTransferTest  scene\n7) Select the camera or any object in the scene\n8) Add the  SendThatFile  script to the object\n9) Update the  File Path  field on the script to have the full path to the  deal-with-it.jpg  image inside of the  FileTransfer  folder\n10) Save the scene\n11) Build and Run\n12) Open 2 instances of the game\n13) Set one to be the server then connect with the other\n14) Press the spacebar on the server\n15) Go into the build folder for the player and then go up a directory, you will notice a  deal-with-it.jpg  has been created", 
            "title": "Preparing to run"
        }, 
        {
            "location": "/SceneNavigation/loading-scenes/", 
            "text": "Loading Scenes\n\n\nOne of the things that you may be worring about is how you can load into new scenes on the network. Some issues you may worry about are:\n\n\n\n\nHow do clients know when to change scenes?\n\n\nHow do I clean up all the network objects?\n\n\nHow do clients know what scene to go to?\n\n\nHow do newly connected clients know what scene is currently active?\n\n\nHow do I handle additive scenes?\n\n\n\n\nThese are all good questions and also all questions that you don't have to worry about in Forge Networking. We hook into Unity's \nSceneManager.sceneLoaded\n event so that we can detect when the scene changes or new scenes are additively loaded on the server. Once the server detects this scene change it will tell all the connected clients to change to the new scene that the server has loaded. If an addative scene was loaded on the server, the server then tells the clients to also additively load the scene. Also the server keeps track of the scenes that are currently active so that it can send them down to the newly accepted client who just connected.\n\n\nThere are a few important notes about scenes with Forge Networking:\n\n\n\n\nThe server must load the scene to trigger all of the clients to load scenes\n\n\nClients can still load scenes without the server having to dictate the change, however when the server changes the scene it will get pushed to the client and overwrite the changes\n\n\nYou load scenes as you normally would do in Unity on the server, no extra calls are needed\n\n\n\n\nBelow is a sample of how to load a scene on the server only if both the server and client are sharing code. The \nNetworker\n in this case will be a reference to the NetWorker in \nNetworkManager.Instance.Networker\n.\n\n\nLoading a single scene on the server\n\n\n// This will load scene at build index 1 only if this is the server's code\nif (Networker.IsServer)\n    SceneManager.LoadScene(1, LoadSceneMode.Single);\n\n\n\n\nAsync loading a single scene on the server\n\n\n// This will load scene at build index 1 only if this is the server's code\nif (Networker.IsServer)\n    SceneManager.LoadSceneAsync(1, LoadSceneMode.Single);\n\n\n\n\nLoading an addative scene on the server\n\n\n// This will load scene at build index 1 only if this is the server's code\nif (Networker.IsServer)\n    SceneManager.LoadScene(1, LoadSceneMode.Additive);\n\n\n\n\nAsync loading an additive scene on the server\n\n\n// This will load scene at build index 1 only if this is the server's code\nif (Networker.IsServer)\n    SceneManager.LoadSceneAsync(1, LoadSceneMode.Additive);", 
            "title": "Loading scenes"
        }, 
        {
            "location": "/SceneNavigation/loading-scenes/#loading-scenes", 
            "text": "One of the things that you may be worring about is how you can load into new scenes on the network. Some issues you may worry about are:   How do clients know when to change scenes?  How do I clean up all the network objects?  How do clients know what scene to go to?  How do newly connected clients know what scene is currently active?  How do I handle additive scenes?   These are all good questions and also all questions that you don't have to worry about in Forge Networking. We hook into Unity's  SceneManager.sceneLoaded  event so that we can detect when the scene changes or new scenes are additively loaded on the server. Once the server detects this scene change it will tell all the connected clients to change to the new scene that the server has loaded. If an addative scene was loaded on the server, the server then tells the clients to also additively load the scene. Also the server keeps track of the scenes that are currently active so that it can send them down to the newly accepted client who just connected.  There are a few important notes about scenes with Forge Networking:   The server must load the scene to trigger all of the clients to load scenes  Clients can still load scenes without the server having to dictate the change, however when the server changes the scene it will get pushed to the client and overwrite the changes  You load scenes as you normally would do in Unity on the server, no extra calls are needed   Below is a sample of how to load a scene on the server only if both the server and client are sharing code. The  Networker  in this case will be a reference to the NetWorker in  NetworkManager.Instance.Networker .", 
            "title": "Loading Scenes"
        }, 
        {
            "location": "/SceneNavigation/loading-scenes/#loading-a-single-scene-on-the-server", 
            "text": "// This will load scene at build index 1 only if this is the server's code\nif (Networker.IsServer)\n    SceneManager.LoadScene(1, LoadSceneMode.Single);", 
            "title": "Loading a single scene on the server"
        }, 
        {
            "location": "/SceneNavigation/loading-scenes/#async-loading-a-single-scene-on-the-server", 
            "text": "// This will load scene at build index 1 only if this is the server's code\nif (Networker.IsServer)\n    SceneManager.LoadSceneAsync(1, LoadSceneMode.Single);", 
            "title": "Async loading a single scene on the server"
        }, 
        {
            "location": "/SceneNavigation/loading-scenes/#loading-an-addative-scene-on-the-server", 
            "text": "// This will load scene at build index 1 only if this is the server's code\nif (Networker.IsServer)\n    SceneManager.LoadScene(1, LoadSceneMode.Additive);", 
            "title": "Loading an addative scene on the server"
        }, 
        {
            "location": "/SceneNavigation/loading-scenes/#async-loading-an-additive-scene-on-the-server", 
            "text": "// This will load scene at build index 1 only if this is the server's code\nif (Networker.IsServer)\n    SceneManager.LoadSceneAsync(1, LoadSceneMode.Additive);", 
            "title": "Async loading an additive scene on the server"
        }, 
        {
            "location": "/SceneNavigation/scene-events/", 
            "text": "Scene Events\n\n\nThere are some events that you can register to in order to know the flow of the scene loading events. Below are a list of the available events to hook into for scene loading and short descriptions of what they are for. \nNote\n All of these events are available through the \nNetworkManager.Instance\n so for example \nplayerLoadedScene\n would be \nNetworkManager.Instance.playerLoadedScene\n.\n\n\nplayerLoadedScene\n\n\nThis is used on the server to know when a specific player has finished loading into a level.\n\n\nnetworkSceneChanging\n\n\nThis is used on the client to know if it has been told by the server to change the scene. This happens just before the scene change is invoked.\n\n\nnetworkSceneLoaded\n\n\nThis is used on the client and the server to know when the scene has been successfully loaded and is ready to begin with networking code (starting with spawning Network Objects).", 
            "title": "Scene events"
        }, 
        {
            "location": "/SceneNavigation/scene-events/#scene-events", 
            "text": "There are some events that you can register to in order to know the flow of the scene loading events. Below are a list of the available events to hook into for scene loading and short descriptions of what they are for.  Note  All of these events are available through the  NetworkManager.Instance  so for example  playerLoadedScene  would be  NetworkManager.Instance.playerLoadedScene .", 
            "title": "Scene Events"
        }, 
        {
            "location": "/SceneNavigation/scene-events/#playerloadedscene", 
            "text": "This is used on the server to know when a specific player has finished loading into a level.", 
            "title": "playerLoadedScene"
        }, 
        {
            "location": "/SceneNavigation/scene-events/#networkscenechanging", 
            "text": "This is used on the client to know if it has been told by the server to change the scene. This happens just before the scene change is invoked.", 
            "title": "networkSceneChanging"
        }, 
        {
            "location": "/SceneNavigation/scene-events/#networksceneloaded", 
            "text": "This is used on the client and the server to know when the scene has been successfully loaded and is ready to begin with networking code (starting with spawning Network Objects).", 
            "title": "networkSceneLoaded"
        }, 
        {
            "location": "/NetWorker/temporarily-blocking-connections/", 
            "text": "Temporarily Blocking Connections\n\n\nSometimes, when a match starts, you don't want people being able to join the server, even when other players leave. You are able to tell the server to no longer accept connections as seen below:\n\n\nNetWorker server = new UdpServer(32);\nserver.Connect();\n\n// ...\n\n// Don't allow any more connections to this server, but don't kick any current connections\n((IServer)server).StopAcceptingConnections();\n\n\n\n\nObviosuly we needed to give you a way to be able to start accepting connections again otherwise that would be kinda rude. So we wen't ahead and made the following function for you to begin accepting connections again. \nNote that this is a continuation of the above example\n\n\n// Start allowing for connections to this server again\n((IServer)server).StartAcceptingConnections();\n\n\n\n\nLastly, you may have forgotten or don't know if you stopped allowing connections, so we made this handy boolean for you to check against! \nNote that this is a continuation of the above example\n\n\nif (!((IServer)server).AcceptingConnections)\n{\n    // Connections are currently not allowed for this server\n}", 
            "title": "Temporarily blocking connections"
        }, 
        {
            "location": "/NetWorker/temporarily-blocking-connections/#temporarily-blocking-connections", 
            "text": "Sometimes, when a match starts, you don't want people being able to join the server, even when other players leave. You are able to tell the server to no longer accept connections as seen below:  NetWorker server = new UdpServer(32);\nserver.Connect();\n\n// ...\n\n// Don't allow any more connections to this server, but don't kick any current connections\n((IServer)server).StopAcceptingConnections();  Obviosuly we needed to give you a way to be able to start accepting connections again otherwise that would be kinda rude. So we wen't ahead and made the following function for you to begin accepting connections again.  Note that this is a continuation of the above example  // Start allowing for connections to this server again\n((IServer)server).StartAcceptingConnections();  Lastly, you may have forgotten or don't know if you stopped allowing connections, so we made this handy boolean for you to check against!  Note that this is a continuation of the above example  if (!((IServer)server).AcceptingConnections)\n{\n    // Connections are currently not allowed for this server\n}", 
            "title": "Temporarily Blocking Connections"
        }, 
        {
            "location": "/NetWorker/thread-safe-player-iteration/", 
            "text": "Thread Safe Player Iteration\n\n\nSometimes it is important for our server to go through every player on the network and perform some action for them. Being that the players can connect asynchronously to the server, the \nPlayers\n list can be altered at any point, even while we are currently iterating through the players. There are two ways to be able to go through the players in a thread-safe manor \nWHICH YOU MUST ALWAYS DO\n. You either will be required to lock the players before performing any actions on them, or you can use the provided helper method \nNetWorker::IteratePlayers\n.\n\n\nIf you were to use a simple lock, then let's say we had a reference to a \nNetWorker\n with the variable name myNetWorker. Now you have direct access to the players via the myNetWorker.Players getter, however it is not thread safe to just simply access them in this way; you instead will lock them as seen in the following:\n\n\nLocking\n\n\nlock (myNetWorker.Players)\n{\n    // Do your player iteration logic here\n}\n\n\n\n\nThe second way would be to use the \nNetWorker::IteratePlayers\n method as described above. There are two ways that you can do this, the first being to provide a lambda expression [INSERT LINK] for quick inline actions and the other is to provide a function pointer.\n\n\nLambda Expression\n\n\n// This is an example of using a lambda expression\nmyNetWorker.IteratePlayers((player) =\n\n{\n    // Do your player iteration logic here\n});\n\n\n\n\nFunction Pointer\n\n\n// This is an example of using a function pointer\nmyNetWorker.IteratePlayers(GoThroughPlayers);\n\n// ...\nprivate void GoThroughPlayers(NetworkingPlayer player)\n{\n    // Do your player iteration logic here\n}", 
            "title": "Thread safe player iteration"
        }, 
        {
            "location": "/NetWorker/thread-safe-player-iteration/#thread-safe-player-iteration", 
            "text": "Sometimes it is important for our server to go through every player on the network and perform some action for them. Being that the players can connect asynchronously to the server, the  Players  list can be altered at any point, even while we are currently iterating through the players. There are two ways to be able to go through the players in a thread-safe manor  WHICH YOU MUST ALWAYS DO . You either will be required to lock the players before performing any actions on them, or you can use the provided helper method  NetWorker::IteratePlayers .  If you were to use a simple lock, then let's say we had a reference to a  NetWorker  with the variable name myNetWorker. Now you have direct access to the players via the myNetWorker.Players getter, however it is not thread safe to just simply access them in this way; you instead will lock them as seen in the following:", 
            "title": "Thread Safe Player Iteration"
        }, 
        {
            "location": "/NetWorker/thread-safe-player-iteration/#locking", 
            "text": "lock (myNetWorker.Players)\n{\n    // Do your player iteration logic here\n}  The second way would be to use the  NetWorker::IteratePlayers  method as described above. There are two ways that you can do this, the first being to provide a lambda expression [INSERT LINK] for quick inline actions and the other is to provide a function pointer.", 
            "title": "Locking"
        }, 
        {
            "location": "/NetWorker/thread-safe-player-iteration/#lambda-expression", 
            "text": "// This is an example of using a lambda expression\nmyNetWorker.IteratePlayers((player) = \n{\n    // Do your player iteration logic here\n});", 
            "title": "Lambda Expression"
        }, 
        {
            "location": "/NetWorker/thread-safe-player-iteration/#function-pointer", 
            "text": "// This is an example of using a function pointer\nmyNetWorker.IteratePlayers(GoThroughPlayers);\n\n// ...\nprivate void GoThroughPlayers(NetworkingPlayer player)\n{\n    // Do your player iteration logic here\n}", 
            "title": "Function Pointer"
        }, 
        {
            "location": "/MasterServer/quick-start/", 
            "text": "Master Server Quick Start\n\n\nThe Master Server is a stand alone server that allows for games to be publically (or privately with password) listed for the world to join. If you've ever played an online game with friends, chances are that you have had to get their IP address in order to join their hosted games. The Master Server gives your game the ability to have these fancy server listings.\n\n\nGetting the Master Server\n\n\nTo start with your Master Server adventures you must first purchase the Independent Master Server. \nAHH!!\n another purchase? Well yes, Forge Networking sells addons to help support the team to continue developing for Forge Networking. We've been around since 2014 so something has to be working with this model :). Speaking of which, \nTHANK YOU\n sooooo much for supporting Forge Networking, it means a lot to us and the community!\n\n\nAlright, where were we, ah yes; downloading the Master Server. The first thing you need to do is head over to your \nForge Networking developer profile\n and scroll down towards the bottom. You will see the addon section with \nUnity Independent Master Server\n listed right. Once you purchase this addon through PayPal you will immediately have it in your account for download.\n\n\nRunning the Master Server\n\n\nAt this poing we are assuming that you have already purchased the Master Server addon and you are looking to get it up and running. The very first thing you do on any operating system is to head over to your \ndeveloper profile\n and locate the download for the \nUnity Independent Master Server\n. Upon downloading this file (a .zip file) you will find that within the contents is a README file to get you started and the .exe file to be run.\n\n\nWindows\n\n\nIn windows it is very simple to host a Master Server. Just double click the \nMasterServer.exe\n and you are up and running!\n\n\nOther Platforms\n\n\nOn any platform other than Windows, as you may know, you can not run an \n.exe\n file. However with the power of Mono you will be abel to do such things without any extra coding needed. Please follow the instructions required to install mono onto your respecive platform. After this you can open up a terminal window in the location where the \n.exe\n file was extracted and you can run the program by doing \nmono MasterServer.exe\n.\n\n\nFirewall\n\n\nSo in order for your MasterServer to be effective, you will need to allow the process through your machine firewall (see instructions on how to allow a process on your operating system through the firewall). Once you have allowed the process on your machine through your machine's firewall, it is time for you to allow the port to your machine on the network. Yes, there are technically 2 firewalls that you have to setup to allow an application to be visible to the outside world. Every router is different and so there are many different ways to allow port forwarding to your machine. Please veiew an online guide on how to set this up for your router make/model. The default port number for the master server is \n15940\n.\n\n\nUsing the Master Server\n\n\nSo now that we have the master server up and running on our machine, it is time to give it a test and see what all is needed to use it. Lets begin by making sure that everything is working properly by running the built in testing method for Master Servers that come with Forge Networking.\n\n\n\n\nOpen your project with Forge Netwroking\n\n\nOpen the demo Multiplayer Menu scene\n\n\nMake sure your build settings have a scene after the Multiplayer Menu scene in it\n\n\nLocate the \nCanvas\n game object in the hierarchy and select it\n\n\nLocate the \nMaster Server Host\n and \nMaster Server Port\n in the Inspector\n\n\n\nInput the local or static IP address of the machine your Master Server is running on\n\n\nInput \n15940\n as the port number for the Master Server\n\n\nClick the play button in Unity\n\n\nClick this \nHost\n button to start a game server\n\n\n\n\nIf you look at the Master Server command/terminal you should notice that a message appears with your game servers IP address and port number saying that it has been registered. At this point any clients can now connect to your Master Server and get the host listings. If the message did not appear then you've probably not setup the firewall settings correctly on either your machine or your router/network.", 
            "title": "Quick start"
        }, 
        {
            "location": "/MasterServer/quick-start/#master-server-quick-start", 
            "text": "The Master Server is a stand alone server that allows for games to be publically (or privately with password) listed for the world to join. If you've ever played an online game with friends, chances are that you have had to get their IP address in order to join their hosted games. The Master Server gives your game the ability to have these fancy server listings.", 
            "title": "Master Server Quick Start"
        }, 
        {
            "location": "/MasterServer/quick-start/#getting-the-master-server", 
            "text": "To start with your Master Server adventures you must first purchase the Independent Master Server.  AHH!!  another purchase? Well yes, Forge Networking sells addons to help support the team to continue developing for Forge Networking. We've been around since 2014 so something has to be working with this model :). Speaking of which,  THANK YOU  sooooo much for supporting Forge Networking, it means a lot to us and the community!  Alright, where were we, ah yes; downloading the Master Server. The first thing you need to do is head over to your  Forge Networking developer profile  and scroll down towards the bottom. You will see the addon section with  Unity Independent Master Server  listed right. Once you purchase this addon through PayPal you will immediately have it in your account for download.", 
            "title": "Getting the Master Server"
        }, 
        {
            "location": "/MasterServer/quick-start/#running-the-master-server", 
            "text": "At this poing we are assuming that you have already purchased the Master Server addon and you are looking to get it up and running. The very first thing you do on any operating system is to head over to your  developer profile  and locate the download for the  Unity Independent Master Server . Upon downloading this file (a .zip file) you will find that within the contents is a README file to get you started and the .exe file to be run.", 
            "title": "Running the Master Server"
        }, 
        {
            "location": "/MasterServer/quick-start/#windows", 
            "text": "In windows it is very simple to host a Master Server. Just double click the  MasterServer.exe  and you are up and running!", 
            "title": "Windows"
        }, 
        {
            "location": "/MasterServer/quick-start/#other-platforms", 
            "text": "On any platform other than Windows, as you may know, you can not run an  .exe  file. However with the power of Mono you will be abel to do such things without any extra coding needed. Please follow the instructions required to install mono onto your respecive platform. After this you can open up a terminal window in the location where the  .exe  file was extracted and you can run the program by doing  mono MasterServer.exe .", 
            "title": "Other Platforms"
        }, 
        {
            "location": "/MasterServer/quick-start/#firewall", 
            "text": "So in order for your MasterServer to be effective, you will need to allow the process through your machine firewall (see instructions on how to allow a process on your operating system through the firewall). Once you have allowed the process on your machine through your machine's firewall, it is time for you to allow the port to your machine on the network. Yes, there are technically 2 firewalls that you have to setup to allow an application to be visible to the outside world. Every router is different and so there are many different ways to allow port forwarding to your machine. Please veiew an online guide on how to set this up for your router make/model. The default port number for the master server is  15940 .", 
            "title": "Firewall"
        }, 
        {
            "location": "/MasterServer/quick-start/#using-the-master-server", 
            "text": "So now that we have the master server up and running on our machine, it is time to give it a test and see what all is needed to use it. Lets begin by making sure that everything is working properly by running the built in testing method for Master Servers that come with Forge Networking.   Open your project with Forge Netwroking  Open the demo Multiplayer Menu scene  Make sure your build settings have a scene after the Multiplayer Menu scene in it  Locate the  Canvas  game object in the hierarchy and select it  Locate the  Master Server Host  and  Master Server Port  in the Inspector  Input the local or static IP address of the machine your Master Server is running on  Input  15940  as the port number for the Master Server  Click the play button in Unity  Click this  Host  button to start a game server   If you look at the Master Server command/terminal you should notice that a message appears with your game servers IP address and port number saying that it has been registered. At this point any clients can now connect to your Master Server and get the host listings. If the message did not appear then you've probably not setup the firewall settings correctly on either your machine or your router/network.", 
            "title": "Using the Master Server"
        }, 
        {
            "location": "/MasterServer/connecting-to-master-server/", 
            "text": "Connecting to Master Server\n\n\nIf you have not already, we would suggest reviewing the \nMaster Server Quick Start\n documentation to get familiar with the Master Server and to setup the stand alone executable.\n\n\nWhen you first initialize your \nNetworkManager\n (as seen in \nMultiplayerMenu.cs\n) you will need to provide it with the NetWorker that you wish to use for standard game network communications. To do this the NetworkManager has a method \nMasterServerRegisterData\n that you can use in order to get the registration data object to allow you to register your game server with the Master Server. Below is an example of how to use the \nMasterServerRegisterData\n method to generate the json data needed to register the game server.\n\n\nstring serverId = \nmyGame\n;\nstring serverName = \nForge Game\n;\nstring type = \nDeathmatch\n;\nstring mode = \nTeams\n;\nstring comment = \nDemo comment...\n;\nbool useElo = false;\nint eloRequired = 0;\n\nJSONNode masterServerData = NetworkManager.Instance.MasterServerRegisterData(networker, serverId, serverName, type, mode, comment, useElo, eloRequired);\n\n\n\n\nYou may be curious what to do next with this data and the answer is to send it into the NetworkManager's \nInitialize\n method as seen below.\n\n\n// This should be the IP address of the machine that your master server is hosted on\nstring masterServerHost = \n127.0.0.1\n;\n\n// This can be left as the default port (15940) if you did not change it when hosting the master server\nushort masterServerPort = 15940;\n\nNetworkManager.Instance.Initialize(networker, masterServerHost, masterServerPort, masterServerData);\n\n\n\n\nWith all of this setup your game server should now be automatically registered on the Master Server once this method is called.", 
            "title": "Connecting to master server"
        }, 
        {
            "location": "/MasterServer/connecting-to-master-server/#connecting-to-master-server", 
            "text": "If you have not already, we would suggest reviewing the  Master Server Quick Start  documentation to get familiar with the Master Server and to setup the stand alone executable.  When you first initialize your  NetworkManager  (as seen in  MultiplayerMenu.cs ) you will need to provide it with the NetWorker that you wish to use for standard game network communications. To do this the NetworkManager has a method  MasterServerRegisterData  that you can use in order to get the registration data object to allow you to register your game server with the Master Server. Below is an example of how to use the  MasterServerRegisterData  method to generate the json data needed to register the game server.  string serverId =  myGame ;\nstring serverName =  Forge Game ;\nstring type =  Deathmatch ;\nstring mode =  Teams ;\nstring comment =  Demo comment... ;\nbool useElo = false;\nint eloRequired = 0;\n\nJSONNode masterServerData = NetworkManager.Instance.MasterServerRegisterData(networker, serverId, serverName, type, mode, comment, useElo, eloRequired);  You may be curious what to do next with this data and the answer is to send it into the NetworkManager's  Initialize  method as seen below.  // This should be the IP address of the machine that your master server is hosted on\nstring masterServerHost =  127.0.0.1 ;\n\n// This can be left as the default port (15940) if you did not change it when hosting the master server\nushort masterServerPort = 15940;\n\nNetworkManager.Instance.Initialize(networker, masterServerHost, masterServerPort, masterServerData);  With all of this setup your game server should now be automatically registered on the Master Server once this method is called.", 
            "title": "Connecting to Master Server"
        }, 
        {
            "location": "/MasterServer/getting-host-list/", 
            "text": "Getting Host List From Master Server\n\n\nIf you have not already, we would suggest reviewing the \nMaster Server Quick Start\n documentation to get familiar with the Master Server and to setup the stand alone executable and then reviewing \nConnecting to Master Server\n to learn how to register your game server on the master server.\n\n\nRequest stages\n\n\nThere are a few stages when requesting the list of servers from the master server:\n\n\n\n\nConnect to Master Server\n\n\nCreate a JSONNode request\n\n\nSend the request to the server\n\n\nGet response from the server\n\n\nParse response from server\n\n\nImplement your code\n\n\n\n\n(1) So the very first thing you have to do is to connect to the master server. We have created a helper class to get you doing this quickly:\n\n\n// TODO:  This will be the address of the machine your master server is running on\nstring host = \n127.0.0.1\n;\n\nushort port = 15937;\n\n// The Master Server communicates over TCP\nTCPMasterClient client = new TCPMasterClient();\n\n// Just call the connect method and you are ready to go\nclient.Connect(host, ort);\n\n\n\n\n(2) Once your server is accepted (which you can use the \nserverAccepted\n event) you can create your request to the master server. The request is a JSONNode object that follows this structure:\n\n\n{\n    get:\n    {\n        id: \nmyGame\n,\n        type: \nany\n,\n        mode: \nall\n\n    }\n}\n\n\n\n\nYou can do this with code similar to the following:\n\n\n// The overall game id to select from\nstring gameId = \nmyGame\n;\n\n// The game type to choose from, if \nany\n then all types will be returned\nstring gameType = \nany\n;\n\n// The game mode to choose from, if \nall\n then all game modes will be returned\nstring gameMode = \nall\n;\n\n// Create the get request with the desired filters\nJSONNode sendData = JSONNode.Parse(\n{}\n);\nJSONClass getData = new JSONClass();\n\n// The id of the game to get\ngetData.Add(\nid\n, gameId);\ngetData.Add(\ntype\n, gameType);\ngetData.Add(\nmode\n, gameMode);\n\nsendData.Add(\nget\n, getData);\n\n\n\n\n(3) Now that we have the json \nsendData\n we need to send it to the server. Since JSON can be a string representation, you can send it directly to the server as a \nText\n frame in Forge:\n\n\n// Send the request to the server\nclient.Send(Frame.Text.CreateFromString(client.Time.Timestep, sendData.ToString(), true, Receivers.Server, MessageGroupIds.MASTER_SERVER_GET, true));\n\n\n\n\n(4) If you listen to the \ntextMessageReceived\n event on the \nclient\n object you will be able to capture the response from the server. This response will contain any errors (if any) and most importantly, your game list!\n\n\n(5) Now that you have the JSON response from the server, you will need to parse it into the \nMasterServerResponse\n object. Lets imagine that your json response variable is called \ndata\n, then the code you will need to parse the response to this object is:\n\n\n// Create a C# object for the response from the master server\nMasterServerResponse response = new MasterServerResponse(data[\nhosts\n].AsArray);\n\n\n\n\nNote\n: If \ndata[\"hosts\"]\n is null, then there was an error.\n\n\n(6) Now that you have the \nMasterServerResponse\n object, you are ready to start writing your code for the UI and any other behaviors you want to execute based on the server listing.\n\n\nforeach (MasterServerResponse.Server server in response.serverResponse)\n{\n    // TODO:  Do something with the server information here!\n}\n\n\n\n\nRefresh Complete Sample\n\n\nBelow is a compelte example of how to:\n\n\n\n\nConnect to master server\n\n\nRequest the games list from the master server\n\n\nProcess the list of games returned from the master server\n\n\nDisconnect from the master server\n\n\n\n\nThe below example can be used to refresh the current listings of hosts from the master server. Please be sure to read the comments within the code to better understand what is going on. It is also good to scroll up and reference the top of this page to see why and when things happen in this sample.\n\n\npublic void Refresh()\n{\n    // TODO:  Clear out any previously listed servers\n\n    // The Master Server communicates over TCP\n    TCPMasterClient client = new TCPMasterClient();\n\n    // Once this client has been accepted by the master server it should sent it's get request\n    client.serverAccepted += () =\n\n    {\n        try\n        {\n            // The overall game id to select from\n            string gameId = \nmyGame\n;\n\n            // The game type to choose from, if \nany\n then all types will be returned\n            string gameType = \nany\n;\n\n            // The game mode to choose from, if \nall\n then all game modes will be returned\n            string gameMode = \nall\n;\n\n            // Create the get request with the desired filters\n            JSONNode sendData = JSONNode.Parse(\n{}\n);\n            JSONClass getData = new JSONClass();\n\n            // The id of the game to get\n            getData.Add(\nid\n, gameId);\n            getData.Add(\ntype\n, gameType);\n            getData.Add(\nmode\n, gameMode);\n\n            sendData.Add(\nget\n, getData);\n\n            // Send the request to the server\n            client.Send(Frame.Text.CreateFromString(client.Time.Timestep, sendData.ToString(), true, Receivers.Server, MessageGroupIds.MASTER_SERVER_GET, true));\n        }\n        catch\n        {\n            // If anything fails, then this client needs to be disconnected\n            client.Disconnect(true);\n            client = null;\n        }\n    };\n\n    // An event that is raised when the server responds with hosts\n    client.textMessageReceived += (player, frame) =\n\n    {\n        try\n        {\n            // Get the list of hosts to iterate through from the frame payload\n            JSONNode data = JSONNode.Parse(frame.ToString());\n            if (data[\nhosts\n] != null)\n            {\n                // Create a C# object for the response from the master server\n                MasterServerResponse response = new MasterServerResponse(data[\nhosts\n].AsArray);\n\n                if (response != null \n response.serverResponse.Count \n 0)\n                {\n                    // Go through all of the available hosts and add them to the server browser\n                    foreach (MasterServerResponse.Server server in response.serverResponse)\n                    {\n                        Debug.Log(\nName: \n + server.Name);\n                        Debug.Log(\nAddress: \n + server.Address);\n                        Debug.Log(\nPort: \n + server.Port);\n                        Debug.Log(\nComment: \n + server.Comment);\n                        Debug.Log(\nType: \n + server.Type);\n                        Debug.Log(\nMode: \n + server.Mode);\n                        Debug.Log(\nPlayers: \n + server.Players);\n                        Debug.Log(\nMax Players: \n + server.MaxPlayers);\n                        Debug.Log(\nProtocol: \n + server.Protocol);\n\n                        // TODO:  Update UI or something with the above data\n                    }\n                }\n            }\n        }\n        finally\n        {\n            if (client != null)\n            {\n                // If we succeed or fail the client needs to disconnect from the Master Server\n                client.Disconnect(true);\n                client = null;\n            }\n        }\n    };\n\n    client.Connect(masterServerHost, (ushort)masterServerPort);\n}", 
            "title": "Getting host list"
        }, 
        {
            "location": "/MasterServer/getting-host-list/#getting-host-list-from-master-server", 
            "text": "If you have not already, we would suggest reviewing the  Master Server Quick Start  documentation to get familiar with the Master Server and to setup the stand alone executable and then reviewing  Connecting to Master Server  to learn how to register your game server on the master server.", 
            "title": "Getting Host List From Master Server"
        }, 
        {
            "location": "/MasterServer/getting-host-list/#request-stages", 
            "text": "There are a few stages when requesting the list of servers from the master server:   Connect to Master Server  Create a JSONNode request  Send the request to the server  Get response from the server  Parse response from server  Implement your code   (1) So the very first thing you have to do is to connect to the master server. We have created a helper class to get you doing this quickly:  // TODO:  This will be the address of the machine your master server is running on\nstring host =  127.0.0.1 ;\n\nushort port = 15937;\n\n// The Master Server communicates over TCP\nTCPMasterClient client = new TCPMasterClient();\n\n// Just call the connect method and you are ready to go\nclient.Connect(host, ort);  (2) Once your server is accepted (which you can use the  serverAccepted  event) you can create your request to the master server. The request is a JSONNode object that follows this structure:  {\n    get:\n    {\n        id:  myGame ,\n        type:  any ,\n        mode:  all \n    }\n}  You can do this with code similar to the following:  // The overall game id to select from\nstring gameId =  myGame ;\n\n// The game type to choose from, if  any  then all types will be returned\nstring gameType =  any ;\n\n// The game mode to choose from, if  all  then all game modes will be returned\nstring gameMode =  all ;\n\n// Create the get request with the desired filters\nJSONNode sendData = JSONNode.Parse( {} );\nJSONClass getData = new JSONClass();\n\n// The id of the game to get\ngetData.Add( id , gameId);\ngetData.Add( type , gameType);\ngetData.Add( mode , gameMode);\n\nsendData.Add( get , getData);  (3) Now that we have the json  sendData  we need to send it to the server. Since JSON can be a string representation, you can send it directly to the server as a  Text  frame in Forge:  // Send the request to the server\nclient.Send(Frame.Text.CreateFromString(client.Time.Timestep, sendData.ToString(), true, Receivers.Server, MessageGroupIds.MASTER_SERVER_GET, true));  (4) If you listen to the  textMessageReceived  event on the  client  object you will be able to capture the response from the server. This response will contain any errors (if any) and most importantly, your game list!  (5) Now that you have the JSON response from the server, you will need to parse it into the  MasterServerResponse  object. Lets imagine that your json response variable is called  data , then the code you will need to parse the response to this object is:  // Create a C# object for the response from the master server\nMasterServerResponse response = new MasterServerResponse(data[ hosts ].AsArray);  Note : If  data[\"hosts\"]  is null, then there was an error.  (6) Now that you have the  MasterServerResponse  object, you are ready to start writing your code for the UI and any other behaviors you want to execute based on the server listing.  foreach (MasterServerResponse.Server server in response.serverResponse)\n{\n    // TODO:  Do something with the server information here!\n}", 
            "title": "Request stages"
        }, 
        {
            "location": "/MasterServer/getting-host-list/#refresh-complete-sample", 
            "text": "Below is a compelte example of how to:   Connect to master server  Request the games list from the master server  Process the list of games returned from the master server  Disconnect from the master server   The below example can be used to refresh the current listings of hosts from the master server. Please be sure to read the comments within the code to better understand what is going on. It is also good to scroll up and reference the top of this page to see why and when things happen in this sample.  public void Refresh()\n{\n    // TODO:  Clear out any previously listed servers\n\n    // The Master Server communicates over TCP\n    TCPMasterClient client = new TCPMasterClient();\n\n    // Once this client has been accepted by the master server it should sent it's get request\n    client.serverAccepted += () = \n    {\n        try\n        {\n            // The overall game id to select from\n            string gameId =  myGame ;\n\n            // The game type to choose from, if  any  then all types will be returned\n            string gameType =  any ;\n\n            // The game mode to choose from, if  all  then all game modes will be returned\n            string gameMode =  all ;\n\n            // Create the get request with the desired filters\n            JSONNode sendData = JSONNode.Parse( {} );\n            JSONClass getData = new JSONClass();\n\n            // The id of the game to get\n            getData.Add( id , gameId);\n            getData.Add( type , gameType);\n            getData.Add( mode , gameMode);\n\n            sendData.Add( get , getData);\n\n            // Send the request to the server\n            client.Send(Frame.Text.CreateFromString(client.Time.Timestep, sendData.ToString(), true, Receivers.Server, MessageGroupIds.MASTER_SERVER_GET, true));\n        }\n        catch\n        {\n            // If anything fails, then this client needs to be disconnected\n            client.Disconnect(true);\n            client = null;\n        }\n    };\n\n    // An event that is raised when the server responds with hosts\n    client.textMessageReceived += (player, frame) = \n    {\n        try\n        {\n            // Get the list of hosts to iterate through from the frame payload\n            JSONNode data = JSONNode.Parse(frame.ToString());\n            if (data[ hosts ] != null)\n            {\n                // Create a C# object for the response from the master server\n                MasterServerResponse response = new MasterServerResponse(data[ hosts ].AsArray);\n\n                if (response != null   response.serverResponse.Count   0)\n                {\n                    // Go through all of the available hosts and add them to the server browser\n                    foreach (MasterServerResponse.Server server in response.serverResponse)\n                    {\n                        Debug.Log( Name:   + server.Name);\n                        Debug.Log( Address:   + server.Address);\n                        Debug.Log( Port:   + server.Port);\n                        Debug.Log( Comment:   + server.Comment);\n                        Debug.Log( Type:   + server.Type);\n                        Debug.Log( Mode:   + server.Mode);\n                        Debug.Log( Players:   + server.Players);\n                        Debug.Log( Max Players:   + server.MaxPlayers);\n                        Debug.Log( Protocol:   + server.Protocol);\n\n                        // TODO:  Update UI or something with the above data\n                    }\n                }\n            }\n        }\n        finally\n        {\n            if (client != null)\n            {\n                // If we succeed or fail the client needs to disconnect from the Master Server\n                client.Disconnect(true);\n                client = null;\n            }\n        }\n    };\n\n    client.Connect(masterServerHost, (ushort)masterServerPort);\n}", 
            "title": "Refresh Complete Sample"
        }, 
        {
            "location": "/MasterServer/windows-server-firewall-setup/", 
            "text": "Windows Server Firewall Setup\n\n\nSometimes images speak louder than words, so we've compiled a list of images to show you exactly what you need to do in order to allow the Master Server to work on your Windows Server either in your home or in the cloud!\n\n\nFirst you need to open your **Advanced Firewall Settings\"\n\n\n\n\nNext you need to select \nInbound Rules\n then select \nNew Rule...\n\n\n\n\nNext you will need to selec \nPort\n and then click \nNext\n\n\n\n\nNext, make sure that \nTCP\n is selected and that you enter the correct port number for your Master Server. The default port is \n15940\n. Then click \nNext\n\n\n\n\nNext you need to select \nAllow the connection\n. Click \nNext\n\n\n\n\nAfter that, just keep all the checkboxes at default (cheched). Click \nNext\n\n\n\n\nLastly give it a good name that is easy to find and click \nFinish\n\n\n\n\nDone\n\n\nThat is it, you should be ready to go. If you experience any other issues, make sure that your network firewall is allowing the connection to this machine and allowing the specified port number.", 
            "title": "Windows server firewall setup"
        }, 
        {
            "location": "/MasterServer/windows-server-firewall-setup/#windows-server-firewall-setup", 
            "text": "Sometimes images speak louder than words, so we've compiled a list of images to show you exactly what you need to do in order to allow the Master Server to work on your Windows Server either in your home or in the cloud!  First you need to open your **Advanced Firewall Settings\"   Next you need to select  Inbound Rules  then select  New Rule...   Next you will need to selec  Port  and then click  Next   Next, make sure that  TCP  is selected and that you enter the correct port number for your Master Server. The default port is  15940 . Then click  Next   Next you need to select  Allow the connection . Click  Next   After that, just keep all the checkboxes at default (cheched). Click  Next   Lastly give it a good name that is easy to find and click  Finish", 
            "title": "Windows Server Firewall Setup"
        }, 
        {
            "location": "/MasterServer/windows-server-firewall-setup/#done", 
            "text": "That is it, you should be ready to go. If you experience any other issues, make sure that your network firewall is allowing the connection to this machine and allowing the specified port number.", 
            "title": "Done"
        }, 
        {
            "location": "/WebServer/jumpstart/", 
            "text": "Web Server Jumpstart\n\n\nGetting up and running with the web server is easier than ever. Just include the plugin into your project, new up the object and start/stop the server at will. The namespace for the web server is \nBeardedManStudios.Forge.MVCWebServer\n, so if you need to include using statements or view things in the object browser, take a look in this namespace.\n\n\nIncluding plugin into project\n\n\nYou will notice a \nMVCWebServer.dll\n file in the unzipped folder for the web server. You just need to copy this file into your \nBearded Man Studios Inc/Plugins\n folder. That is it, you've installed the web server plugin to your project.\n\n\nStarting a Web Server\n\n\nStarting a web server is as simple as calling 2 lines of code as seen below.\n\n\nForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT);\nws.Start();\n\n\n\n\nI know what you are saying, \"what is server... and what are pages?\". Good questions; see below:\n- \nserver\n: This is the \nNetWorker\n for the server\n- \npages\n: This is a \nDictionary\nstring, string\n()\n of web pages (html). The key string is the name of the page, like \n\"index\"\n and the value is the html of the page. The pages you add here will be viewable from the web interface. So let's say you add a page \ncat\n and the html \nh1\nHello World\n/h1\n. Then if you went to \nlocahost:15942/cat\n in any web browser, you would see a big bold \nHello World\n heading on the page.\n\n\nWe have added a few default pages as part of the package in the \nResources\n folder. If you want a magical function that automatically maps all the pages you put into this folder, well... here you go:\n\n\nstring pathToFiles = \nfnwww/html\n;\nDictionary\nstring, string\n pages = new Dictionary\nstring, string\n();\nTextAsset[] assets = Resources.LoadAll\nTextAsset\n(pathToFiles);\nforeach (TextAsset a in assets)\n    pages.Add(a.name, a.text);\n\nForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT);\nws.Start();\n\n// ...\n\n\n\n\nStopping a Web Server\n\n\nWhen you are closing your connection/application that has a running web server, you will want to close the connection for the web server as well. You can see how to close the connection to the web server below:\n\n\nForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT);\nws.Start();\n\n// ...\n\nws.Stop();\n\n\n\n\nNotices \n Warnings!\n\n\nSTOP, BEFORE YOU LEAVE THIS PAGE!\n There are a few things to keep in mind when using the web server.\n1. If you disconnect your server, you \nMUST\n disconnect your web server as well. Since this is a plugin system, you need to remember to do this.\n2. You \nMUST\n remember to close the web server on application quit.\n3. The commands are run on a separate thread so you need to use \nMainThreadManager\n for any code that requires to be on the main thread", 
            "title": "Jumpstart"
        }, 
        {
            "location": "/WebServer/jumpstart/#web-server-jumpstart", 
            "text": "Getting up and running with the web server is easier than ever. Just include the plugin into your project, new up the object and start/stop the server at will. The namespace for the web server is  BeardedManStudios.Forge.MVCWebServer , so if you need to include using statements or view things in the object browser, take a look in this namespace.", 
            "title": "Web Server Jumpstart"
        }, 
        {
            "location": "/WebServer/jumpstart/#including-plugin-into-project", 
            "text": "You will notice a  MVCWebServer.dll  file in the unzipped folder for the web server. You just need to copy this file into your  Bearded Man Studios Inc/Plugins  folder. That is it, you've installed the web server plugin to your project.", 
            "title": "Including plugin into project"
        }, 
        {
            "location": "/WebServer/jumpstart/#starting-a-web-server", 
            "text": "Starting a web server is as simple as calling 2 lines of code as seen below.  ForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT);\nws.Start();  I know what you are saying, \"what is server... and what are pages?\". Good questions; see below:\n-  server : This is the  NetWorker  for the server\n-  pages : This is a  Dictionary string, string ()  of web pages (html). The key string is the name of the page, like  \"index\"  and the value is the html of the page. The pages you add here will be viewable from the web interface. So let's say you add a page  cat  and the html  h1 Hello World /h1 . Then if you went to  locahost:15942/cat  in any web browser, you would see a big bold  Hello World  heading on the page.  We have added a few default pages as part of the package in the  Resources  folder. If you want a magical function that automatically maps all the pages you put into this folder, well... here you go:  string pathToFiles =  fnwww/html ;\nDictionary string, string  pages = new Dictionary string, string ();\nTextAsset[] assets = Resources.LoadAll TextAsset (pathToFiles);\nforeach (TextAsset a in assets)\n    pages.Add(a.name, a.text);\n\nForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT);\nws.Start();\n\n// ...", 
            "title": "Starting a Web Server"
        }, 
        {
            "location": "/WebServer/jumpstart/#stopping-a-web-server", 
            "text": "When you are closing your connection/application that has a running web server, you will want to close the connection for the web server as well. You can see how to close the connection to the web server below:  ForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT);\nws.Start();\n\n// ...\n\nws.Stop();", 
            "title": "Stopping a Web Server"
        }, 
        {
            "location": "/WebServer/jumpstart/#notices-warnings", 
            "text": "STOP, BEFORE YOU LEAVE THIS PAGE!  There are a few things to keep in mind when using the web server.\n1. If you disconnect your server, you  MUST  disconnect your web server as well. Since this is a plugin system, you need to remember to do this.\n2. You  MUST  remember to close the web server on application quit.\n3. The commands are run on a separate thread so you need to use  MainThreadManager  for any code that requires to be on the main thread", 
            "title": "Notices &amp; Warnings!"
        }, 
        {
            "location": "/WebServer/extending-with-mvc/", 
            "text": "Web Server Extending With MVC\n\n\nYes, the web server is a full blown website in it's own right. Being this, you may want to add new controllers and views to the site. We'll start by making a controller named \"Test\". This will make it so that you can go to \nlocalhost:15942/test\n and have your own custom view processed and shown.\n\n\nOur custom \"Test\" controller\n\n\npublic class Test : PageController\n{\n    public Test(NetWorker socket, ForgeWebServer webserver)\n        : base(socket, webserver)\n    {\n        // Key string used in html like this: \n% print %\n\n        variables.Add(\nprint\n, Print);\n    }\n\n    public string Print()\n    {\n        return \nHELLO TEST STRING ACTION!\n;\n    }\n\n    public override string Render()\n    {\n        return PresentHTML(\ntest\n);\n    }\n}\n\n\n\n\nAs you can see from above, there are a lot of things going on, so we'll break them down one by one.\n1. You \nmust\n derive your new controller from the \nPageController\n class\n2. You \nmust\n create the constructor for your controller with the supplied input arguments\n3. You should add any model pulling functions inside the constructor to the variables\n4. You should create methods that are going to return the data needed for the variables\n5. You \nmust\n override the render method as it is abstract. This is where you return the HTML for your page. You can use the built in \nPresentHTML\n method you get from the parent class and pass in the name of your HTML page that will be presented.\n\n\nWhen you add callbacks assigned to a string to \nvariables\n as seen above with \nprint\n, you are making it so that you can use the \nstring\n response from those callbacks within your HTML page. See the \ntest.html\n example below to see how it is used in the \n% %\n tags.\n\n\nNow that you have your new controller, you are probably curious on how you can get it to be used while the web server is running. Below you will notice the line that has \nTryAddController\n which will try to add your new controller to the web server. Notice that all we have to do is new up the controller and pass it into this method.\n\n\nAdding your new controller\n\n\nForgeWebServer ws = new ForgeWebServer(server, 15942, dict);\nws.Start();\n\nws.TryAddController(new Test(server, ws));\n\n\n\n\nFinally, we are ready to create our view. A view is something that the controller will present to the user when they request your controllers web page. We will name this file \ntest.html\n because we are passing \ntest\n into the \nPresentHTML\n of our controller. If we were to name this html file \ncats\n then we would need to update the controller to pass \n\"cats\"\n into the \nPresentHTML\n method of the \nRender\n function.\n\n\nOur \"test.html\" view\n\n\nhtml\n\n\nhead\n\n    \ntitle\nMy Test Page\n/title\n\n\n/head\n\n\nbody\n\n    \nh1\nHello \n% print %\n/h1\n\n\n/body\n\n\n/html\n\n\n\n\n\nNote if you are not sure what the HTML page is, be sure to check out the \nJumpstart Guide\n\n\nDone\n\n\nThat's it, you have your fancy new controller and view and you can start using it immediately inside of your web server.", 
            "title": "Extending with mvc"
        }, 
        {
            "location": "/WebServer/extending-with-mvc/#web-server-extending-with-mvc", 
            "text": "Yes, the web server is a full blown website in it's own right. Being this, you may want to add new controllers and views to the site. We'll start by making a controller named \"Test\". This will make it so that you can go to  localhost:15942/test  and have your own custom view processed and shown.", 
            "title": "Web Server Extending With MVC"
        }, 
        {
            "location": "/WebServer/extending-with-mvc/#our-custom-test-controller", 
            "text": "public class Test : PageController\n{\n    public Test(NetWorker socket, ForgeWebServer webserver)\n        : base(socket, webserver)\n    {\n        // Key string used in html like this:  % print % \n        variables.Add( print , Print);\n    }\n\n    public string Print()\n    {\n        return  HELLO TEST STRING ACTION! ;\n    }\n\n    public override string Render()\n    {\n        return PresentHTML( test );\n    }\n}  As you can see from above, there are a lot of things going on, so we'll break them down one by one.\n1. You  must  derive your new controller from the  PageController  class\n2. You  must  create the constructor for your controller with the supplied input arguments\n3. You should add any model pulling functions inside the constructor to the variables\n4. You should create methods that are going to return the data needed for the variables\n5. You  must  override the render method as it is abstract. This is where you return the HTML for your page. You can use the built in  PresentHTML  method you get from the parent class and pass in the name of your HTML page that will be presented.  When you add callbacks assigned to a string to  variables  as seen above with  print , you are making it so that you can use the  string  response from those callbacks within your HTML page. See the  test.html  example below to see how it is used in the  % %  tags.  Now that you have your new controller, you are probably curious on how you can get it to be used while the web server is running. Below you will notice the line that has  TryAddController  which will try to add your new controller to the web server. Notice that all we have to do is new up the controller and pass it into this method.", 
            "title": "Our custom \"Test\" controller"
        }, 
        {
            "location": "/WebServer/extending-with-mvc/#adding-your-new-controller", 
            "text": "ForgeWebServer ws = new ForgeWebServer(server, 15942, dict);\nws.Start();\n\nws.TryAddController(new Test(server, ws));  Finally, we are ready to create our view. A view is something that the controller will present to the user when they request your controllers web page. We will name this file  test.html  because we are passing  test  into the  PresentHTML  of our controller. If we were to name this html file  cats  then we would need to update the controller to pass  \"cats\"  into the  PresentHTML  method of the  Render  function.", 
            "title": "Adding your new controller"
        }, 
        {
            "location": "/WebServer/extending-with-mvc/#our-testhtml-view", 
            "text": "html  head \n     title My Test Page /title  /head  body \n     h1 Hello  % print % /h1  /body  /html   Note if you are not sure what the HTML page is, be sure to check out the  Jumpstart Guide", 
            "title": "Our \"test.html\" view"
        }, 
        {
            "location": "/WebServer/extending-with-mvc/#done", 
            "text": "That's it, you have your fancy new controller and view and you can start using it immediately inside of your web server.", 
            "title": "Done"
        }, 
        {
            "location": "/WebServer/command-plugins/", 
            "text": "Web Server Command Plugins\n\n\nAs you know by now, the webserver comes with a fancy console which allows you to type in commands and execute some logic on your server. One thing that we thought would be needed is for you to have the ability to create your own commands.\n\n\nCreate the plugin class\n\n\nWhen creating a plugin for the webserver, you will need to derive from the \nICommandPlugin\n interface which is in the \nBeardedManStudios.Forge.MVCWebServer.Plugins\n namespace, so be sure to add it to your using statements. Below you will see a code example of a plugin. This plugin must have the \nExecute\n method and it must return a \nstring\n as well as take in a \nstring[]\n of commands. If you typed into the command box \ntesting brent farris\n the output would be \nHello Brent!\n. However if you typed in \ntesting \"Brent Farris\"\n the output would be \nHello Brent Farris!\n. As you can see, the quotes will group parts of the command together. Lastly, parameters are not required (because of how we wrote our class) so \ntesting\n by itself will respond with \nHELLO!\n.\n\n\npublic class TestingPlugin : ICommandPlugin\n{\n    public string Execute(string[] commands)\n    {\n        if (commands == null || commands.Length == 0)\n            return \nHELLO!\n;\n\n        return \nHello \n + commands[0] + \n!\n;\n    }\n}\n\n\n\n\nAdd our plugin\n\n\nAdding a plugin is very easy, let's say you have a web server running, all you need to do is call the \nTryAddPlugin\n method. Below is a couple examples of this in action.\n\n\nWithout help strings\n\n\nForgeWebServer ws = new ForgeWebServer(server, 15942, dict);\nws.Start();\n\nws.TryAddPlugin(\ntesting\n, new TestingPlugin());\n\n\n\n\nWith help strings\n\n\nForgeWebServer ws = new ForgeWebServer(server, 15942, dict);\nws.Start();\n\nws.TryAddPlugin(\ntesting\n, new TestingPlugin(), \nDo a test log\n, \ntesting brent\n, \narg1\n, \narg2\n, \narg3\n, \n...\n);\n\n\n\n\nWhen you supply help strings, then when you type \nhelp\n into the command box, it will print out the help messages to let the user know what the command does and what arguments it expects.\n\n\nDone\n\n\nWell that is it, once you create the command class and implement the \nICommandPlugin\n interface, then do a call to \nTryAddPlugin\n with your plugin class, then you are ready to start using the command in the web browser.\n\n\nNotes\n\n\nYou can create and add plugins to your web server at any time in your code. So you can potentially create commands to spawn objects, kill player characters, render a cube for no reason, pretty much anything you can imagine.", 
            "title": "Command plugins"
        }, 
        {
            "location": "/WebServer/command-plugins/#web-server-command-plugins", 
            "text": "As you know by now, the webserver comes with a fancy console which allows you to type in commands and execute some logic on your server. One thing that we thought would be needed is for you to have the ability to create your own commands.", 
            "title": "Web Server Command Plugins"
        }, 
        {
            "location": "/WebServer/command-plugins/#create-the-plugin-class", 
            "text": "When creating a plugin for the webserver, you will need to derive from the  ICommandPlugin  interface which is in the  BeardedManStudios.Forge.MVCWebServer.Plugins  namespace, so be sure to add it to your using statements. Below you will see a code example of a plugin. This plugin must have the  Execute  method and it must return a  string  as well as take in a  string[]  of commands. If you typed into the command box  testing brent farris  the output would be  Hello Brent! . However if you typed in  testing \"Brent Farris\"  the output would be  Hello Brent Farris! . As you can see, the quotes will group parts of the command together. Lastly, parameters are not required (because of how we wrote our class) so  testing  by itself will respond with  HELLO! .  public class TestingPlugin : ICommandPlugin\n{\n    public string Execute(string[] commands)\n    {\n        if (commands == null || commands.Length == 0)\n            return  HELLO! ;\n\n        return  Hello   + commands[0] +  ! ;\n    }\n}", 
            "title": "Create the plugin class"
        }, 
        {
            "location": "/WebServer/command-plugins/#add-our-plugin", 
            "text": "Adding a plugin is very easy, let's say you have a web server running, all you need to do is call the  TryAddPlugin  method. Below is a couple examples of this in action.", 
            "title": "Add our plugin"
        }, 
        {
            "location": "/WebServer/command-plugins/#without-help-strings", 
            "text": "ForgeWebServer ws = new ForgeWebServer(server, 15942, dict);\nws.Start();\n\nws.TryAddPlugin( testing , new TestingPlugin());", 
            "title": "Without help strings"
        }, 
        {
            "location": "/WebServer/command-plugins/#with-help-strings", 
            "text": "ForgeWebServer ws = new ForgeWebServer(server, 15942, dict);\nws.Start();\n\nws.TryAddPlugin( testing , new TestingPlugin(),  Do a test log ,  testing brent ,  arg1 ,  arg2 ,  arg3 ,  ... );  When you supply help strings, then when you type  help  into the command box, it will print out the help messages to let the user know what the command does and what arguments it expects.", 
            "title": "With help strings"
        }, 
        {
            "location": "/WebServer/command-plugins/#done", 
            "text": "Well that is it, once you create the command class and implement the  ICommandPlugin  interface, then do a call to  TryAddPlugin  with your plugin class, then you are ready to start using the command in the web browser.", 
            "title": "Done"
        }, 
        {
            "location": "/WebServer/command-plugins/#notes", 
            "text": "You can create and add plugins to your web server at any time in your code. So you can potentially create commands to spawn objects, kill player characters, render a cube for no reason, pretty much anything you can imagine.", 
            "title": "Notes"
        }, 
        {
            "location": "/Troubleshooting/troubleshooting/", 
            "text": "Troubleshooting\n\n\nNetwork Issues\n\n\nIf you are having trouble setting up your network, or you are having trouble connecting your game, please review this page and follow the steps completely. There are many stages of network communication that you can troubleshoot to test your game. In this document we will go over the various steps to troubleshooting so that you can figure out what could be wrong with the setup on your machine, local network, or internet connections.\n\n\nThe Local Machine\n\n\nThe primary method of testing your game will most likely be on a single machine which is often your development machine. The addresses \n127.0.0.1\n, \nlocalhost\n, \n::0\n, etc. are all references to the machine you are currently on. These addresses are used for local testing, routing, security, and other probably less common practices.\n\n\nSteps to test:\n1. Turn on \"Run in Background\" in Unity Player Settings\n2. Set the Multiplayer Menu scene as the first scene\n3. Use the CubeForge demo scene as the second scene\n4. Build your game from Unity\n5. Run 1 instance of your build and play the other instance in the Unity Editor\n6. Press play in the Editor\n7. Host a server in the Editor on port \n15937\n\n8. Run the built instance of the application\n9. Connect to IP address \n127.0.0.1\n and port number \n15937\n on the built instance\n\n\nIf you can connect, \nCONGRATULATIONS\n, your game is properly networked and your machine is properly setup to test your game on the local machine. If you are having trouble with this stage, please ensure that you are properly following the steps above and building the instance.\n\n\nThe Local Area Network (LAN)\n\n\nIf the local machine setup above is working correctly and your local area network (LAN) is not, chances are there is an issue with your network or machine firewall. Follow the above steps except run the instance of the game that was built on another machine on your network. We will refer to the machine that the Unity Editor (server) is on as \nServer\n and the second machine that is on the network which is running the built instance \nClient\n.\n\n\n\n\nHost the server on \nServer\n\n\nTry to connect using \nClient\n\n\n\n\nIf the above steps fail to connect and play the game, you have 1 or more of the following problems with your network setup.\n\n\n\n\nYour machine firewall on \nServer\n is not allowing the connections\n\n\nYour machines are not on the same network\n\n\nYou are not supplying the correct IP address or Port number\n\n\n\n\n# Issue 1 Resolution\n\n\nFirst, let's find out if your issue is the one listed as #1. Open your firewall settings on your local machine, locate the Unity Editor in the firewall settings and make sure it is allowing connections. If you are not sure how to check or change your firewall settings, please reference Google to learn the steps for your operating system.\n\n\nNOTE\n: If you are not hosting in the Unity Editor, these same steps would apply to the build game, you just need to locate the game name in the firewall settings. If it is not found, you need to add the exception to your machine firewall with the same steps as mentioned above.\n\n\n# Issue 2 Resolution\n\n\nFor (#2) you are going to have to make sure that the two machines are on the same exact network. You can do this by making sure that the router name (when connecting) is the same for both machines (when connecting via Wi-Fi). If you are using a Ethernet cable, make sure that both cables for both machines are leading into the same router. If you are using Ethernet for one machine and Wi-Fi for another machine, make sure that the Wi-Fi connected machine is connecting to the same router name as the machine that has the Ethernet cord connected to the router.\n\n\n# Issue 3 Resolution\n\n\nWhen connecting to \nServer\n, you are required to input the correct IP address. For the \nServer\n machine, you should be hosting on 0.0.0.0 for this test; if you are not sure what that means, then you are already set to that and do not need to worry about it as you've not set it explicitly yourself.\n\n\nFirst, you need to open the network configuration on \nServer\n. You can do this by opening a \ncommand prompt\n or a \nterminal\n window. The following is the command that you would input onto a \nWindows Command Prompt\n window to find your local area networks IP address.\n\n\nipconfig\n\n\n\n\nThe following is the command that you would input onto a \nMacOS/Linux Terminal\n window to find your local area networks IP address.\n\n\nifconfig\n\n\n\n\nLocate the LAN that you are connected to and find the IPv4 address that is assigned to the \nServer\n. This is the IP address that you need to input into your \nClient\n for the host address. The port number should still be \n15937\n as mentioned in the previous example.\n\n\nNOTE\n: If you use machine virtualization (VM or Virtual Machine's) then there may be multiple network IPv4 addresses when you enter the above command. This is also the case if you using both Ethernet and Wi-Fi, so please be sure to select the correct network address. Usually the name showed in the listings is indicative to the connection type.\n\n\nThe Internet \n Cloud Servers\n\n\nChances are that if the above are working perfectly, then there are one of two things that could not be working for you.\n\n\n1) The server machine's firewall is not opened for the application. Please see \nthe above\n on how to fix this\nor\n2) The network firewlal settings are not allowing the port\n\n\nFor #2 you will need to review with your cloud hosting provider on how to open the ports for your application/machine. This is done differently through each provider but should be an easy \nGoogle Search\n away from finding out. Let's say that you are hosting through Microsoft Azure, you would search Google as follows:\n\n\nAzure open network ports\n\n\n\n\nor\n\n\nAzure open ports and endpoints\n\n\n\n\nThese queries should produce some fine results. \nMAKE SURE\n to replace \"Azure\" with your cloud hosting provider, like \"EC2\" or \"Rackspace\".", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/Troubleshooting/troubleshooting/#troubleshooting", 
            "text": "", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/Troubleshooting/troubleshooting/#network-issues", 
            "text": "If you are having trouble setting up your network, or you are having trouble connecting your game, please review this page and follow the steps completely. There are many stages of network communication that you can troubleshoot to test your game. In this document we will go over the various steps to troubleshooting so that you can figure out what could be wrong with the setup on your machine, local network, or internet connections.", 
            "title": "Network Issues"
        }, 
        {
            "location": "/Troubleshooting/troubleshooting/#the-local-machine", 
            "text": "The primary method of testing your game will most likely be on a single machine which is often your development machine. The addresses  127.0.0.1 ,  localhost ,  ::0 , etc. are all references to the machine you are currently on. These addresses are used for local testing, routing, security, and other probably less common practices.  Steps to test:\n1. Turn on \"Run in Background\" in Unity Player Settings\n2. Set the Multiplayer Menu scene as the first scene\n3. Use the CubeForge demo scene as the second scene\n4. Build your game from Unity\n5. Run 1 instance of your build and play the other instance in the Unity Editor\n6. Press play in the Editor\n7. Host a server in the Editor on port  15937 \n8. Run the built instance of the application\n9. Connect to IP address  127.0.0.1  and port number  15937  on the built instance  If you can connect,  CONGRATULATIONS , your game is properly networked and your machine is properly setup to test your game on the local machine. If you are having trouble with this stage, please ensure that you are properly following the steps above and building the instance.", 
            "title": "The Local Machine"
        }, 
        {
            "location": "/Troubleshooting/troubleshooting/#the-local-area-network-lan", 
            "text": "If the local machine setup above is working correctly and your local area network (LAN) is not, chances are there is an issue with your network or machine firewall. Follow the above steps except run the instance of the game that was built on another machine on your network. We will refer to the machine that the Unity Editor (server) is on as  Server  and the second machine that is on the network which is running the built instance  Client .   Host the server on  Server  Try to connect using  Client   If the above steps fail to connect and play the game, you have 1 or more of the following problems with your network setup.   Your machine firewall on  Server  is not allowing the connections  Your machines are not on the same network  You are not supplying the correct IP address or Port number", 
            "title": "The Local Area Network (LAN)"
        }, 
        {
            "location": "/Troubleshooting/troubleshooting/#issue-1-resolution", 
            "text": "First, let's find out if your issue is the one listed as #1. Open your firewall settings on your local machine, locate the Unity Editor in the firewall settings and make sure it is allowing connections. If you are not sure how to check or change your firewall settings, please reference Google to learn the steps for your operating system.  NOTE : If you are not hosting in the Unity Editor, these same steps would apply to the build game, you just need to locate the game name in the firewall settings. If it is not found, you need to add the exception to your machine firewall with the same steps as mentioned above.", 
            "title": "# Issue 1 Resolution"
        }, 
        {
            "location": "/Troubleshooting/troubleshooting/#issue-2-resolution", 
            "text": "For (#2) you are going to have to make sure that the two machines are on the same exact network. You can do this by making sure that the router name (when connecting) is the same for both machines (when connecting via Wi-Fi). If you are using a Ethernet cable, make sure that both cables for both machines are leading into the same router. If you are using Ethernet for one machine and Wi-Fi for another machine, make sure that the Wi-Fi connected machine is connecting to the same router name as the machine that has the Ethernet cord connected to the router.", 
            "title": "# Issue 2 Resolution"
        }, 
        {
            "location": "/Troubleshooting/troubleshooting/#issue-3-resolution", 
            "text": "When connecting to  Server , you are required to input the correct IP address. For the  Server  machine, you should be hosting on 0.0.0.0 for this test; if you are not sure what that means, then you are already set to that and do not need to worry about it as you've not set it explicitly yourself.  First, you need to open the network configuration on  Server . You can do this by opening a  command prompt  or a  terminal  window. The following is the command that you would input onto a  Windows Command Prompt  window to find your local area networks IP address.  ipconfig  The following is the command that you would input onto a  MacOS/Linux Terminal  window to find your local area networks IP address.  ifconfig  Locate the LAN that you are connected to and find the IPv4 address that is assigned to the  Server . This is the IP address that you need to input into your  Client  for the host address. The port number should still be  15937  as mentioned in the previous example.  NOTE : If you use machine virtualization (VM or Virtual Machine's) then there may be multiple network IPv4 addresses when you enter the above command. This is also the case if you using both Ethernet and Wi-Fi, so please be sure to select the correct network address. Usually the name showed in the listings is indicative to the connection type.", 
            "title": "# Issue 3 Resolution"
        }, 
        {
            "location": "/Troubleshooting/troubleshooting/#the-internet-cloud-servers", 
            "text": "Chances are that if the above are working perfectly, then there are one of two things that could not be working for you.  1) The server machine's firewall is not opened for the application. Please see  the above  on how to fix this\nor\n2) The network firewlal settings are not allowing the port  For #2 you will need to review with your cloud hosting provider on how to open the ports for your application/machine. This is done differently through each provider but should be an easy  Google Search  away from finding out. Let's say that you are hosting through Microsoft Azure, you would search Google as follows:  Azure open network ports  or  Azure open ports and endpoints  These queries should produce some fine results.  MAKE SURE  to replace \"Azure\" with your cloud hosting provider, like \"EC2\" or \"Rackspace\".", 
            "title": "The Internet &amp; Cloud Servers"
        }, 
        {
            "location": "/Troubleshooting/throttling-network-internal/", 
            "text": "Throttling Network Internal\n\n\nSo there are many tools out there to download and use to test applications and the general stability of networks, however we wanted to go over some quick and easy ways that you can test the network using just Forge Networking.\n\n\nNetwork Latency Simulation\n\n\nThe network latency simulation lets you test how your code would behave if there were to be network latency. This is a very simple tool that makes it so that the core of Forge will delay the reading/sending of messages by the given milliseconds. This is useful to test and see how clients with slow networks will experience your game. The latency simulation is \nper NetWorker\n so to test this out quickly you can use \nNetworkManager.Instance.Networker\n. Below is a sample of how to set the latency to 900 milliseconds (0.9 seconds):\n\n\n// Somewhere in code, even during runtime\nNetworkManager.Instance.Networker.LatencySimulation = 900;  // 900 is the time in milliseconds\n\n\n\n\nPacket Loss Simulation\n\n\nThe packet loss simulation lets you test how your code would behave if there were to be packet loss of a specific chance. This tool allows you to set a percentage of packet loss. What this does internally is generate a random number, if it is within the specified percantage then it will delete the packet and ignore reading it. This will allow you to test your code to see what would happen if you were to lose packets during gameplay. The packet loss simulation is \nper NetWorker\n so to test this out quickly you can use \nNetworkManager.Instance.Networker\n. Below is a sample of how to set the percentage to 0.1f (10% packet loss chance):\n\n\n// Somewhere in code, even during runtime\nNetworkManager.Instance.Networker.PacketLossSimulation = 0.1f;  // 0.1f is the percentage chance of packet loss (10% in this case)", 
            "title": "Throttling network internal"
        }, 
        {
            "location": "/Troubleshooting/throttling-network-internal/#throttling-network-internal", 
            "text": "So there are many tools out there to download and use to test applications and the general stability of networks, however we wanted to go over some quick and easy ways that you can test the network using just Forge Networking.", 
            "title": "Throttling Network Internal"
        }, 
        {
            "location": "/Troubleshooting/throttling-network-internal/#network-latency-simulation", 
            "text": "The network latency simulation lets you test how your code would behave if there were to be network latency. This is a very simple tool that makes it so that the core of Forge will delay the reading/sending of messages by the given milliseconds. This is useful to test and see how clients with slow networks will experience your game. The latency simulation is  per NetWorker  so to test this out quickly you can use  NetworkManager.Instance.Networker . Below is a sample of how to set the latency to 900 milliseconds (0.9 seconds):  // Somewhere in code, even during runtime\nNetworkManager.Instance.Networker.LatencySimulation = 900;  // 900 is the time in milliseconds", 
            "title": "Network Latency Simulation"
        }, 
        {
            "location": "/Troubleshooting/throttling-network-internal/#packet-loss-simulation", 
            "text": "The packet loss simulation lets you test how your code would behave if there were to be packet loss of a specific chance. This tool allows you to set a percentage of packet loss. What this does internally is generate a random number, if it is within the specified percantage then it will delete the packet and ignore reading it. This will allow you to test your code to see what would happen if you were to lose packets during gameplay. The packet loss simulation is  per NetWorker  so to test this out quickly you can use  NetworkManager.Instance.Networker . Below is a sample of how to set the percentage to 0.1f (10% packet loss chance):  // Somewhere in code, even during runtime\nNetworkManager.Instance.Networker.PacketLossSimulation = 0.1f;  // 0.1f is the percentage chance of packet loss (10% in this case)", 
            "title": "Packet Loss Simulation"
        }, 
        {
            "location": "/connection-cycle-events/", 
            "text": "Connection Cycle Events\n\n\nBelow are a quick explaination of the various events that happen during the connection and acceptance cycles on both the server and the client.\n\n\nServer \n Client Events\n\n\nThe below are events that are local-aware, that is to say that they are called without any need for an active connection.\n\n\nbindSuccessful\n\n\nCalled when the local machine allowed the binding of the port requested.\n\n\nbindFailure\n\n\nCalled when the local machine rejected the binding of the port requested.\n\n\ndisconnected\n\n\nCalled when the local machine has completely disconnected from any communications in the Forge life cycle\n\n\nServer Events\n\n\nThe following events are called on the \nserver only\n based on the behavior of clients connecting or disconnecting.\n\n\nplayerConnected\n\n\nCalled when a player has successfully connected with the server. This player \nCAN\n be rejected by the server, so this event is mainly useful for evaluation of the player or preparing anything you need for the player. You should not be communicating with the player at all until they have been accepted.\n\n\nplayerGuidAssigned\n\n\nThis event is called once the server has gotten the unique guid for a player. This triggers just before the accepted message and is useful to prepare any network player lookups.\n\n\nplayerAccepted\n\n\nFired when the player has been officially accepted by the server and now is the time you are able to start sending your messages to this player.\n\n\nplayerRejected\n\n\nFired when a player has been rejected for any reason by the server. This event will be expanded later but currenlty is used for when a client has sent invalid connection headers.\n\n\nplayerTimeout\n\n\nCalled when a player has timed out on the server. This happens after they have been accepted and if the server hasn't receieved any message (ping or otherwise) from the specified client. The timeout time (in milliseconds) for a player can be found/set in the \nNetworkingPlayer::TimeoutMilliseconds\n property.\n\n\nplayerDisconnected\n\n\nCalled at any time that a player has disconnected on its own or by the server.\n\n\nClient Events\n\n\nThe following events are called on the client only and deal with the various connection events that relate to this client and the server.\n\n\nserverAccepted\n\n\nCalled whenever the server has accepted this client. At this point it is safe to start sending messages to the server and to know it is a live connection.", 
            "title": "Events"
        }, 
        {
            "location": "/connection-cycle-events/#connection-cycle-events", 
            "text": "Below are a quick explaination of the various events that happen during the connection and acceptance cycles on both the server and the client.", 
            "title": "Connection Cycle Events"
        }, 
        {
            "location": "/connection-cycle-events/#server-client-events", 
            "text": "The below are events that are local-aware, that is to say that they are called without any need for an active connection.", 
            "title": "Server &amp; Client Events"
        }, 
        {
            "location": "/connection-cycle-events/#bindsuccessful", 
            "text": "Called when the local machine allowed the binding of the port requested.", 
            "title": "bindSuccessful"
        }, 
        {
            "location": "/connection-cycle-events/#bindfailure", 
            "text": "Called when the local machine rejected the binding of the port requested.", 
            "title": "bindFailure"
        }, 
        {
            "location": "/connection-cycle-events/#disconnected", 
            "text": "Called when the local machine has completely disconnected from any communications in the Forge life cycle", 
            "title": "disconnected"
        }, 
        {
            "location": "/connection-cycle-events/#server-events", 
            "text": "The following events are called on the  server only  based on the behavior of clients connecting or disconnecting.", 
            "title": "Server Events"
        }, 
        {
            "location": "/connection-cycle-events/#playerconnected", 
            "text": "Called when a player has successfully connected with the server. This player  CAN  be rejected by the server, so this event is mainly useful for evaluation of the player or preparing anything you need for the player. You should not be communicating with the player at all until they have been accepted.", 
            "title": "playerConnected"
        }, 
        {
            "location": "/connection-cycle-events/#playerguidassigned", 
            "text": "This event is called once the server has gotten the unique guid for a player. This triggers just before the accepted message and is useful to prepare any network player lookups.", 
            "title": "playerGuidAssigned"
        }, 
        {
            "location": "/connection-cycle-events/#playeraccepted", 
            "text": "Fired when the player has been officially accepted by the server and now is the time you are able to start sending your messages to this player.", 
            "title": "playerAccepted"
        }, 
        {
            "location": "/connection-cycle-events/#playerrejected", 
            "text": "Fired when a player has been rejected for any reason by the server. This event will be expanded later but currenlty is used for when a client has sent invalid connection headers.", 
            "title": "playerRejected"
        }, 
        {
            "location": "/connection-cycle-events/#playertimeout", 
            "text": "Called when a player has timed out on the server. This happens after they have been accepted and if the server hasn't receieved any message (ping or otherwise) from the specified client. The timeout time (in milliseconds) for a player can be found/set in the  NetworkingPlayer::TimeoutMilliseconds  property.", 
            "title": "playerTimeout"
        }, 
        {
            "location": "/connection-cycle-events/#playerdisconnected", 
            "text": "Called at any time that a player has disconnected on its own or by the server.", 
            "title": "playerDisconnected"
        }, 
        {
            "location": "/connection-cycle-events/#client-events", 
            "text": "The following events are called on the client only and deal with the various connection events that relate to this client and the server.", 
            "title": "Client Events"
        }, 
        {
            "location": "/connection-cycle-events/#serveraccepted", 
            "text": "Called whenever the server has accepted this client. At this point it is safe to start sending messages to the server and to know it is a live connection.", 
            "title": "serverAccepted"
        }, 
        {
            "location": "/rewinding/", 
            "text": "Rewinding\n\n\nRewinding is a method in which you can go back in \"time\" and look at what the value of a variable was at/around a specific timestep. The \nRewind\n data structure is a pretty simple structure that allows you to do rewinding however you would like. Since you are able to get the Timestep at any point in your code through the use of \nNetworkManager.Instance.NetWorker.Time.Timestep\n, you can easily store anything into the structure that you need. Below is an example showing you how to get started with rewinding in a practical way.\n\n\n\n\nCreate a C# file in your project\n\n\nName the file \nRewindTest.cs\n\n\nOpen the file and paste the code following these steps\n\n\nCreate a new scene\n\n\nPlace a cube in the scene\n\n\nAttach the \nRewindTeste.cs\n script to the cube\n\n\nAttach a \nRigidbody\n component to the cube\n\n\nSave the scene as \nRewindTest\n\n\nOpen the Multiplayer Menu sample scene\n\n\nOpen the build settings\n\n\nClick the \nPlayer Settings...\n button\n\n\nMake sure \nRun in Background\n is turned on\n\n\nAdd the Multiplayer Menu Scene as scene (index 0) to the build settings\n\n\nAdd the \nRewindTest\n scene as the second scene (index 1) to the build settings\n\n\nPress play\n\n\nHost a game\n\n\nWait a second or two\n\n\nPress the spacebar\n\n\nCheck the \nGET\n message and what time it was at\n\n\nCheck the \nSET\n message with the closest time to that seen in the get message and you will notice they are a match\n\n\n\n\nusing BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Unity;\nusing System.Collections;\nusing UnityEngine;\n\npublic class RewindTest : MonoBehaviour\n{\n    private Rewind\nVector3\n rewind;\n\n    private void Start()\n    {\n        rewind = new Rewind\nVector3\n(5000);\n        StartCoroutine(Store());\n    }\n\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            var timestep = NetworkManager.Instance.Networker.Time.Timestep - 1000;\n            Debug.Log(\nGET: \n + timestep + \n | \n + rewind.Get(timestep));\n            UnityEditor.EditorApplication.isPaused = true;\n        }\n    }\n\n    private IEnumerator Store()\n    {\n        for (;;)\n        {\n            var timestep = NetworkManager.Instance.Networker.Time.Timestep;\n            rewind.Register(transform.position, timestep);\n            Debug.Log(\nSET: \n + timestep + \n | \n + transform.position);\n            yield return new WaitForSeconds(0.5f);\n        }\n    }\n}\n\n\n\n\nDeeper Dive\n\n\nYou will notice in the above example we do \nrewind = new Rewind\nVector3\n(5000);\n. The \n5000\n in this case is the number of milliseconds to track data. Anything older than 5 seconds from now will be removed for memory constraint purposes. You can put whatever time frame you want here, 5000 may be a bit much (because 5000ms is 5 seconds which is a very long time). The \nVector3\n is the type of data that we are storing into this rewinding structure.\n\n\nNext you will notice the \nrewind.Register(transform.position, timestep);\n call. This will save the value of \ntransform.position\n to the rewind history at the provided \nulong\n \ntimestep\n. This adds to the pool of stored data for this specific verable for you to pull from. \nNote\n It is not good practice to \nRegister\n different \nVector3\n addresses, so if we are using \nrewind\n for \ntransform.position\n we should only pass \ntransform.position\n into this variable's \nRegister\n method.\n\n\nLastly we come to the most important action we can do \nrewind.Get(timestep)\n. There are many different overloads for getting the values near and around a timestep however the simplest method to call is \nGet\n. So let's say you \nRegister\n a value \nA\n at timestep \n3\n and a value \nB\n at timestep \n20\n. If you were to call \nGet(10)\n then you will get value \nA\n returned, however if you called \nGet(19)\n you would get the value \nB\n. This is because the value closest to the sent timestamp would be returned.\n\n\nOther Get Methods\n\n\nList\nT\n Get(ulong timestep, out T lower, out T upper)\n - If we were following the above example and we passed \nGet(10, out lower, out upper)\n into this method, then \nlower\n would equal \n3\n, \nupper\n would equal \n20\n and the returned value will be \n3\n. This method is useful for if you want to calculate a median or where the value might possibly be between the two values.\n\n\nList\nT\n GetRange(ulong timestep, int count)\n - This method will act exactly like the first \nGet\n method we learned about in the \nDeeper Dive\n section above; however, it also will return \nn\n values before the given timestep. So if we passed in \n3\n for the \ncount\n then we would get a list of values back where the first element is the target value for that timestep and every element after that is the value stored at the last timestep registered.\n\n\nT GetRange(ulong timestepMin, ulong timestepMax)\n - This method allows you to get all values between two timesteps (including the min and the max).", 
            "title": "Rewinding"
        }, 
        {
            "location": "/rewinding/#rewinding", 
            "text": "Rewinding is a method in which you can go back in \"time\" and look at what the value of a variable was at/around a specific timestep. The  Rewind  data structure is a pretty simple structure that allows you to do rewinding however you would like. Since you are able to get the Timestep at any point in your code through the use of  NetworkManager.Instance.NetWorker.Time.Timestep , you can easily store anything into the structure that you need. Below is an example showing you how to get started with rewinding in a practical way.   Create a C# file in your project  Name the file  RewindTest.cs  Open the file and paste the code following these steps  Create a new scene  Place a cube in the scene  Attach the  RewindTeste.cs  script to the cube  Attach a  Rigidbody  component to the cube  Save the scene as  RewindTest  Open the Multiplayer Menu sample scene  Open the build settings  Click the  Player Settings...  button  Make sure  Run in Background  is turned on  Add the Multiplayer Menu Scene as scene (index 0) to the build settings  Add the  RewindTest  scene as the second scene (index 1) to the build settings  Press play  Host a game  Wait a second or two  Press the spacebar  Check the  GET  message and what time it was at  Check the  SET  message with the closest time to that seen in the get message and you will notice they are a match   using BeardedManStudios.Forge.Networking;\nusing BeardedManStudios.Forge.Networking.Unity;\nusing System.Collections;\nusing UnityEngine;\n\npublic class RewindTest : MonoBehaviour\n{\n    private Rewind Vector3  rewind;\n\n    private void Start()\n    {\n        rewind = new Rewind Vector3 (5000);\n        StartCoroutine(Store());\n    }\n\n    private void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            var timestep = NetworkManager.Instance.Networker.Time.Timestep - 1000;\n            Debug.Log( GET:   + timestep +   |   + rewind.Get(timestep));\n            UnityEditor.EditorApplication.isPaused = true;\n        }\n    }\n\n    private IEnumerator Store()\n    {\n        for (;;)\n        {\n            var timestep = NetworkManager.Instance.Networker.Time.Timestep;\n            rewind.Register(transform.position, timestep);\n            Debug.Log( SET:   + timestep +   |   + transform.position);\n            yield return new WaitForSeconds(0.5f);\n        }\n    }\n}", 
            "title": "Rewinding"
        }, 
        {
            "location": "/rewinding/#deeper-dive", 
            "text": "You will notice in the above example we do  rewind = new Rewind Vector3 (5000); . The  5000  in this case is the number of milliseconds to track data. Anything older than 5 seconds from now will be removed for memory constraint purposes. You can put whatever time frame you want here, 5000 may be a bit much (because 5000ms is 5 seconds which is a very long time). The  Vector3  is the type of data that we are storing into this rewinding structure.  Next you will notice the  rewind.Register(transform.position, timestep);  call. This will save the value of  transform.position  to the rewind history at the provided  ulong   timestep . This adds to the pool of stored data for this specific verable for you to pull from.  Note  It is not good practice to  Register  different  Vector3  addresses, so if we are using  rewind  for  transform.position  we should only pass  transform.position  into this variable's  Register  method.  Lastly we come to the most important action we can do  rewind.Get(timestep) . There are many different overloads for getting the values near and around a timestep however the simplest method to call is  Get . So let's say you  Register  a value  A  at timestep  3  and a value  B  at timestep  20 . If you were to call  Get(10)  then you will get value  A  returned, however if you called  Get(19)  you would get the value  B . This is because the value closest to the sent timestamp would be returned.", 
            "title": "Deeper Dive"
        }, 
        {
            "location": "/rewinding/#other-get-methods", 
            "text": "List T  Get(ulong timestep, out T lower, out T upper)  - If we were following the above example and we passed  Get(10, out lower, out upper)  into this method, then  lower  would equal  3 ,  upper  would equal  20  and the returned value will be  3 . This method is useful for if you want to calculate a median or where the value might possibly be between the two values.  List T  GetRange(ulong timestep, int count)  - This method will act exactly like the first  Get  method we learned about in the  Deeper Dive  section above; however, it also will return  n  values before the given timestep. So if we passed in  3  for the  count  then we would get a list of values back where the first element is the target value for that timestep and every element after that is the value stored at the last timestep registered.  T GetRange(ulong timestepMin, ulong timestepMax)  - This method allows you to get all values between two timesteps (including the min and the max).", 
            "title": "Other Get Methods"
        }, 
        {
            "location": "/network-logging/", 
            "text": "Network Logging\n\n\nForge Networking has it's own logging system built in for the purposes of debugging and tracing any errors that may happen during network communication. When an exception is thrown on the networking layer, the logging system will pick that up and process the log. There are currently 2 main forms of logging that is built into the system, the in-game logging and the file system logging. We do not recommend using the in-game logging for any production environment, however we do suggest that you enable file logging for production environments.\n\n\nThe Forge Networking logger will only log network exceptions so it will not have any impact on performance, except if there are many exceptions being thrown (which shouldn't happen unless there is a critical process error in the game). This log does a little more than just log network exceptions however; it also logs exceptions that are thrown by your code during the network transport time. Things such as an invalid parameter to an RPC or an invalid cast being performed by your code. Because of this, we recommend always having this log available when testing your code in order to reduce support tickets on our end and in order to keep you as productive as possible towards your awesome product!\n\n\nHow To Enable Logging\n\n\n\n\nNavigate to Bearded Man Studios IncScripts-\nLogging-\nResourcesBMSLogger\n\n\nHaving the BMSLogger selected, you can then check 'Log To File'\n\n\n\n\nThis will then allow you to log all exceptions and common networking debug logs into the logging folder (including logs that you write).\n\n\nHow to Enable Visible Logging\n\n\nNote: This will allow you to see the logs in the build itself on any device.\n\n\n\n\nNavigate to Bearded Man Studios IncScripts-\nLogging-\nResourcesBMSLogger\n\n\nHaving the BMSLogger selected, you can then check 'Logger Visible'\n\n\n\n\nThe final location of this log file will be dependent on whether it is in the editor or a build.\n\n\nEditor location: Root Unity DirectoryAsset Logsbmslog.txt\n\n\nWindows Build Location: ExecutableDirectoryExecutableName_DataLogsbmslog.txt\n\n\nUsing the Logger yourself for development purposes\n\n\nExample Logging\n\n\nBeardedManStudios.Forge.Logging.BMSLog.Log(\nANYTHING YOU WANT TO LOGHERE!\n);\nBeardedManStudios.Forge.Logging.BMSLog.LogFormat(\nFOLLOWING A FORMAT[{0}]\n, \nANYTHING YOU WANT TO LOG HERE!\n);\nBeardedManStudios.Forge.Logging.BMSLog.LogWarning(\nANYTHING YOU WANT TO LOGHERE!\n);\nBeardedManStudios.Forge.Logging.BMSLog.LogWarningFormat(\nFOLLOWING A FORMAT[{0}]\n, \nANYTHING YOU WANT TO LOG HERE!\n);\nBeardedManStudios.Forge.Logging.BMSLog.LogException([System.Exception]); \nBeardedManStudios.Forge.Logging.BMSLog.LogException(\nANYTHING YOU WANT TOLOG HERE!\n);\nBeardedManStudios.Forge.Logging.BMSLog.LogExceptionFormat(\nFOLLOWING AFORMAT [{0}]\n, \nANYTHING YOU WANT TO LOG HERE!\n);\n\n\n\n\nAbove is code examples of how to call the logger to use it for logging purposes.\n\n\nNote: All exceptions will automatically be logged, so put them in places that should never be called frequently, useful for testing on builds and figuring out what went wrong on the network.", 
            "title": "Debugging"
        }, 
        {
            "location": "/network-logging/#network-logging", 
            "text": "Forge Networking has it's own logging system built in for the purposes of debugging and tracing any errors that may happen during network communication. When an exception is thrown on the networking layer, the logging system will pick that up and process the log. There are currently 2 main forms of logging that is built into the system, the in-game logging and the file system logging. We do not recommend using the in-game logging for any production environment, however we do suggest that you enable file logging for production environments.  The Forge Networking logger will only log network exceptions so it will not have any impact on performance, except if there are many exceptions being thrown (which shouldn't happen unless there is a critical process error in the game). This log does a little more than just log network exceptions however; it also logs exceptions that are thrown by your code during the network transport time. Things such as an invalid parameter to an RPC or an invalid cast being performed by your code. Because of this, we recommend always having this log available when testing your code in order to reduce support tickets on our end and in order to keep you as productive as possible towards your awesome product!  How To Enable Logging   Navigate to Bearded Man Studios IncScripts- Logging- ResourcesBMSLogger  Having the BMSLogger selected, you can then check 'Log To File'   This will then allow you to log all exceptions and common networking debug logs into the logging folder (including logs that you write).  How to Enable Visible Logging  Note: This will allow you to see the logs in the build itself on any device.   Navigate to Bearded Man Studios IncScripts- Logging- ResourcesBMSLogger  Having the BMSLogger selected, you can then check 'Logger Visible'   The final location of this log file will be dependent on whether it is in the editor or a build.  Editor location: Root Unity DirectoryAsset Logsbmslog.txt  Windows Build Location: ExecutableDirectoryExecutableName_DataLogsbmslog.txt  Using the Logger yourself for development purposes", 
            "title": "Network Logging"
        }, 
        {
            "location": "/network-logging/#example-logging", 
            "text": "BeardedManStudios.Forge.Logging.BMSLog.Log( ANYTHING YOU WANT TO LOGHERE! );\nBeardedManStudios.Forge.Logging.BMSLog.LogFormat( FOLLOWING A FORMAT[{0}] ,  ANYTHING YOU WANT TO LOG HERE! );\nBeardedManStudios.Forge.Logging.BMSLog.LogWarning( ANYTHING YOU WANT TO LOGHERE! );\nBeardedManStudios.Forge.Logging.BMSLog.LogWarningFormat( FOLLOWING A FORMAT[{0}] ,  ANYTHING YOU WANT TO LOG HERE! );\nBeardedManStudios.Forge.Logging.BMSLog.LogException([System.Exception]); \nBeardedManStudios.Forge.Logging.BMSLog.LogException( ANYTHING YOU WANT TOLOG HERE! );\nBeardedManStudios.Forge.Logging.BMSLog.LogExceptionFormat( FOLLOWING AFORMAT [{0}] ,  ANYTHING YOU WANT TO LOG HERE! );  Above is code examples of how to call the logger to use it for logging purposes.  Note: All exceptions will automatically be logged, so put them in places that should never be called frequently, useful for testing on builds and figuring out what went wrong on the network.", 
            "title": "Example Logging"
        }, 
        {
            "location": "/working-with-multiple-sockets/", 
            "text": "Working With Multiple Sockets\n\n\nWorking in Forge Networking you may have found that it is extremely easy to setup a server and then setup a client to communicate with each other. Just in case you have forgotten, lets take a trip down memory lane:\n\n\nushort myPort = 15937;\nUDPServer myServer = new UDPServer(32); // Only allowing 32 connections to this server\nmyServer.Connect(port: myPort);\n\n\n\n\nLooking above you might be thinking \"wow, why use any other networking solution\" and that is a very good question. Alright, so sure, it is easy to make a server... so how would you go about making 3 servers that run at the same time huh!? The anser is easy, let us do this through example below:\n\n\nUDPServer server1 = new UDPServer(32); // Only allowing 32 connections to this UDP server\nserver1.Connect();\n\nushort myPort = 15959;\nTCPServer server2 = new TCPServer(364); // Only allowing 64 connections to this TCP server\nserver2.Connect(myPort);\n\nUDPServer server3 = new UDPServer(1024); // Only allowing 1024 connections to this UDP server\nserver3.Connect(myPort + 1);\n\n\n\n\nAnd just like that we have 3 servers \nserver1\n, \nserver2\n, and \nserver3\n. These three servers are 3 different servers and manage their own players, network objects, rpcs, and pretty much everything else. Be warned, with great power comes great responsibility! You must always be aware of what networker is being communicated with and also know that the \nNetworkManager\n can only manage 1 NetWorker for the game. That means that the Instantiate methods and everything else that works with the netwrok on the \nNetworkManager\n is for that \"main\" NetWorker. This means you need to do the work of disconnecting these servers when the application exits as well, otherwise the application will hang when the user tries to exit. You are also responsible for managing the references to these NetWorkers as well.\n\n\nMatching Players on Separate NetWorkers\n\n\nWhat kind of guys would we be if we didn't tell you about the awesome \nNetWorker::FindMatchingPlayer\n method. Each NetWorker has a method \nFindMatchingPlayer\n that can be called to find players that match across the different NetWorkers. \nRemember\n that just because a player is id \n22\n on NetWorkerA doesn't mean it will be \n22\n on NetWorkerB.", 
            "title": "Working With Multiple Sockets"
        }, 
        {
            "location": "/working-with-multiple-sockets/#working-with-multiple-sockets", 
            "text": "Working in Forge Networking you may have found that it is extremely easy to setup a server and then setup a client to communicate with each other. Just in case you have forgotten, lets take a trip down memory lane:  ushort myPort = 15937;\nUDPServer myServer = new UDPServer(32); // Only allowing 32 connections to this server\nmyServer.Connect(port: myPort);  Looking above you might be thinking \"wow, why use any other networking solution\" and that is a very good question. Alright, so sure, it is easy to make a server... so how would you go about making 3 servers that run at the same time huh!? The anser is easy, let us do this through example below:  UDPServer server1 = new UDPServer(32); // Only allowing 32 connections to this UDP server\nserver1.Connect();\n\nushort myPort = 15959;\nTCPServer server2 = new TCPServer(364); // Only allowing 64 connections to this TCP server\nserver2.Connect(myPort);\n\nUDPServer server3 = new UDPServer(1024); // Only allowing 1024 connections to this UDP server\nserver3.Connect(myPort + 1);  And just like that we have 3 servers  server1 ,  server2 , and  server3 . These three servers are 3 different servers and manage their own players, network objects, rpcs, and pretty much everything else. Be warned, with great power comes great responsibility! You must always be aware of what networker is being communicated with and also know that the  NetworkManager  can only manage 1 NetWorker for the game. That means that the Instantiate methods and everything else that works with the netwrok on the  NetworkManager  is for that \"main\" NetWorker. This means you need to do the work of disconnecting these servers when the application exits as well, otherwise the application will hang when the user tries to exit. You are also responsible for managing the references to these NetWorkers as well.", 
            "title": "Working With Multiple Sockets"
        }, 
        {
            "location": "/working-with-multiple-sockets/#matching-players-on-separate-networkers", 
            "text": "What kind of guys would we be if we didn't tell you about the awesome  NetWorker::FindMatchingPlayer  method. Each NetWorker has a method  FindMatchingPlayer  that can be called to find players that match across the different NetWorkers.  Remember  that just because a player is id  22  on NetWorkerA doesn't mean it will be  22  on NetWorkerB.", 
            "title": "Matching Players on Separate NetWorkers"
        }, 
        {
            "location": "/nat-hole-punching/", 
            "text": "NAT Hole Punching\n\n\nNat hole punching is a way for users behind a firewall to be able to connect to each other without requireing them to open their firewall ports on their router. To do this, it requires a special server that is dedicated to registering hosts and keeping an open communication with that game host. When a client requests to join a host that is behind a NAT they will communicate with the NAT service host. This NAT service host will then act as a delegate to request that the game host begin communications with the requesting client.\n\n\nWhen you look at the \nConnect\n method of the \nServerUDP\n and \nClientUDP\n classes you will notice that there are 2 optional parameters related to nat traversal. One is the NAT host address and the other is the NAT server port. When you provide a NAT host address to the \nConnect\n method on a \nServerUDP\n object, you will be telling the server where it needs to register itself and you will be opening communication with the NAT server for it to forward client connection requests. When you provide a NAT host address to the \nConnect\n method on a \nClientUDP\n object, you will be telling the client to communicate with that specific NAT host to open communications with the desired server.\n\n\nSetting the correct NAT host in the \nConnect\n method of the \nServerUDP\n and \nClientUDP\n is all you will need to do in order to enable NAT hole punching in your application.\n\n\nVideo Tutorial On How To Test", 
            "title": "NAT Hole Punching"
        }, 
        {
            "location": "/nat-hole-punching/#nat-hole-punching", 
            "text": "Nat hole punching is a way for users behind a firewall to be able to connect to each other without requireing them to open their firewall ports on their router. To do this, it requires a special server that is dedicated to registering hosts and keeping an open communication with that game host. When a client requests to join a host that is behind a NAT they will communicate with the NAT service host. This NAT service host will then act as a delegate to request that the game host begin communications with the requesting client.  When you look at the  Connect  method of the  ServerUDP  and  ClientUDP  classes you will notice that there are 2 optional parameters related to nat traversal. One is the NAT host address and the other is the NAT server port. When you provide a NAT host address to the  Connect  method on a  ServerUDP  object, you will be telling the server where it needs to register itself and you will be opening communication with the NAT server for it to forward client connection requests. When you provide a NAT host address to the  Connect  method on a  ClientUDP  object, you will be telling the client to communicate with that specific NAT host to open communications with the desired server.  Setting the correct NAT host in the  Connect  method of the  ServerUDP  and  ClientUDP  is all you will need to do in order to enable NAT hole punching in your application.", 
            "title": "NAT Hole Punching"
        }, 
        {
            "location": "/nat-hole-punching/#video-tutorial-on-how-to-test", 
            "text": "", 
            "title": "Video Tutorial On How To Test"
        }, 
        {
            "location": "/lan-discovery/", 
            "text": "UDP LAN Discovery\n\n\nLAN Discovery is a way for you to quickly find other game servers on the local area network. This is done by sending out a broadcast message on the local network that gets picked up by the game servers that are currently running. When they receive the lan discovery request they respond to the sender to let the sender know the IP addresses and port numbers that are available. There is only 1 method that needs to be called to use LAN Discovery in Forge Netwroking:\n\n\nNetWorker.RefreshLocalUdpListings();\n\n\n\n\nThe above is a static method that is called to trigger the request. Since this request is a threaded request, you can not expect to have any results immediately after the request has been made. So often you will want to listen for the various servers to respond. Below is an example of how to do this:\n\n\nNetWorker.localServerLocated += LocalServerLocated;\nNetWorker.RefreshLocalUdpListings();\n\n// ... Some code and stuff\n\nprivate void LocalServerLocated(NetWorker.BroadcastEndpoints endpoint)\n{\n    Debug.Log(\nFound endpoint: \n + endpoint.Address + \n:\n + endpoint.Port);\n}\n\n\n\n\nYou can replace the above debug log with whatever code you would like. The endpoint contains the server that has responded (it's address and port number). With this information you are able to connect to the server.\n\n\nRefreshLocalUdpListings\n\n\nNotice that this is a refresh method, that means that you will need to call it each time you want to refresh the listings of servers on the network. This method can be called at an interval if you would like or you could have your players click a button to invoke it. Also notice that the \nRefreshLocalUdpListings\n takes in an argument (time in milliseconds) to wait for server responses. The default is 1000 (1 second). If a server doesn't respond in that amount of time it will not be counted. If you do not want to rely on the event callback alone you can also get the listings of servers from the \nNetWorker.LocalEndpoints\n list.", 
            "title": "LAN Discovery"
        }, 
        {
            "location": "/lan-discovery/#udp-lan-discovery", 
            "text": "LAN Discovery is a way for you to quickly find other game servers on the local area network. This is done by sending out a broadcast message on the local network that gets picked up by the game servers that are currently running. When they receive the lan discovery request they respond to the sender to let the sender know the IP addresses and port numbers that are available. There is only 1 method that needs to be called to use LAN Discovery in Forge Netwroking:  NetWorker.RefreshLocalUdpListings();  The above is a static method that is called to trigger the request. Since this request is a threaded request, you can not expect to have any results immediately after the request has been made. So often you will want to listen for the various servers to respond. Below is an example of how to do this:  NetWorker.localServerLocated += LocalServerLocated;\nNetWorker.RefreshLocalUdpListings();\n\n// ... Some code and stuff\n\nprivate void LocalServerLocated(NetWorker.BroadcastEndpoints endpoint)\n{\n    Debug.Log( Found endpoint:   + endpoint.Address +  :  + endpoint.Port);\n}  You can replace the above debug log with whatever code you would like. The endpoint contains the server that has responded (it's address and port number). With this information you are able to connect to the server.", 
            "title": "UDP LAN Discovery"
        }, 
        {
            "location": "/lan-discovery/#refreshlocaludplistings", 
            "text": "Notice that this is a refresh method, that means that you will need to call it each time you want to refresh the listings of servers on the network. This method can be called at an interval if you would like or you could have your players click a button to invoke it. Also notice that the  RefreshLocalUdpListings  takes in an argument (time in milliseconds) to wait for server responses. The default is 1000 (1 second). If a server doesn't respond in that amount of time it will not be counted. If you do not want to rely on the event callback alone you can also get the listings of servers from the  NetWorker.LocalEndpoints  list.", 
            "title": "RefreshLocalUdpListings"
        }, 
        {
            "location": "/offline-mode/", 
            "text": "How to Make \"Offline\" Mode\n\n\nSomething you may be curious about is how you can make your game both single player and multi-player. Your main problem is probably going to be trying to figure out how you can separate all your RPC calls and your offline direct calls. The thing that may suprise you is if we were to say that there is no need for the distinction between \"Online\" and \"Offline\" code.\n\n\nThe Solo Server\n\n\nSo if you think about it, single player could very well be a server that has the following attributes:\n1. Does not register with a master server\n2. Does not register with a nat traversal server\n3. Does not accept any connections (max players is 0)\n4. Blocks any other connection attempts\n\n\nWell this makes sense so far, if a server doesn't accept any clients then technically it is nothing more than an offline game. However, what about the RPC calls and the vairious other networked things like the networkObject? Well, the answer is simple, Forge Networking was built to where the server isolation is offline play. If there are no connections to the server, it will call all RPCs directly without any network layer involved for sending (it doesn't send to itself, just runs the method locally). Below is an example of a server put into an \noffline\n like state:\n\n\n// Zero connections allowed to this server\nNetWorker server = new UdpServer(0);\nserver.Connect();\n\n// Block all connections to skip the validation phase\n((IServer)server).StopAcceptingConnections();\n\n\n\n\nNotes\n\n\nWhen you specify receivers that do not include the server, such as \nReceivers.Others\n then the server will not call the method, even with no other connections.", 
            "title": "Offline Mode"
        }, 
        {
            "location": "/offline-mode/#how-to-make-offline-mode", 
            "text": "Something you may be curious about is how you can make your game both single player and multi-player. Your main problem is probably going to be trying to figure out how you can separate all your RPC calls and your offline direct calls. The thing that may suprise you is if we were to say that there is no need for the distinction between \"Online\" and \"Offline\" code.", 
            "title": "How to Make \"Offline\" Mode"
        }, 
        {
            "location": "/offline-mode/#the-solo-server", 
            "text": "So if you think about it, single player could very well be a server that has the following attributes:\n1. Does not register with a master server\n2. Does not register with a nat traversal server\n3. Does not accept any connections (max players is 0)\n4. Blocks any other connection attempts  Well this makes sense so far, if a server doesn't accept any clients then technically it is nothing more than an offline game. However, what about the RPC calls and the vairious other networked things like the networkObject? Well, the answer is simple, Forge Networking was built to where the server isolation is offline play. If there are no connections to the server, it will call all RPCs directly without any network layer involved for sending (it doesn't send to itself, just runs the method locally). Below is an example of a server put into an  offline  like state:  // Zero connections allowed to this server\nNetWorker server = new UdpServer(0);\nserver.Connect();\n\n// Block all connections to skip the validation phase\n((IServer)server).StopAcceptingConnections();", 
            "title": "The Solo Server"
        }, 
        {
            "location": "/offline-mode/#notes", 
            "text": "When you specify receivers that do not include the server, such as  Receivers.Others  then the server will not call the method, even with no other connections.", 
            "title": "Notes"
        }, 
        {
            "location": "/lobby/", 
            "text": "Lobby System\n\n\nThe lobby system is a way for you to be able to manage your existing players on your particular server on a global level.\n\n\nWith this system, you are able to do the following:\n\n\n\n\nSet Player Name (string)\n\n\nSet Avatar ID (int)\n\n\nSet Team ID (int)\n\n\nSend a message to everyone like the chat system (string)\n\n\nKick player\n\n\nStart game button\n\n\n\n\nThis system allows us to be able to control the list of players and functionality of those players at runtime. There is a basic dummy lobby master class that will be the default system chosen until overridden with either our custom Lobby Master (unity implementation) or your own Custom Lobby Master. Because of the way it is written for forge, this system does not need to be ran from Unity and can work perfectly fine on your linux builds (more on this later).\n\n\nUsing the Existing Lobby System\n\n\nThe existing lobby system is available out of the box to be used in your application. The one thing you want to check is if you are using the MultiplayerMenu and loading into your game then you'll be fine following skipping to step #2.\n\n\n\n\nFirst ensure that whatever network loading sequence you are going with, that the host will call the following code.\n\n\n\n\nLobbyService.Instance.Initialize(serversocket);\n\n\n\n\nWhere the 'server socket' would be the socket that the host makes when hosting. You can see this being done in the example MultiplayerMenu.cs that is included with Forge Networking.\n\n\n\n\nAdd the lobby system prefab (LobbySystem.prefab) to your game scene, or wherever you want to include the lobby system to your existing game.\n\n\nIf you don't have an event system \n a standalone input module in your scene already, then you would need to make sure they are in there to interact with the lobby items as well.\n\n\n\n\nThe lobby player item prefab is just a prefab that stores the users name, color, buttons and the like. You are free to modify this prefab to your liking as well as the lobby system itself.\n\n\n\n\n\n\nCongratulations you have officially added the lobby system to your game and can start using it! Change your name in your player top let, and start talking in the chat bottom left, change the UI to however you please as well as the prefab.\n\n\n\n\n\n\nPS- To get better results, make sure in the build settings Multiplayermenu -\n \nLobby\n -\n Game\n\n\n\n\n\n\nLobby Service API Calls\n\n\nThe lobby service has built in api calls that are currently being used in the LobbyManager. For reason of explaining it further, these api calls can be called from anywhere in code as long as you are connected to a socket. This allows you to change the users name from anywhere other than the built in Lobby system.\n\n\nstring newName = \n;\nLobbyService.Instance.SetName(newName);\n\nuint playerID = 999; \n//Only the server will actually kick players\nLobbyService.Instance.KickPlayer(playerID);\n\nint avatarID = -1;\nLobbyService.Instance.SetAvatar(avatarID);\n\nint teamID = -1;\nLobbyService.Instance.SetTeamId(teamID);\n\nstring chatMessage = \n;\nLobbyService.Instance.SendPlayerMessage(chatMessage);\n\n\n\n\nHere is some examples of what the data structure of sending these api calls would look like. As stated before, these can be called anywhere in your code and your LobbyMaster/LobbyManager would handle the data received from other players.\n\n\nYou can easily grab the list of players by doing the following:\n\n\nList\nIClientMockPlayer\n currentPlayers = LobbyService.Instance.MasterLobby.LobbyPlayers;\n\n\n\n\nThis list will auto populate with the users that join and leave/disconnect.\n\n\nLobby System Enhancements\n\n\nThis section is for advanced users who want to expand the lobby system past what is already there for further functionality.\n\n\nPlease take a look at the following classes:\nLobbyManager.cs\nLobbyPlayer.cs\nLobbyPlayerItem.cs\n\n\nLobby Player Manager\n\n\nThe lobby player manager is an example of how you would expand the lobby system itself. Right now it implements the functionality of ILobbyMaster and replaces the mock lobby system with this one during setup. You'll see that it replaces it in SetupComplete() with the following code.\n\n\nLobbyService.Instance.SetLobbyMaster(this);\n\n\n\n\nSetupComplete() also creates the player item for himself as well as for the already connected players.\n\n\nYou'll notice that you can modify the data however you please and expand on it given the Interface API that is implemented because of the system. If you want to fully understand how the implementation is done, please take a further in-depth look at LobbyService.cs (which we will not cover in this documentation at the moment as it is a lot to go over).\n\n\nLobby Player\n\n\nThe purpose of the lobby player is to implement the IClientMockPlayer which will allow you to implement the basic data that we require for the lobby system to work and expand on it with your own custom data. Just note that if you want that data to be synced properly for any additional logic, you would have to implement the code to be in the lobby manager as well as the LobbyService, otherwise you can always sync the data from other networked objects to the lobby manager with RPC's as well. We will have to revisit this to help make expanding the player data, but just or now I recommend taking a look at the way the data is structured and used in the Lobby Manager in order to populate it as well as the Lobby Service.\n\n\nThe Lobby Player is used extensively on our Lobby Manager to store the current state of a given player.\n\n\nLobby Player Item\n\n\nThe lobby player item prefab is used to populate itself with the data of a given player passed in. This is mostly just a ui helper and is not necessary for the player to exist as the lobby system itself will always have all the current players. For demonstration purposes we have included a simple prefab that is being populated in the provided lobby system included with Forge Networking. You are free to populate and change the ui however you please with this data passed in.\n\n\nWe store a reference to the Lobby system itself, but you can easily do other ways of sending the button calls to your own custom lobby system by passing in the actions and the like. This way you would remove the need to have the lobby system being stored as a reference in every lobby player item. The reason we stuck with this format is to just showcase the ease of expanding this item with future features that we plan on adding.\n\n\nStart Game\n\n\nThe start game button sends all the players to the Game scene. How this is setup in build settings. \n\n\nMultiplayerMenu -\n Lobby Scene -\n Game \n\n\nHere is the script of Start Game, if you want to use it in other applications.\n\n\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class StartGame : MonoBehaviour\n{\npublic void startGame (int Levelnum)\n    { \n        Application.LoadLevel(Levelnum);\n    }\n}\n\n\n\n\nCreate Your Own Lobby (Easier way)\n\n\n1) Create a new scene.\n2) Add the LobbySystem Prefab.\n3) Change the UI, Change the buttons and edit/copy off of the LobbySystem Prefab.\n4) make sure the scripts in the LobbySystem prefab go into the desired area in the scene as well as the Inspector (Button scripts go in the button scripts, etc).\n5) add it to MultiplayerMenu -\n \nLobby\n -\n Game\n\n\nLobby Scene\n\n\nThis Lobby can be used for your game or used as a reference for you to make your own Lobby. This is the Game-Scene.\n\n\n\nLobby Overview\n\n\nThis system allows us to be able to control the list of players and functionality of those players at runtime. There is a basic dummy lobby master class that will be the default system chosen until overridden with either our custom Lobby Master (unity implementation) or your own Custom Lobby Master. Because of the way it is written for forge, this system does not need to be ran from Unity and can work perfectly fine on your linux builds (more on this later).\n\n\nTo Be Continued\n\n\nAs the lobby system is a great system to add to your game, we are very open to suggestions that can add further features to this as well as give the users the ability to chime in over Discord. As we add more features expect this documentation to cover that and expand.", 
            "title": "Lobby System"
        }, 
        {
            "location": "/lobby/#lobby-system", 
            "text": "The lobby system is a way for you to be able to manage your existing players on your particular server on a global level.  With this system, you are able to do the following:   Set Player Name (string)  Set Avatar ID (int)  Set Team ID (int)  Send a message to everyone like the chat system (string)  Kick player  Start game button   This system allows us to be able to control the list of players and functionality of those players at runtime. There is a basic dummy lobby master class that will be the default system chosen until overridden with either our custom Lobby Master (unity implementation) or your own Custom Lobby Master. Because of the way it is written for forge, this system does not need to be ran from Unity and can work perfectly fine on your linux builds (more on this later).", 
            "title": "Lobby System"
        }, 
        {
            "location": "/lobby/#using-the-existing-lobby-system", 
            "text": "The existing lobby system is available out of the box to be used in your application. The one thing you want to check is if you are using the MultiplayerMenu and loading into your game then you'll be fine following skipping to step #2.   First ensure that whatever network loading sequence you are going with, that the host will call the following code.   LobbyService.Instance.Initialize(serversocket);  Where the 'server socket' would be the socket that the host makes when hosting. You can see this being done in the example MultiplayerMenu.cs that is included with Forge Networking.   Add the lobby system prefab (LobbySystem.prefab) to your game scene, or wherever you want to include the lobby system to your existing game.  If you don't have an event system   a standalone input module in your scene already, then you would need to make sure they are in there to interact with the lobby items as well.   The lobby player item prefab is just a prefab that stores the users name, color, buttons and the like. You are free to modify this prefab to your liking as well as the lobby system itself.    Congratulations you have officially added the lobby system to your game and can start using it! Change your name in your player top let, and start talking in the chat bottom left, change the UI to however you please as well as the prefab.    PS- To get better results, make sure in the build settings Multiplayermenu -   Lobby  -  Game", 
            "title": "Using the Existing Lobby System"
        }, 
        {
            "location": "/lobby/#lobby-service-api-calls", 
            "text": "The lobby service has built in api calls that are currently being used in the LobbyManager. For reason of explaining it further, these api calls can be called from anywhere in code as long as you are connected to a socket. This allows you to change the users name from anywhere other than the built in Lobby system.  string newName =  ;\nLobbyService.Instance.SetName(newName);\n\nuint playerID = 999; \n//Only the server will actually kick players\nLobbyService.Instance.KickPlayer(playerID);\n\nint avatarID = -1;\nLobbyService.Instance.SetAvatar(avatarID);\n\nint teamID = -1;\nLobbyService.Instance.SetTeamId(teamID);\n\nstring chatMessage =  ;\nLobbyService.Instance.SendPlayerMessage(chatMessage);  Here is some examples of what the data structure of sending these api calls would look like. As stated before, these can be called anywhere in your code and your LobbyMaster/LobbyManager would handle the data received from other players.  You can easily grab the list of players by doing the following:  List IClientMockPlayer  currentPlayers = LobbyService.Instance.MasterLobby.LobbyPlayers;  This list will auto populate with the users that join and leave/disconnect.", 
            "title": "Lobby Service API Calls"
        }, 
        {
            "location": "/lobby/#lobby-system-enhancements", 
            "text": "This section is for advanced users who want to expand the lobby system past what is already there for further functionality.  Please take a look at the following classes:\nLobbyManager.cs\nLobbyPlayer.cs\nLobbyPlayerItem.cs", 
            "title": "Lobby System Enhancements"
        }, 
        {
            "location": "/lobby/#lobby-player-manager", 
            "text": "The lobby player manager is an example of how you would expand the lobby system itself. Right now it implements the functionality of ILobbyMaster and replaces the mock lobby system with this one during setup. You'll see that it replaces it in SetupComplete() with the following code.  LobbyService.Instance.SetLobbyMaster(this);  SetupComplete() also creates the player item for himself as well as for the already connected players.  You'll notice that you can modify the data however you please and expand on it given the Interface API that is implemented because of the system. If you want to fully understand how the implementation is done, please take a further in-depth look at LobbyService.cs (which we will not cover in this documentation at the moment as it is a lot to go over).", 
            "title": "Lobby Player Manager"
        }, 
        {
            "location": "/lobby/#lobby-player", 
            "text": "The purpose of the lobby player is to implement the IClientMockPlayer which will allow you to implement the basic data that we require for the lobby system to work and expand on it with your own custom data. Just note that if you want that data to be synced properly for any additional logic, you would have to implement the code to be in the lobby manager as well as the LobbyService, otherwise you can always sync the data from other networked objects to the lobby manager with RPC's as well. We will have to revisit this to help make expanding the player data, but just or now I recommend taking a look at the way the data is structured and used in the Lobby Manager in order to populate it as well as the Lobby Service.  The Lobby Player is used extensively on our Lobby Manager to store the current state of a given player.", 
            "title": "Lobby Player"
        }, 
        {
            "location": "/lobby/#lobby-player-item", 
            "text": "The lobby player item prefab is used to populate itself with the data of a given player passed in. This is mostly just a ui helper and is not necessary for the player to exist as the lobby system itself will always have all the current players. For demonstration purposes we have included a simple prefab that is being populated in the provided lobby system included with Forge Networking. You are free to populate and change the ui however you please with this data passed in.  We store a reference to the Lobby system itself, but you can easily do other ways of sending the button calls to your own custom lobby system by passing in the actions and the like. This way you would remove the need to have the lobby system being stored as a reference in every lobby player item. The reason we stuck with this format is to just showcase the ease of expanding this item with future features that we plan on adding.", 
            "title": "Lobby Player Item"
        }, 
        {
            "location": "/lobby/#start-game", 
            "text": "The start game button sends all the players to the Game scene. How this is setup in build settings.   MultiplayerMenu -  Lobby Scene -  Game   Here is the script of Start Game, if you want to use it in other applications.  using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class StartGame : MonoBehaviour\n{\npublic void startGame (int Levelnum)\n    { \n        Application.LoadLevel(Levelnum);\n    }\n}", 
            "title": "Start Game"
        }, 
        {
            "location": "/lobby/#create-your-own-lobby-easier-way", 
            "text": "1) Create a new scene.\n2) Add the LobbySystem Prefab.\n3) Change the UI, Change the buttons and edit/copy off of the LobbySystem Prefab.\n4) make sure the scripts in the LobbySystem prefab go into the desired area in the scene as well as the Inspector (Button scripts go in the button scripts, etc).\n5) add it to MultiplayerMenu -   Lobby  -  Game", 
            "title": "Create Your Own Lobby (Easier way)"
        }, 
        {
            "location": "/lobby/#lobby-scene", 
            "text": "This Lobby can be used for your game or used as a reference for you to make your own Lobby. This is the Game-Scene.", 
            "title": "Lobby Scene"
        }, 
        {
            "location": "/lobby/#lobby-overview", 
            "text": "This system allows us to be able to control the list of players and functionality of those players at runtime. There is a basic dummy lobby master class that will be the default system chosen until overridden with either our custom Lobby Master (unity implementation) or your own Custom Lobby Master. Because of the way it is written for forge, this system does not need to be ran from Unity and can work perfectly fine on your linux builds (more on this later).", 
            "title": "Lobby Overview"
        }, 
        {
            "location": "/lobby/#to-be-continued", 
            "text": "As the lobby system is a great system to add to your game, we are very open to suggestions that can add further features to this as well as give the users the ability to chime in over Discord. As we add more features expect this documentation to cover that and expand.", 
            "title": "To Be Continued"
        }, 
        {
            "location": "/adding-and-updating-docs/", 
            "text": "Adding and Updating Docs\n\n\nSo you've discovered some new stuff in Forge Networking and you think that it would be important to add documentation around your discovery to share with the community. Great!! We love that and people like you is where real progress comes from :). So lets begin with the requirements to get started:\n\n\n\n\nAccess to GitHub (You can get this by requesting it in Discord and providing your GitHub username)\n\n\nAn updated checkout of your own fork of the \nForge Networking Remastered\n repository\n\n\nA text editor to edit Markdown (.md) files in, we recommend \nVisual Studio Code\n\n\n\n\nAnd that is it! You are officially ready to start adding and updating the documentation via pull requests.\n\n\nCreating a New Page in the Docs\n\n\nWe use MkDocs to generate our searchable documentation so it is extremely easy for you to create your page using Markdown. Below are the steps taken to create your own page:\n\n\n\n\nOpen the \nForgeNetworkingRemastered/docs/mkdocs/docs\n folder in the repo\n\n\nCreate your file, if your page is called \nAzure Setup\n then you will create a file \nazure-setup.md\n in this folder\n\n\nOpen and edit your .md file\n\n\nSave your file\n\n\nOpen the \nForgeNetworkingRemastered/docs/mkdocs/mkdocs.yml\n file\n\n\nAdd your file to the appropriate section under \npages:\n or create a new section if needed\n\n\nCommit your changes and create a pull request\n\n\n\n\nOnce your pull request is accepted, we will run the MkDocs build and your documentation will be up on the website!\n\n\nUpdating an Existing Page in the Docs\n\n\nIf you find an error or feel that something is missing from the documentation you can do make a fix and submit it for review! Below are the steps in updating a page in the documentation:\n\n\n\n\nOpen the \nForgeNetworkingRemastered/docs/mkdocs/docs\n folder in the repo\n\n\nFind the page you want to update, if the page is called \nAzure Setup\n then you will find a file named \nazure-setup.md\n in this folder\n\n\nOpen and edit your .md file\n\n\nSave your file\n\n\nCommit your changes and create a pull request", 
            "title": "Contributing"
        }, 
        {
            "location": "/adding-and-updating-docs/#adding-and-updating-docs", 
            "text": "So you've discovered some new stuff in Forge Networking and you think that it would be important to add documentation around your discovery to share with the community. Great!! We love that and people like you is where real progress comes from :). So lets begin with the requirements to get started:   Access to GitHub (You can get this by requesting it in Discord and providing your GitHub username)  An updated checkout of your own fork of the  Forge Networking Remastered  repository  A text editor to edit Markdown (.md) files in, we recommend  Visual Studio Code   And that is it! You are officially ready to start adding and updating the documentation via pull requests.", 
            "title": "Adding and Updating Docs"
        }, 
        {
            "location": "/adding-and-updating-docs/#creating-a-new-page-in-the-docs", 
            "text": "We use MkDocs to generate our searchable documentation so it is extremely easy for you to create your page using Markdown. Below are the steps taken to create your own page:   Open the  ForgeNetworkingRemastered/docs/mkdocs/docs  folder in the repo  Create your file, if your page is called  Azure Setup  then you will create a file  azure-setup.md  in this folder  Open and edit your .md file  Save your file  Open the  ForgeNetworkingRemastered/docs/mkdocs/mkdocs.yml  file  Add your file to the appropriate section under  pages:  or create a new section if needed  Commit your changes and create a pull request   Once your pull request is accepted, we will run the MkDocs build and your documentation will be up on the website!", 
            "title": "Creating a New Page in the Docs"
        }, 
        {
            "location": "/adding-and-updating-docs/#updating-an-existing-page-in-the-docs", 
            "text": "If you find an error or feel that something is missing from the documentation you can do make a fix and submit it for review! Below are the steps in updating a page in the documentation:   Open the  ForgeNetworkingRemastered/docs/mkdocs/docs  folder in the repo  Find the page you want to update, if the page is called  Azure Setup  then you will find a file named  azure-setup.md  in this folder  Open and edit your .md file  Save your file  Commit your changes and create a pull request", 
            "title": "Updating an Existing Page in the Docs"
        }
    ]
}